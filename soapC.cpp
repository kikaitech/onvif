/* soapC.cpp
   Generated by gSOAP 2.8.109 for onvif.h

gSOAP XML Web services tools
Copyright (C) 2000-2020, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.8.109 2020-12-21 09:42:36 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (soap->fault == NULL)
			return;
	}
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code == NULL)
		soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason == NULL)
		soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
				return NULL;
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	const char **s = soap_faultsubcode(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2 && soap->fault->SOAP_ENV__Reason)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	const char **s = soap_faultstring(soap);
	return s ? *s : NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault == NULL)
		return NULL;
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
			soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
		soap->fault->detail = soap_new_SOAP_ENV__Detail(soap, -1);
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	const char **s = soap_faultdetail(soap);
	return s ? *s : NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, NULL, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, const char *tag, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, tag, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_float:
		return soap_in_float(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_double:
		return soap_in_double(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_in_unsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_in_unsignedInt(soap, tag, NULL, "xsd:unsignedInt");
	case SOAP_TYPE_ULONG64:
		return soap_in_ULONG64(soap, tag, NULL, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_in_dateTime(soap, tag, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_tt__MoveStatus:
		return soap_in_tt__MoveStatus(soap, tag, NULL, "tt:MoveStatus");
	case SOAP_TYPE_tt__PTZPresetTourOperation:
		return soap_in_tt__PTZPresetTourOperation(soap, tag, NULL, "tt:PTZPresetTourOperation");
	case SOAP_TYPE_tt__PTZPresetTourDirection:
		return soap_in_tt__PTZPresetTourDirection(soap, tag, NULL, "tt:PTZPresetTourDirection");
	case SOAP_TYPE_tt__PTZPresetTourState:
		return soap_in_tt__PTZPresetTourState(soap, tag, NULL, "tt:PTZPresetTourState");
	case SOAP_TYPE_tt__ReverseMode:
		return soap_in_tt__ReverseMode(soap, tag, NULL, "tt:ReverseMode");
	case SOAP_TYPE_tt__EFlipMode:
		return soap_in_tt__EFlipMode(soap, tag, NULL, "tt:EFlipMode");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_in_wsa5__FaultCodesType(soap, tag, NULL, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_in_wsa5__RelationshipType(soap, tag, NULL, "wsa5:RelationshipType");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken");
	case SOAP_TYPE_tt__AuxiliaryData:
		return soap_in_tt__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData");
	case SOAP_TYPE_tt__Name:
		return soap_in_tt__Name(soap, tag, NULL, "tt:Name");
	case SOAP_TYPE_tt__StringList:
		return soap_in_tt__StringList(soap, tag, NULL, "tt:StringList");
	case SOAP_TYPE_tt__IntAttrList:
		return soap_in_tt__IntAttrList(soap, tag, NULL, "tt:IntAttrList");
	case SOAP_TYPE_tt__GeoLocation:
		return soap_in_tt__GeoLocation(soap, tag, NULL, "tt:GeoLocation");
	case SOAP_TYPE_tt__PTZMoveStatus:
		return soap_in_tt__PTZMoveStatus(soap, tag, NULL, "tt:PTZMoveStatus");
	case SOAP_TYPE_tt__PTZStatus:
		return soap_in_tt__PTZStatus(soap, tag, NULL, "tt:PTZStatus");
	case SOAP_TYPE_tt__PTZVector:
		return soap_in_tt__PTZVector(soap, tag, NULL, "tt:PTZVector");
	case SOAP_TYPE_tt__Vector1D:
		return soap_in_tt__Vector1D(soap, tag, NULL, "tt:Vector1D");
	case SOAP_TYPE_tt__Vector2D:
		return soap_in_tt__Vector2D(soap, tag, NULL, "tt:Vector2D");
	case SOAP_TYPE_tt__IntRange:
		return soap_in_tt__IntRange(soap, tag, NULL, "tt:IntRange");
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension:
		return soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, NULL, "tt:PTZPresetTourStartingConditionOptionsExtension");
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions:
		return soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, NULL, "tt:PTZPresetTourStartingConditionOptions");
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension:
		return soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, NULL, "tt:PTZPresetTourPresetDetailOptionsExtension");
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions:
		return soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, NULL, "tt:PTZPresetTourPresetDetailOptions");
	case SOAP_TYPE_tt__PTZPresetTourSpotOptions:
		return soap_in_tt__PTZPresetTourSpotOptions(soap, tag, NULL, "tt:PTZPresetTourSpotOptions");
	case SOAP_TYPE_tt__PTZPresetTourOptions:
		return soap_in_tt__PTZPresetTourOptions(soap, tag, NULL, "tt:PTZPresetTourOptions");
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension:
		return soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, NULL, "tt:PTZPresetTourStartingConditionExtension");
	case SOAP_TYPE_tt__PTZPresetTourStartingCondition:
		return soap_in_tt__PTZPresetTourStartingCondition(soap, tag, NULL, "tt:PTZPresetTourStartingCondition");
	case SOAP_TYPE_tt__PTZPresetTourStatusExtension:
		return soap_in_tt__PTZPresetTourStatusExtension(soap, tag, NULL, "tt:PTZPresetTourStatusExtension");
	case SOAP_TYPE_tt__PTZPresetTourStatus:
		return soap_in_tt__PTZPresetTourStatus(soap, tag, NULL, "tt:PTZPresetTourStatus");
	case SOAP_TYPE_tt__PTZPresetTourTypeExtension:
		return soap_in_tt__PTZPresetTourTypeExtension(soap, tag, NULL, "tt:PTZPresetTourTypeExtension");
	case SOAP_TYPE_tt__PTZPresetTourPresetDetail:
		return soap_in_tt__PTZPresetTourPresetDetail(soap, tag, NULL, "tt:PTZPresetTourPresetDetail");
	case SOAP_TYPE_tt__PTZPresetTourSpotExtension:
		return soap_in_tt__PTZPresetTourSpotExtension(soap, tag, NULL, "tt:PTZPresetTourSpotExtension");
	case SOAP_TYPE_tt__PTZPresetTourSpot:
		return soap_in_tt__PTZPresetTourSpot(soap, tag, NULL, "tt:PTZPresetTourSpot");
	case SOAP_TYPE_tt__PTZPresetTourExtension:
		return soap_in_tt__PTZPresetTourExtension(soap, tag, NULL, "tt:PTZPresetTourExtension");
	case SOAP_TYPE_tt__PresetTour:
		return soap_in_tt__PresetTour(soap, tag, NULL, "tt:PresetTour");
	case SOAP_TYPE_tt__PTZPreset:
		return soap_in_tt__PTZPreset(soap, tag, NULL, "tt:PTZPreset");
	case SOAP_TYPE_tt__PTZSpeed:
		return soap_in_tt__PTZSpeed(soap, tag, NULL, "tt:PTZSpeed");
	case SOAP_TYPE_tt__Space1DDescription:
		return soap_in_tt__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription");
	case SOAP_TYPE_tt__Space2DDescription:
		return soap_in_tt__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription");
	case SOAP_TYPE_tt__PTZSpacesExtension:
		return soap_in_tt__PTZSpacesExtension(soap, tag, NULL, "tt:PTZSpacesExtension");
	case SOAP_TYPE_tt__PTZSpaces:
		return soap_in_tt__PTZSpaces(soap, tag, NULL, "tt:PTZSpaces");
	case SOAP_TYPE_tt__ZoomLimits:
		return soap_in_tt__ZoomLimits(soap, tag, NULL, "tt:ZoomLimits");
	case SOAP_TYPE_tt__PanTiltLimits:
		return soap_in_tt__PanTiltLimits(soap, tag, NULL, "tt:PanTiltLimits");
	case SOAP_TYPE_tt__ReverseOptionsExtension:
		return soap_in_tt__ReverseOptionsExtension(soap, tag, NULL, "tt:ReverseOptionsExtension");
	case SOAP_TYPE_tt__ReverseOptions:
		return soap_in_tt__ReverseOptions(soap, tag, NULL, "tt:ReverseOptions");
	case SOAP_TYPE_tt__EFlipOptionsExtension:
		return soap_in_tt__EFlipOptionsExtension(soap, tag, NULL, "tt:EFlipOptionsExtension");
	case SOAP_TYPE_tt__EFlipOptions:
		return soap_in_tt__EFlipOptions(soap, tag, NULL, "tt:EFlipOptions");
	case SOAP_TYPE_tt__PTControlDirectionOptionsExtension:
		return soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, NULL, "tt:PTControlDirectionOptionsExtension");
	case SOAP_TYPE_tt__PTControlDirectionOptions:
		return soap_in_tt__PTControlDirectionOptions(soap, tag, NULL, "tt:PTControlDirectionOptions");
	case SOAP_TYPE_tt__PTZConfigurationOptions2:
		return soap_in_tt__PTZConfigurationOptions2(soap, tag, NULL, "tt:PTZConfigurationOptions2");
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		return soap_in_tt__PTZConfigurationOptions(soap, tag, NULL, "tt:PTZConfigurationOptions");
	case SOAP_TYPE_tt__Reverse:
		return soap_in_tt__Reverse(soap, tag, NULL, "tt:Reverse");
	case SOAP_TYPE_tt__EFlip:
		return soap_in_tt__EFlip(soap, tag, NULL, "tt:EFlip");
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		return soap_in_tt__PTControlDirectionExtension(soap, tag, NULL, "tt:PTControlDirectionExtension");
	case SOAP_TYPE_tt__PTControlDirection:
		return soap_in_tt__PTControlDirection(soap, tag, NULL, "tt:PTControlDirection");
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		return soap_in_tt__PTZConfigurationExtension2(soap, tag, NULL, "tt:PTZConfigurationExtension2");
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return soap_in_tt__PTZConfigurationExtension(soap, tag, NULL, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_tt__PTZConfiguration:
		return soap_in_tt__PTZConfiguration(soap, tag, NULL, "tt:PTZConfiguration");
	case SOAP_TYPE_tt__PTZPresetTourSupportedExtension:
		return soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, NULL, "tt:PTZPresetTourSupportedExtension");
	case SOAP_TYPE_tt__PTZPresetTourSupported:
		return soap_in_tt__PTZPresetTourSupported(soap, tag, NULL, "tt:PTZPresetTourSupported");
	case SOAP_TYPE_tt__PTZNodeExtension2:
		return soap_in_tt__PTZNodeExtension2(soap, tag, NULL, "tt:PTZNodeExtension2");
	case SOAP_TYPE_tt__PTZNodeExtension:
		return soap_in_tt__PTZNodeExtension(soap, tag, NULL, "tt:PTZNodeExtension");
	case SOAP_TYPE_tt__PTZNode:
		return soap_in_tt__PTZNode(soap, tag, NULL, "tt:PTZNode");
	case SOAP_TYPE_tt__ConfigurationEntity:
		return soap_in_tt__ConfigurationEntity(soap, tag, NULL, "tt:ConfigurationEntity");
	case SOAP_TYPE_tt__DurationRange:
		return soap_in_tt__DurationRange(soap, tag, NULL, "tt:DurationRange");
	case SOAP_TYPE_tt__FloatRange:
		return soap_in_tt__FloatRange(soap, tag, NULL, "tt:FloatRange");
	case SOAP_TYPE_tt__DeviceEntity:
		return soap_in_tt__DeviceEntity(soap, tag, NULL, "tt:DeviceEntity");
	case SOAP_TYPE_tptz__Capabilities:
		return soap_in_tptz__Capabilities(soap, tag, NULL, "tptz:Capabilities");
	case SOAP_TYPE_xsd__token:
		return soap_in_xsd__token(soap, tag, NULL, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_in_xsd__nonNegativeInteger(soap, tag, NULL, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, tag, NULL, "xsd:integer");
	case SOAP_TYPE_xsd__duration:
		return soap_in_xsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_xsd__anyURI:
		return soap_in_xsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_in_xsd__anySimpleType(soap, tag, NULL, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__NCName:
		return soap_in_xsd__NCName(soap, tag, NULL, "xsd:NCName");
	case SOAP_TYPE_xsd__hexBinary:
		return soap_in_xsd__hexBinary(soap, tag, NULL, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return soap_in_xsd__base64Binary(soap, tag, NULL, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_in_xsd__QName(soap, tag, NULL, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return soap_in_xsd__anyType(soap, tag, NULL, "xsd:anyType");
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return soap_in_SOAP_ENV__Envelope(soap, tag, NULL, "SOAP-ENV:Envelope");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_in_chan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_in_wsa5__ProblemActionType(soap, tag, NULL, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_in_wsa5__RelatesToType(soap, tag, NULL, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_in_wsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, "wsa5:EndpointReferenceType");
	case SOAP_TYPE_PointerTo_tptz__MoveAndStartTracking:
		return soap_in_PointerTo_tptz__MoveAndStartTracking(soap, tag, NULL, "tptz:MoveAndStartTracking");
	case SOAP_TYPE_PointerTo_tptz__GetCompatibleConfigurations:
		return soap_in_PointerTo_tptz__GetCompatibleConfigurations(soap, tag, NULL, "tptz:GetCompatibleConfigurations");
	case SOAP_TYPE_PointerTo_tptz__RemovePresetTour:
		return soap_in_PointerTo_tptz__RemovePresetTour(soap, tag, NULL, "tptz:RemovePresetTour");
	case SOAP_TYPE_PointerTo_tptz__OperatePresetTour:
		return soap_in_PointerTo_tptz__OperatePresetTour(soap, tag, NULL, "tptz:OperatePresetTour");
	case SOAP_TYPE_PointerTo_tptz__ModifyPresetTour:
		return soap_in_PointerTo_tptz__ModifyPresetTour(soap, tag, NULL, "tptz:ModifyPresetTour");
	case SOAP_TYPE_PointerTo_tptz__CreatePresetTour:
		return soap_in_PointerTo_tptz__CreatePresetTour(soap, tag, NULL, "tptz:CreatePresetTour");
	case SOAP_TYPE_PointerTo_tptz__GetPresetTourOptions:
		return soap_in_PointerTo_tptz__GetPresetTourOptions(soap, tag, NULL, "tptz:GetPresetTourOptions");
	case SOAP_TYPE_PointerTo_tptz__GetPresetTour:
		return soap_in_PointerTo_tptz__GetPresetTour(soap, tag, NULL, "tptz:GetPresetTour");
	case SOAP_TYPE_PointerTo_tptz__GetPresetTours:
		return soap_in_PointerTo_tptz__GetPresetTours(soap, tag, NULL, "tptz:GetPresetTours");
	case SOAP_TYPE_PointerTo_tptz__Stop:
		return soap_in_PointerTo_tptz__Stop(soap, tag, NULL, "tptz:Stop");
	case SOAP_TYPE_PointerTo_tptz__GeoMove:
		return soap_in_PointerTo_tptz__GeoMove(soap, tag, NULL, "tptz:GeoMove");
	case SOAP_TYPE_PointerTo_tptz__AbsoluteMove:
		return soap_in_PointerTo_tptz__AbsoluteMove(soap, tag, NULL, "tptz:AbsoluteMove");
	case SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommand:
		return soap_in_PointerTo_tptz__SendAuxiliaryCommand(soap, tag, NULL, "tptz:SendAuxiliaryCommand");
	case SOAP_TYPE_PointerTo_tptz__RelativeMove:
		return soap_in_PointerTo_tptz__RelativeMove(soap, tag, NULL, "tptz:RelativeMove");
	case SOAP_TYPE_PointerTo_tptz__ContinuousMove:
		return soap_in_PointerTo_tptz__ContinuousMove(soap, tag, NULL, "tptz:ContinuousMove");
	case SOAP_TYPE_PointerTo_tptz__SetHomePosition:
		return soap_in_PointerTo_tptz__SetHomePosition(soap, tag, NULL, "tptz:SetHomePosition");
	case SOAP_TYPE_PointerTo_tptz__GotoHomePosition:
		return soap_in_PointerTo_tptz__GotoHomePosition(soap, tag, NULL, "tptz:GotoHomePosition");
	case SOAP_TYPE_PointerTo_tptz__GetConfigurationOptions:
		return soap_in_PointerTo_tptz__GetConfigurationOptions(soap, tag, NULL, "tptz:GetConfigurationOptions");
	case SOAP_TYPE_PointerTo_tptz__SetConfiguration:
		return soap_in_PointerTo_tptz__SetConfiguration(soap, tag, NULL, "tptz:SetConfiguration");
	case SOAP_TYPE_PointerTo_tptz__GetNode:
		return soap_in_PointerTo_tptz__GetNode(soap, tag, NULL, "tptz:GetNode");
	case SOAP_TYPE_PointerTo_tptz__GetNodes:
		return soap_in_PointerTo_tptz__GetNodes(soap, tag, NULL, "tptz:GetNodes");
	case SOAP_TYPE_PointerTo_tptz__GetConfiguration:
		return soap_in_PointerTo_tptz__GetConfiguration(soap, tag, NULL, "tptz:GetConfiguration");
	case SOAP_TYPE_PointerTo_tptz__GetStatus:
		return soap_in_PointerTo_tptz__GetStatus(soap, tag, NULL, "tptz:GetStatus");
	case SOAP_TYPE_PointerTo_tptz__GotoPreset:
		return soap_in_PointerTo_tptz__GotoPreset(soap, tag, NULL, "tptz:GotoPreset");
	case SOAP_TYPE_PointerTo_tptz__RemovePreset:
		return soap_in_PointerTo_tptz__RemovePreset(soap, tag, NULL, "tptz:RemovePreset");
	case SOAP_TYPE_PointerTo_tptz__SetPreset:
		return soap_in_PointerTo_tptz__SetPreset(soap, tag, NULL, "tptz:SetPreset");
	case SOAP_TYPE_PointerTo_tptz__GetPresets:
		return soap_in_PointerTo_tptz__GetPresets(soap, tag, NULL, "tptz:GetPresets");
	case SOAP_TYPE_PointerTo_tptz__GetConfigurations:
		return soap_in_PointerTo_tptz__GetConfigurations(soap, tag, NULL, "tptz:GetConfigurations");
	case SOAP_TYPE_PointerTo_tptz__GetServiceCapabilities:
		return soap_in_PointerTo_tptz__GetServiceCapabilities(soap, tag, NULL, "tptz:GetServiceCapabilities");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		return soap_in_PointerTott__PTZConfigurationExtension(soap, tag, NULL, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_PointerTott__ZoomLimits:
		return soap_in_PointerTott__ZoomLimits(soap, tag, NULL, "tt:ZoomLimits");
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		return soap_in_PointerTott__PanTiltLimits(soap, tag, NULL, "tt:PanTiltLimits");
	case SOAP_TYPE_PointerTott__PTZNodeExtension:
		return soap_in_PointerTott__PTZNodeExtension(soap, tag, NULL, "tt:PTZNodeExtension");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, tag, NULL, "xsd:double");
	case SOAP_TYPE_PointerTott__MoveStatus:
		return soap_in_PointerTott__MoveStatus(soap, tag, NULL, "tt:MoveStatus");
	case SOAP_TYPE_PointerTott__PTZMoveStatus:
		return soap_in_PointerTott__PTZMoveStatus(soap, tag, NULL, "tt:PTZMoveStatus");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_in_PointerToxsd__anyURI(soap, tag, NULL, "xsd:anyURI");
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptionsExtension:
		return soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, tag, NULL, "tt:PTZPresetTourStartingConditionOptionsExtension");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_in_PointerTott__IntRange(soap, tag, NULL, "tt:IntRange");
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptionsExtension:
		return soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, tag, NULL, "tt:PTZPresetTourPresetDetailOptionsExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptions:
		return soap_in_PointerTott__PTZPresetTourPresetDetailOptions(soap, tag, NULL, "tt:PTZPresetTourPresetDetailOptions");
	case SOAP_TYPE_PointerTott__PTZPresetTourSpotOptions:
		return soap_in_PointerTott__PTZPresetTourSpotOptions(soap, tag, NULL, "tt:PTZPresetTourSpotOptions");
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptions:
		return soap_in_PointerTott__PTZPresetTourStartingConditionOptions(soap, tag, NULL, "tt:PTZPresetTourStartingConditionOptions");
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionExtension:
		return soap_in_PointerTott__PTZPresetTourStartingConditionExtension(soap, tag, NULL, "tt:PTZPresetTourStartingConditionExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourDirection:
		return soap_in_PointerTott__PTZPresetTourDirection(soap, tag, NULL, "tt:PTZPresetTourDirection");
	case SOAP_TYPE_PointerTott__PTZPresetTourStatusExtension:
		return soap_in_PointerTott__PTZPresetTourStatusExtension(soap, tag, NULL, "tt:PTZPresetTourStatusExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourTypeExtension:
		return soap_in_PointerTott__PTZPresetTourTypeExtension(soap, tag, NULL, "tt:PTZPresetTourTypeExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourSpotExtension:
		return soap_in_PointerTott__PTZPresetTourSpotExtension(soap, tag, NULL, "tt:PTZPresetTourSpotExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetail:
		return soap_in_PointerTott__PTZPresetTourPresetDetail(soap, tag, NULL, "tt:PTZPresetTourPresetDetail");
	case SOAP_TYPE_PointerTott__PTZPresetTourExtension:
		return soap_in_PointerTott__PTZPresetTourExtension(soap, tag, NULL, "tt:PTZPresetTourExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourSpot:
		return soap_in_PointerTott__PTZPresetTourSpot(soap, tag, NULL, "tt:PTZPresetTourSpot");
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingCondition:
		return soap_in_PointerTott__PTZPresetTourStartingCondition(soap, tag, NULL, "tt:PTZPresetTourStartingCondition");
	case SOAP_TYPE_PointerTott__PTZPresetTourStatus:
		return soap_in_PointerTott__PTZPresetTourStatus(soap, tag, NULL, "tt:PTZPresetTourStatus");
	case SOAP_TYPE_PointerTott__Name:
		return soap_in_PointerTott__Name(soap, tag, NULL, "tt:Name");
	case SOAP_TYPE_PointerTott__Vector1D:
		return soap_in_PointerTott__Vector1D(soap, tag, NULL, "tt:Vector1D");
	case SOAP_TYPE_PointerTott__Vector2D:
		return soap_in_PointerTott__Vector2D(soap, tag, NULL, "tt:Vector2D");
	case SOAP_TYPE_PointerTott__FloatRange:
		return soap_in_PointerTott__FloatRange(soap, tag, NULL, "tt:FloatRange");
	case SOAP_TYPE_PointerTott__PTZSpacesExtension:
		return soap_in_PointerTott__PTZSpacesExtension(soap, tag, NULL, "tt:PTZSpacesExtension");
	case SOAP_TYPE_PointerTott__Space1DDescription:
		return soap_in_PointerTott__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription");
	case SOAP_TYPE_PointerTott__Space2DDescription:
		return soap_in_PointerTott__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription");
	case SOAP_TYPE_PointerTott__ReverseOptionsExtension:
		return soap_in_PointerTott__ReverseOptionsExtension(soap, tag, NULL, "tt:ReverseOptionsExtension");
	case SOAP_TYPE_PointerTott__EFlipOptionsExtension:
		return soap_in_PointerTott__EFlipOptionsExtension(soap, tag, NULL, "tt:EFlipOptionsExtension");
	case SOAP_TYPE_PointerTott__PTControlDirectionOptionsExtension:
		return soap_in_PointerTott__PTControlDirectionOptionsExtension(soap, tag, NULL, "tt:PTControlDirectionOptionsExtension");
	case SOAP_TYPE_PointerTott__ReverseOptions:
		return soap_in_PointerTott__ReverseOptions(soap, tag, NULL, "tt:ReverseOptions");
	case SOAP_TYPE_PointerTott__EFlipOptions:
		return soap_in_PointerTott__EFlipOptions(soap, tag, NULL, "tt:EFlipOptions");
	case SOAP_TYPE_PointerTott__IntAttrList:
		return soap_in_PointerTott__IntAttrList(soap, tag, NULL, "tt:IntAttrList");
	case SOAP_TYPE_PointerTott__PTZConfigurationOptions2:
		return soap_in_PointerTott__PTZConfigurationOptions2(soap, tag, NULL, "tt:PTZConfigurationOptions2");
	case SOAP_TYPE_PointerTott__PTControlDirectionOptions:
		return soap_in_PointerTott__PTControlDirectionOptions(soap, tag, NULL, "tt:PTControlDirectionOptions");
	case SOAP_TYPE_PointerTott__DurationRange:
		return soap_in_PointerTott__DurationRange(soap, tag, NULL, "tt:DurationRange");
	case SOAP_TYPE_PointerTott__PTZSpaces:
		return soap_in_PointerTott__PTZSpaces(soap, tag, NULL, "tt:PTZSpaces");
	case SOAP_TYPE_PointerTott__PTControlDirectionExtension:
		return soap_in_PointerTott__PTControlDirectionExtension(soap, tag, NULL, "tt:PTControlDirectionExtension");
	case SOAP_TYPE_PointerTott__Reverse:
		return soap_in_PointerTott__Reverse(soap, tag, NULL, "tt:Reverse");
	case SOAP_TYPE_PointerTott__EFlip:
		return soap_in_PointerTott__EFlip(soap, tag, NULL, "tt:EFlip");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension2:
		return soap_in_PointerTott__PTZConfigurationExtension2(soap, tag, NULL, "tt:PTZConfigurationExtension2");
	case SOAP_TYPE_PointerTott__PTControlDirection:
		return soap_in_PointerTott__PTControlDirection(soap, tag, NULL, "tt:PTControlDirection");
	case SOAP_TYPE_PointerTott__PTZPresetTourSupportedExtension:
		return soap_in_PointerTott__PTZPresetTourSupportedExtension(soap, tag, NULL, "tt:PTZPresetTourSupportedExtension");
	case SOAP_TYPE_PointerTott__PTZNodeExtension2:
		return soap_in_PointerTott__PTZNodeExtension2(soap, tag, NULL, "tt:PTZNodeExtension2");
	case SOAP_TYPE_PointerTott__PTZPresetTourSupported:
		return soap_in_PointerTott__PTZPresetTourSupported(soap, tag, NULL, "tt:PTZPresetTourSupported");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, tag, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTott__PTZPresetTourOptions:
		return soap_in_PointerTott__PTZPresetTourOptions(soap, tag, NULL, "tt:PTZPresetTourOptions");
	case SOAP_TYPE_PointerTott__PresetTour:
		return soap_in_PointerTott__PresetTour(soap, tag, NULL, "tt:PresetTour");
	case SOAP_TYPE_PointerTofloat:
		return soap_in_PointerTofloat(soap, tag, NULL, "xsd:float");
	case SOAP_TYPE_PointerTott__GeoLocation:
		return soap_in_PointerTott__GeoLocation(soap, tag, NULL, "tt:GeoLocation");
	case SOAP_TYPE_PointerTott__PTZVector:
		return soap_in_PointerTott__PTZVector(soap, tag, NULL, "tt:PTZVector");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_in_PointerToxsd__duration(soap, tag, NULL, "xsd:duration");
	case SOAP_TYPE_PointerTott__PTZStatus:
		return soap_in_PointerTott__PTZStatus(soap, tag, NULL, "tt:PTZStatus");
	case SOAP_TYPE_PointerTott__PTZSpeed:
		return soap_in_PointerTott__PTZSpeed(soap, tag, NULL, "tt:PTZSpeed");
	case SOAP_TYPE_PointerTott__ReferenceToken:
		return soap_in_PointerTott__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, tag, NULL, "xsd:string");
	case SOAP_TYPE_PointerTott__PTZPreset:
		return soap_in_PointerTott__PTZPreset(soap, tag, NULL, "tt:PTZPreset");
	case SOAP_TYPE_PointerTott__PTZConfigurationOptions:
		return soap_in_PointerTott__PTZConfigurationOptions(soap, tag, NULL, "tt:PTZConfigurationOptions");
	case SOAP_TYPE_PointerTott__PTZConfiguration:
		return soap_in_PointerTott__PTZConfiguration(soap, tag, NULL, "tt:PTZConfiguration");
	case SOAP_TYPE_PointerTott__PTZNode:
		return soap_in_PointerTott__PTZNode(soap, tag, NULL, "tt:PTZNode");
	case SOAP_TYPE_PointerTotptz__Capabilities:
		return soap_in_PointerTotptz__Capabilities(soap, tag, NULL, "tptz:Capabilities");
	case SOAP_TYPE_PointerTott__StringList:
		return soap_in_PointerTott__StringList(soap, tag, NULL, "tt:StringList");
	case SOAP_TYPE_PointerTobool:
		return soap_in_PointerTobool(soap, tag, NULL, "xsd:boolean");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_in_PointerTochan__ChannelInstanceType(soap, tag, NULL, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_in_PointerTo_wsa5__FaultTo(soap, tag, NULL, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_in_PointerTo_wsa5__ReplyTo(soap, tag, NULL, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_in_PointerTo_wsa5__From(soap, tag, NULL, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_in_PointerTo_wsa5__RelatesTo(soap, tag, NULL, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
	{	char **s;
		s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, tag, NULL, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_in_PointerTowsa5__MetadataType(soap, tag, NULL, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, NULL, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
	{	char **s;
		s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, "wsa5:FaultCodesOpenEnumType");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
	{	char **s;
		s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, "wsa5:RelationshipTypeOpenEnum");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_in_PointerTounsignedByte(soap, tag, NULL, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, tag, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, tag, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "tt:ReferenceToken"))
		{	*type = SOAP_TYPE_tt__ReferenceToken;
			return soap_in_tt__ReferenceToken(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:AuxiliaryData"))
		{	*type = SOAP_TYPE_tt__AuxiliaryData;
			return soap_in_tt__AuxiliaryData(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Name"))
		{	*type = SOAP_TYPE_tt__Name;
			return soap_in_tt__Name(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:StringList"))
		{	*type = SOAP_TYPE_tt__StringList;
			return soap_in_tt__StringList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntAttrList"))
		{	*type = SOAP_TYPE_tt__IntAttrList;
			return soap_in_tt__IntAttrList(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:GeoLocation"))
		{	*type = SOAP_TYPE_tt__GeoLocation;
			return soap_in_tt__GeoLocation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZMoveStatus"))
		{	*type = SOAP_TYPE_tt__PTZMoveStatus;
			return soap_in_tt__PTZMoveStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZStatus"))
		{	*type = SOAP_TYPE_tt__PTZStatus;
			return soap_in_tt__PTZStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZVector"))
		{	*type = SOAP_TYPE_tt__PTZVector;
			return soap_in_tt__PTZVector(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector1D"))
		{	*type = SOAP_TYPE_tt__Vector1D;
			return soap_in_tt__Vector1D(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Vector2D"))
		{	*type = SOAP_TYPE_tt__Vector2D;
			return soap_in_tt__Vector2D(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:IntRange"))
		{	*type = SOAP_TYPE_tt__IntRange;
			return soap_in_tt__IntRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourStartingConditionOptionsExtension"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension;
			return soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourStartingConditionOptions"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions;
			return soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourPresetDetailOptionsExtension"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension;
			return soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourPresetDetailOptions"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions;
			return soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourSpotOptions"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourSpotOptions;
			return soap_in_tt__PTZPresetTourSpotOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourOptions"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourOptions;
			return soap_in_tt__PTZPresetTourOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourStartingConditionExtension"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension;
			return soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourStartingCondition"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourStartingCondition;
			return soap_in_tt__PTZPresetTourStartingCondition(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourStatusExtension"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourStatusExtension;
			return soap_in_tt__PTZPresetTourStatusExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourStatus"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourStatus;
			return soap_in_tt__PTZPresetTourStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourTypeExtension"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourTypeExtension;
			return soap_in_tt__PTZPresetTourTypeExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourPresetDetail"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourPresetDetail;
			return soap_in_tt__PTZPresetTourPresetDetail(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourSpotExtension"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourSpotExtension;
			return soap_in_tt__PTZPresetTourSpotExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourSpot"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourSpot;
			return soap_in_tt__PTZPresetTourSpot(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourExtension"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourExtension;
			return soap_in_tt__PTZPresetTourExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PresetTour"))
		{	*type = SOAP_TYPE_tt__PresetTour;
			return soap_in_tt__PresetTour(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPreset"))
		{	*type = SOAP_TYPE_tt__PTZPreset;
			return soap_in_tt__PTZPreset(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpeed"))
		{	*type = SOAP_TYPE_tt__PTZSpeed;
			return soap_in_tt__PTZSpeed(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Space1DDescription"))
		{	*type = SOAP_TYPE_tt__Space1DDescription;
			return soap_in_tt__Space1DDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Space2DDescription"))
		{	*type = SOAP_TYPE_tt__Space2DDescription;
			return soap_in_tt__Space2DDescription(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpacesExtension"))
		{	*type = SOAP_TYPE_tt__PTZSpacesExtension;
			return soap_in_tt__PTZSpacesExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZSpaces"))
		{	*type = SOAP_TYPE_tt__PTZSpaces;
			return soap_in_tt__PTZSpaces(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ZoomLimits"))
		{	*type = SOAP_TYPE_tt__ZoomLimits;
			return soap_in_tt__ZoomLimits(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PanTiltLimits"))
		{	*type = SOAP_TYPE_tt__PanTiltLimits;
			return soap_in_tt__PanTiltLimits(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReverseOptionsExtension"))
		{	*type = SOAP_TYPE_tt__ReverseOptionsExtension;
			return soap_in_tt__ReverseOptionsExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReverseOptions"))
		{	*type = SOAP_TYPE_tt__ReverseOptions;
			return soap_in_tt__ReverseOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EFlipOptionsExtension"))
		{	*type = SOAP_TYPE_tt__EFlipOptionsExtension;
			return soap_in_tt__EFlipOptionsExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EFlipOptions"))
		{	*type = SOAP_TYPE_tt__EFlipOptions;
			return soap_in_tt__EFlipOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTControlDirectionOptionsExtension"))
		{	*type = SOAP_TYPE_tt__PTControlDirectionOptionsExtension;
			return soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTControlDirectionOptions"))
		{	*type = SOAP_TYPE_tt__PTControlDirectionOptions;
			return soap_in_tt__PTControlDirectionOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfigurationOptions2"))
		{	*type = SOAP_TYPE_tt__PTZConfigurationOptions2;
			return soap_in_tt__PTZConfigurationOptions2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfigurationOptions"))
		{	*type = SOAP_TYPE_tt__PTZConfigurationOptions;
			return soap_in_tt__PTZConfigurationOptions(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:Reverse"))
		{	*type = SOAP_TYPE_tt__Reverse;
			return soap_in_tt__Reverse(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EFlip"))
		{	*type = SOAP_TYPE_tt__EFlip;
			return soap_in_tt__EFlip(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTControlDirectionExtension"))
		{	*type = SOAP_TYPE_tt__PTControlDirectionExtension;
			return soap_in_tt__PTControlDirectionExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTControlDirection"))
		{	*type = SOAP_TYPE_tt__PTControlDirection;
			return soap_in_tt__PTControlDirection(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfigurationExtension2"))
		{	*type = SOAP_TYPE_tt__PTZConfigurationExtension2;
			return soap_in_tt__PTZConfigurationExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfigurationExtension"))
		{	*type = SOAP_TYPE_tt__PTZConfigurationExtension;
			return soap_in_tt__PTZConfigurationExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZConfiguration"))
		{	*type = SOAP_TYPE_tt__PTZConfiguration;
			return soap_in_tt__PTZConfiguration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourSupportedExtension"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourSupportedExtension;
			return soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourSupported"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourSupported;
			return soap_in_tt__PTZPresetTourSupported(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZNodeExtension2"))
		{	*type = SOAP_TYPE_tt__PTZNodeExtension2;
			return soap_in_tt__PTZNodeExtension2(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZNodeExtension"))
		{	*type = SOAP_TYPE_tt__PTZNodeExtension;
			return soap_in_tt__PTZNodeExtension(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZNode"))
		{	*type = SOAP_TYPE_tt__PTZNode;
			return soap_in_tt__PTZNode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ConfigurationEntity"))
		{	*type = SOAP_TYPE_tt__ConfigurationEntity;
			return soap_in_tt__ConfigurationEntity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DurationRange"))
		{	*type = SOAP_TYPE_tt__DurationRange;
			return soap_in_tt__DurationRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:FloatRange"))
		{	*type = SOAP_TYPE_tt__FloatRange;
			return soap_in_tt__FloatRange(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:DeviceEntity"))
		{	*type = SOAP_TYPE_tt__DeviceEntity;
			return soap_in_tt__DeviceEntity(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:Capabilities"))
		{	*type = SOAP_TYPE_tptz__Capabilities;
			return soap_in_tptz__Capabilities(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:token"))
		{	*type = SOAP_TYPE_xsd__token;
			return soap_in_xsd__token(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:nonNegativeInteger"))
		{	*type = SOAP_TYPE_xsd__nonNegativeInteger;
			return soap_in_xsd__nonNegativeInteger(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:duration"))
		{	*type = SOAP_TYPE_xsd__duration;
			return soap_in_xsd__duration(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyURI"))
		{	*type = SOAP_TYPE_xsd__anyURI;
			return soap_in_xsd__anyURI(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anySimpleType"))
		{	*type = SOAP_TYPE_xsd__anySimpleType;
			return soap_in_xsd__anySimpleType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:NCName"))
		{	*type = SOAP_TYPE_xsd__NCName;
			return soap_in_xsd__NCName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:hexBinary"))
		{	*type = SOAP_TYPE_xsd__hexBinary;
			return soap_in_xsd__hexBinary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:base64Binary"))
		{	*type = SOAP_TYPE_xsd__base64Binary;
			return soap_in_xsd__base64Binary(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	*type = SOAP_TYPE_xsd__QName;
			return soap_in_xsd__QName(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:anyType"))
		{	*type = SOAP_TYPE_xsd__anyType;
			return soap_in_xsd__anyType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:float"))
		{	*type = SOAP_TYPE_float;
			return soap_in_float(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedByte"))
		{	*type = SOAP_TYPE_unsignedByte;
			return soap_in_unsignedByte(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedInt"))
		{	*type = SOAP_TYPE_unsignedInt;
			return soap_in_unsignedInt(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:unsignedLong"))
		{	*type = SOAP_TYPE_ULONG64;
			return soap_in_ULONG64(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_dateTime;
			return soap_in_dateTime(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:MoveStatus"))
		{	*type = SOAP_TYPE_tt__MoveStatus;
			return soap_in_tt__MoveStatus(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourOperation"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourOperation;
			return soap_in_tt__PTZPresetTourOperation(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourDirection"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourDirection;
			return soap_in_tt__PTZPresetTourDirection(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:PTZPresetTourState"))
		{	*type = SOAP_TYPE_tt__PTZPresetTourState;
			return soap_in_tt__PTZPresetTourState(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:ReverseMode"))
		{	*type = SOAP_TYPE_tt__ReverseMode;
			return soap_in_tt__ReverseMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tt:EFlipMode"))
		{	*type = SOAP_TYPE_tt__EFlipMode;
			return soap_in_tt__EFlipMode(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:IsReferenceParameter"))
		{	*type = SOAP_TYPE__wsa5__IsReferenceParameter;
			return soap_in__wsa5__IsReferenceParameter(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesType"))
		{	*type = SOAP_TYPE_wsa5__FaultCodesType;
			return soap_in_wsa5__FaultCodesType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipType"))
		{	*type = SOAP_TYPE_wsa5__RelationshipType;
			return soap_in_wsa5__RelationshipType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "SOAP-ENV:Envelope"))
		{	*type = SOAP_TYPE_SOAP_ENV__Envelope;
			return soap_in_SOAP_ENV__Envelope(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "chan:ChannelInstanceType"))
		{	*type = SOAP_TYPE_chan__ChannelInstanceType;
			return soap_in_chan__ChannelInstanceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemActionType"))
		{	*type = SOAP_TYPE_wsa5__ProblemActionType;
			return soap_in_wsa5__ProblemActionType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesToType"))
		{	*type = SOAP_TYPE_wsa5__RelatesToType;
			return soap_in_wsa5__RelatesToType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:MetadataType"))
		{	*type = SOAP_TYPE_wsa5__MetadataType;
			return soap_in_wsa5__MetadataType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParametersType"))
		{	*type = SOAP_TYPE_wsa5__ReferenceParametersType;
			return soap_in_wsa5__ReferenceParametersType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReferenceType"))
		{	*type = SOAP_TYPE_wsa5__EndpointReferenceType;
			return soap_in_wsa5__EndpointReferenceType(soap, tag, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemHeaderQName;
			s = soap_in__wsa5__ProblemHeaderQName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultCodesOpenEnumType"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__FaultCodesOpenEnumType;
			s = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:RelationshipTypeOpenEnum"))
		{	char **s;
			*type = SOAP_TYPE_wsa5__RelationshipTypeOpenEnum;
			s = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, tag, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "wsa5:RetryAfter"))
		{	*type = SOAP_TYPE__wsa5__RetryAfter;
			return soap_in__wsa5__RetryAfter(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:MoveAndStartTrackingResponse"))
		{	*type = SOAP_TYPE__tptz__MoveAndStartTrackingResponse;
			return soap_in__tptz__MoveAndStartTrackingResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:MoveAndStartTracking"))
		{	*type = SOAP_TYPE__tptz__MoveAndStartTracking;
			return soap_in__tptz__MoveAndStartTracking(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetCompatibleConfigurationsResponse"))
		{	*type = SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse;
			return soap_in__tptz__GetCompatibleConfigurationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetCompatibleConfigurations"))
		{	*type = SOAP_TYPE__tptz__GetCompatibleConfigurations;
			return soap_in__tptz__GetCompatibleConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:RemovePresetTourResponse"))
		{	*type = SOAP_TYPE__tptz__RemovePresetTourResponse;
			return soap_in__tptz__RemovePresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:RemovePresetTour"))
		{	*type = SOAP_TYPE__tptz__RemovePresetTour;
			return soap_in__tptz__RemovePresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:OperatePresetTourResponse"))
		{	*type = SOAP_TYPE__tptz__OperatePresetTourResponse;
			return soap_in__tptz__OperatePresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:OperatePresetTour"))
		{	*type = SOAP_TYPE__tptz__OperatePresetTour;
			return soap_in__tptz__OperatePresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:ModifyPresetTourResponse"))
		{	*type = SOAP_TYPE__tptz__ModifyPresetTourResponse;
			return soap_in__tptz__ModifyPresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:ModifyPresetTour"))
		{	*type = SOAP_TYPE__tptz__ModifyPresetTour;
			return soap_in__tptz__ModifyPresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:CreatePresetTourResponse"))
		{	*type = SOAP_TYPE__tptz__CreatePresetTourResponse;
			return soap_in__tptz__CreatePresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:CreatePresetTour"))
		{	*type = SOAP_TYPE__tptz__CreatePresetTour;
			return soap_in__tptz__CreatePresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetPresetTourOptionsResponse"))
		{	*type = SOAP_TYPE__tptz__GetPresetTourOptionsResponse;
			return soap_in__tptz__GetPresetTourOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetPresetTourOptions"))
		{	*type = SOAP_TYPE__tptz__GetPresetTourOptions;
			return soap_in__tptz__GetPresetTourOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetPresetTourResponse"))
		{	*type = SOAP_TYPE__tptz__GetPresetTourResponse;
			return soap_in__tptz__GetPresetTourResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetPresetTour"))
		{	*type = SOAP_TYPE__tptz__GetPresetTour;
			return soap_in__tptz__GetPresetTour(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetPresetToursResponse"))
		{	*type = SOAP_TYPE__tptz__GetPresetToursResponse;
			return soap_in__tptz__GetPresetToursResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetPresetTours"))
		{	*type = SOAP_TYPE__tptz__GetPresetTours;
			return soap_in__tptz__GetPresetTours(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:StopResponse"))
		{	*type = SOAP_TYPE__tptz__StopResponse;
			return soap_in__tptz__StopResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:Stop"))
		{	*type = SOAP_TYPE__tptz__Stop;
			return soap_in__tptz__Stop(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GeoMoveResponse"))
		{	*type = SOAP_TYPE__tptz__GeoMoveResponse;
			return soap_in__tptz__GeoMoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GeoMove"))
		{	*type = SOAP_TYPE__tptz__GeoMove;
			return soap_in__tptz__GeoMove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:AbsoluteMoveResponse"))
		{	*type = SOAP_TYPE__tptz__AbsoluteMoveResponse;
			return soap_in__tptz__AbsoluteMoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:AbsoluteMove"))
		{	*type = SOAP_TYPE__tptz__AbsoluteMove;
			return soap_in__tptz__AbsoluteMove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:RelativeMoveResponse"))
		{	*type = SOAP_TYPE__tptz__RelativeMoveResponse;
			return soap_in__tptz__RelativeMoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:RelativeMove"))
		{	*type = SOAP_TYPE__tptz__RelativeMove;
			return soap_in__tptz__RelativeMove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:ContinuousMoveResponse"))
		{	*type = SOAP_TYPE__tptz__ContinuousMoveResponse;
			return soap_in__tptz__ContinuousMoveResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:ContinuousMove"))
		{	*type = SOAP_TYPE__tptz__ContinuousMove;
			return soap_in__tptz__ContinuousMove(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:SetHomePositionResponse"))
		{	*type = SOAP_TYPE__tptz__SetHomePositionResponse;
			return soap_in__tptz__SetHomePositionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:SetHomePosition"))
		{	*type = SOAP_TYPE__tptz__SetHomePosition;
			return soap_in__tptz__SetHomePosition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GotoHomePositionResponse"))
		{	*type = SOAP_TYPE__tptz__GotoHomePositionResponse;
			return soap_in__tptz__GotoHomePositionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GotoHomePosition"))
		{	*type = SOAP_TYPE__tptz__GotoHomePosition;
			return soap_in__tptz__GotoHomePosition(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetStatusResponse"))
		{	*type = SOAP_TYPE__tptz__GetStatusResponse;
			return soap_in__tptz__GetStatusResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetStatus"))
		{	*type = SOAP_TYPE__tptz__GetStatus;
			return soap_in__tptz__GetStatus(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GotoPresetResponse"))
		{	*type = SOAP_TYPE__tptz__GotoPresetResponse;
			return soap_in__tptz__GotoPresetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GotoPreset"))
		{	*type = SOAP_TYPE__tptz__GotoPreset;
			return soap_in__tptz__GotoPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:RemovePresetResponse"))
		{	*type = SOAP_TYPE__tptz__RemovePresetResponse;
			return soap_in__tptz__RemovePresetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:RemovePreset"))
		{	*type = SOAP_TYPE__tptz__RemovePreset;
			return soap_in__tptz__RemovePreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:SetPresetResponse"))
		{	*type = SOAP_TYPE__tptz__SetPresetResponse;
			return soap_in__tptz__SetPresetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:SetPreset"))
		{	*type = SOAP_TYPE__tptz__SetPreset;
			return soap_in__tptz__SetPreset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetPresetsResponse"))
		{	*type = SOAP_TYPE__tptz__GetPresetsResponse;
			return soap_in__tptz__GetPresetsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetPresets"))
		{	*type = SOAP_TYPE__tptz__GetPresets;
			return soap_in__tptz__GetPresets(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:SendAuxiliaryCommandResponse"))
		{	*type = SOAP_TYPE__tptz__SendAuxiliaryCommandResponse;
			return soap_in__tptz__SendAuxiliaryCommandResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:SendAuxiliaryCommand"))
		{	*type = SOAP_TYPE__tptz__SendAuxiliaryCommand;
			return soap_in__tptz__SendAuxiliaryCommand(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetConfigurationOptionsResponse"))
		{	*type = SOAP_TYPE__tptz__GetConfigurationOptionsResponse;
			return soap_in__tptz__GetConfigurationOptionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetConfigurationOptions"))
		{	*type = SOAP_TYPE__tptz__GetConfigurationOptions;
			return soap_in__tptz__GetConfigurationOptions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:SetConfigurationResponse"))
		{	*type = SOAP_TYPE__tptz__SetConfigurationResponse;
			return soap_in__tptz__SetConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:SetConfiguration"))
		{	*type = SOAP_TYPE__tptz__SetConfiguration;
			return soap_in__tptz__SetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetConfigurationResponse"))
		{	*type = SOAP_TYPE__tptz__GetConfigurationResponse;
			return soap_in__tptz__GetConfigurationResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetConfiguration"))
		{	*type = SOAP_TYPE__tptz__GetConfiguration;
			return soap_in__tptz__GetConfiguration(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetConfigurationsResponse"))
		{	*type = SOAP_TYPE__tptz__GetConfigurationsResponse;
			return soap_in__tptz__GetConfigurationsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetConfigurations"))
		{	*type = SOAP_TYPE__tptz__GetConfigurations;
			return soap_in__tptz__GetConfigurations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetNodeResponse"))
		{	*type = SOAP_TYPE__tptz__GetNodeResponse;
			return soap_in__tptz__GetNodeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetNode"))
		{	*type = SOAP_TYPE__tptz__GetNode;
			return soap_in__tptz__GetNode(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetNodesResponse"))
		{	*type = SOAP_TYPE__tptz__GetNodesResponse;
			return soap_in__tptz__GetNodesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetNodes"))
		{	*type = SOAP_TYPE__tptz__GetNodes;
			return soap_in__tptz__GetNodes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetServiceCapabilitiesResponse"))
		{	*type = SOAP_TYPE__tptz__GetServiceCapabilitiesResponse;
			return soap_in__tptz__GetServiceCapabilitiesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "tptz:GetServiceCapabilities"))
		{	*type = SOAP_TYPE__tptz__GetServiceCapabilities;
			return soap_in__tptz__GetServiceCapabilities(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xml:lang"))
		{	*type = SOAP_TYPE__xml__lang;
			return soap_in__xml__lang(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemAction"))
		{	*type = SOAP_TYPE__wsa5__ProblemAction;
			return soap_in__wsa5__ProblemAction(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:FaultTo"))
		{	*type = SOAP_TYPE__wsa5__FaultTo;
			return soap_in__wsa5__FaultTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:From"))
		{	*type = SOAP_TYPE__wsa5__From;
			return soap_in__wsa5__From(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReplyTo"))
		{	*type = SOAP_TYPE__wsa5__ReplyTo;
			return soap_in__wsa5__ReplyTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:RelatesTo"))
		{	*type = SOAP_TYPE__wsa5__RelatesTo;
			return soap_in__wsa5__RelatesTo(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:Metadata"))
		{	*type = SOAP_TYPE__wsa5__Metadata;
			return soap_in__wsa5__Metadata(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ReferenceParameters"))
		{	*type = SOAP_TYPE__wsa5__ReferenceParameters;
			return soap_in__wsa5__ReferenceParameters(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:EndpointReference"))
		{	*type = SOAP_TYPE__wsa5__EndpointReference;
			return soap_in__wsa5__EndpointReference(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xop:Include"))
		{	*type = SOAP_TYPE__xop__Include;
			return soap_in__xop__Include(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "wsa5:ProblemIRI"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__ProblemIRI;
			s = soap_in__wsa5__ProblemIRI(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:Action"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__Action;
			s = soap_in__wsa5__Action(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:To"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__To;
			s = soap_in__wsa5__To(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "wsa5:MessageID"))
		{	char **s;
			*type = SOAP_TYPE__wsa5__MessageID;
			s = soap_in__wsa5__MessageID(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input at level = %u body = %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, NULL, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_float:
		return soap_out_float(soap, tag, id, (const float *)ptr, "xsd:float");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_unsignedByte:
		return soap_out_unsignedByte(soap, tag, id, (const unsigned char *)ptr, "xsd:unsignedByte");
	case SOAP_TYPE_unsignedInt:
		return soap_out_unsignedInt(soap, tag, id, (const unsigned int *)ptr, "xsd:unsignedInt");
	case SOAP_TYPE__wsa5__RetryAfter:
		return soap_out__wsa5__RetryAfter(soap, "wsa5:RetryAfter", id, (const ULONG64 *)ptr, "");
	case SOAP_TYPE_ULONG64:
		return soap_out_ULONG64(soap, tag, id, (const ULONG64 *)ptr, "xsd:unsignedLong");
	case SOAP_TYPE_dateTime:
		return soap_out_dateTime(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_tt__MoveStatus:
		return soap_out_tt__MoveStatus(soap, tag, id, (const enum tt__MoveStatus *)ptr, "tt:MoveStatus");
	case SOAP_TYPE_tt__PTZPresetTourOperation:
		return soap_out_tt__PTZPresetTourOperation(soap, tag, id, (const enum tt__PTZPresetTourOperation *)ptr, "tt:PTZPresetTourOperation");
	case SOAP_TYPE_tt__PTZPresetTourDirection:
		return soap_out_tt__PTZPresetTourDirection(soap, tag, id, (const enum tt__PTZPresetTourDirection *)ptr, "tt:PTZPresetTourDirection");
	case SOAP_TYPE_tt__PTZPresetTourState:
		return soap_out_tt__PTZPresetTourState(soap, tag, id, (const enum tt__PTZPresetTourState *)ptr, "tt:PTZPresetTourState");
	case SOAP_TYPE_tt__ReverseMode:
		return soap_out_tt__ReverseMode(soap, tag, id, (const enum tt__ReverseMode *)ptr, "tt:ReverseMode");
	case SOAP_TYPE_tt__EFlipMode:
		return soap_out_tt__EFlipMode(soap, tag, id, (const enum tt__EFlipMode *)ptr, "tt:EFlipMode");
	case SOAP_TYPE__wsa5__IsReferenceParameter:
		return soap_out__wsa5__IsReferenceParameter(soap, tag, id, (const enum _wsa5__IsReferenceParameter *)ptr, "wsa5:IsReferenceParameter");
	case SOAP_TYPE_wsa5__FaultCodesType:
		return soap_out_wsa5__FaultCodesType(soap, tag, id, (const enum wsa5__FaultCodesType *)ptr, "wsa5:FaultCodesType");
	case SOAP_TYPE_wsa5__RelationshipType:
		return soap_out_wsa5__RelationshipType(soap, tag, id, (const enum wsa5__RelationshipType *)ptr, "wsa5:RelationshipType");
	case SOAP_TYPE_tt__ReferenceToken:
		return soap_out_tt__ReferenceToken(soap, tag, id, (const std::string *)ptr, "tt:ReferenceToken");
	case SOAP_TYPE_tt__AuxiliaryData:
		return soap_out_tt__AuxiliaryData(soap, tag, id, (const std::string *)ptr, "tt:AuxiliaryData");
	case SOAP_TYPE_tt__Name:
		return soap_out_tt__Name(soap, tag, id, (const std::string *)ptr, "tt:Name");
	case SOAP_TYPE_tt__StringList:
		return soap_out_tt__StringList(soap, tag, id, (const std::string *)ptr, "tt:StringList");
	case SOAP_TYPE_tt__IntAttrList:
		return soap_out_tt__IntAttrList(soap, tag, id, (const std::string *)ptr, "tt:IntAttrList");
	case SOAP_TYPE_tt__GeoLocation:
		return ((tt__GeoLocation *)ptr)->soap_out(soap, tag, id, "tt:GeoLocation");
	case SOAP_TYPE_tt__PTZMoveStatus:
		return ((tt__PTZMoveStatus *)ptr)->soap_out(soap, tag, id, "tt:PTZMoveStatus");
	case SOAP_TYPE_tt__PTZStatus:
		return ((tt__PTZStatus *)ptr)->soap_out(soap, tag, id, "tt:PTZStatus");
	case SOAP_TYPE_tt__PTZVector:
		return ((tt__PTZVector *)ptr)->soap_out(soap, tag, id, "tt:PTZVector");
	case SOAP_TYPE_tt__Vector1D:
		return ((tt__Vector1D *)ptr)->soap_out(soap, tag, id, "tt:Vector1D");
	case SOAP_TYPE_tt__Vector2D:
		return ((tt__Vector2D *)ptr)->soap_out(soap, tag, id, "tt:Vector2D");
	case SOAP_TYPE_tt__IntRange:
		return ((tt__IntRange *)ptr)->soap_out(soap, tag, id, "tt:IntRange");
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension:
		return ((tt__PTZPresetTourStartingConditionOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourStartingConditionOptionsExtension");
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions:
		return ((tt__PTZPresetTourStartingConditionOptions *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourStartingConditionOptions");
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension:
		return ((tt__PTZPresetTourPresetDetailOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourPresetDetailOptionsExtension");
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions:
		return ((tt__PTZPresetTourPresetDetailOptions *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourPresetDetailOptions");
	case SOAP_TYPE_tt__PTZPresetTourSpotOptions:
		return ((tt__PTZPresetTourSpotOptions *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourSpotOptions");
	case SOAP_TYPE_tt__PTZPresetTourOptions:
		return ((tt__PTZPresetTourOptions *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourOptions");
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension:
		return ((tt__PTZPresetTourStartingConditionExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourStartingConditionExtension");
	case SOAP_TYPE_tt__PTZPresetTourStartingCondition:
		return ((tt__PTZPresetTourStartingCondition *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourStartingCondition");
	case SOAP_TYPE_tt__PTZPresetTourStatusExtension:
		return ((tt__PTZPresetTourStatusExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourStatusExtension");
	case SOAP_TYPE_tt__PTZPresetTourStatus:
		return ((tt__PTZPresetTourStatus *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourStatus");
	case SOAP_TYPE_tt__PTZPresetTourTypeExtension:
		return ((tt__PTZPresetTourTypeExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourTypeExtension");
	case SOAP_TYPE_tt__PTZPresetTourPresetDetail:
		return ((tt__PTZPresetTourPresetDetail *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourPresetDetail");
	case SOAP_TYPE_tt__PTZPresetTourSpotExtension:
		return ((tt__PTZPresetTourSpotExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourSpotExtension");
	case SOAP_TYPE_tt__PTZPresetTourSpot:
		return ((tt__PTZPresetTourSpot *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourSpot");
	case SOAP_TYPE_tt__PTZPresetTourExtension:
		return ((tt__PTZPresetTourExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourExtension");
	case SOAP_TYPE_tt__PresetTour:
		return ((tt__PresetTour *)ptr)->soap_out(soap, tag, id, "tt:PresetTour");
	case SOAP_TYPE_tt__PTZPreset:
		return ((tt__PTZPreset *)ptr)->soap_out(soap, tag, id, "tt:PTZPreset");
	case SOAP_TYPE_tt__PTZSpeed:
		return ((tt__PTZSpeed *)ptr)->soap_out(soap, tag, id, "tt:PTZSpeed");
	case SOAP_TYPE_tt__Space1DDescription:
		return ((tt__Space1DDescription *)ptr)->soap_out(soap, tag, id, "tt:Space1DDescription");
	case SOAP_TYPE_tt__Space2DDescription:
		return ((tt__Space2DDescription *)ptr)->soap_out(soap, tag, id, "tt:Space2DDescription");
	case SOAP_TYPE_tt__PTZSpacesExtension:
		return ((tt__PTZSpacesExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZSpacesExtension");
	case SOAP_TYPE_tt__PTZSpaces:
		return ((tt__PTZSpaces *)ptr)->soap_out(soap, tag, id, "tt:PTZSpaces");
	case SOAP_TYPE_tt__ZoomLimits:
		return ((tt__ZoomLimits *)ptr)->soap_out(soap, tag, id, "tt:ZoomLimits");
	case SOAP_TYPE_tt__PanTiltLimits:
		return ((tt__PanTiltLimits *)ptr)->soap_out(soap, tag, id, "tt:PanTiltLimits");
	case SOAP_TYPE_tt__ReverseOptionsExtension:
		return ((tt__ReverseOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:ReverseOptionsExtension");
	case SOAP_TYPE_tt__ReverseOptions:
		return ((tt__ReverseOptions *)ptr)->soap_out(soap, tag, id, "tt:ReverseOptions");
	case SOAP_TYPE_tt__EFlipOptionsExtension:
		return ((tt__EFlipOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:EFlipOptionsExtension");
	case SOAP_TYPE_tt__EFlipOptions:
		return ((tt__EFlipOptions *)ptr)->soap_out(soap, tag, id, "tt:EFlipOptions");
	case SOAP_TYPE_tt__PTControlDirectionOptionsExtension:
		return ((tt__PTControlDirectionOptionsExtension *)ptr)->soap_out(soap, tag, id, "tt:PTControlDirectionOptionsExtension");
	case SOAP_TYPE_tt__PTControlDirectionOptions:
		return ((tt__PTControlDirectionOptions *)ptr)->soap_out(soap, tag, id, "tt:PTControlDirectionOptions");
	case SOAP_TYPE_tt__PTZConfigurationOptions2:
		return ((tt__PTZConfigurationOptions2 *)ptr)->soap_out(soap, tag, id, "tt:PTZConfigurationOptions2");
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		return ((tt__PTZConfigurationOptions *)ptr)->soap_out(soap, tag, id, "tt:PTZConfigurationOptions");
	case SOAP_TYPE_tt__Reverse:
		return ((tt__Reverse *)ptr)->soap_out(soap, tag, id, "tt:Reverse");
	case SOAP_TYPE_tt__EFlip:
		return ((tt__EFlip *)ptr)->soap_out(soap, tag, id, "tt:EFlip");
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		return ((tt__PTControlDirectionExtension *)ptr)->soap_out(soap, tag, id, "tt:PTControlDirectionExtension");
	case SOAP_TYPE_tt__PTControlDirection:
		return ((tt__PTControlDirection *)ptr)->soap_out(soap, tag, id, "tt:PTControlDirection");
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		return ((tt__PTZConfigurationExtension2 *)ptr)->soap_out(soap, tag, id, "tt:PTZConfigurationExtension2");
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return ((tt__PTZConfigurationExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_tt__PTZConfiguration:
		return ((tt__PTZConfiguration *)ptr)->soap_out(soap, tag, id, "tt:PTZConfiguration");
	case SOAP_TYPE_tt__PTZPresetTourSupportedExtension:
		return ((tt__PTZPresetTourSupportedExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourSupportedExtension");
	case SOAP_TYPE_tt__PTZPresetTourSupported:
		return ((tt__PTZPresetTourSupported *)ptr)->soap_out(soap, tag, id, "tt:PTZPresetTourSupported");
	case SOAP_TYPE_tt__PTZNodeExtension2:
		return ((tt__PTZNodeExtension2 *)ptr)->soap_out(soap, tag, id, "tt:PTZNodeExtension2");
	case SOAP_TYPE_tt__PTZNodeExtension:
		return ((tt__PTZNodeExtension *)ptr)->soap_out(soap, tag, id, "tt:PTZNodeExtension");
	case SOAP_TYPE_tt__PTZNode:
		return ((tt__PTZNode *)ptr)->soap_out(soap, tag, id, "tt:PTZNode");
	case SOAP_TYPE_tt__ConfigurationEntity:
		return ((tt__ConfigurationEntity *)ptr)->soap_out(soap, tag, id, "tt:ConfigurationEntity");
	case SOAP_TYPE_tt__DurationRange:
		return ((tt__DurationRange *)ptr)->soap_out(soap, tag, id, "tt:DurationRange");
	case SOAP_TYPE_tt__FloatRange:
		return ((tt__FloatRange *)ptr)->soap_out(soap, tag, id, "tt:FloatRange");
	case SOAP_TYPE_tt__DeviceEntity:
		return ((tt__DeviceEntity *)ptr)->soap_out(soap, tag, id, "tt:DeviceEntity");
	case SOAP_TYPE__tptz__MoveAndStartTrackingResponse:
		return ((_tptz__MoveAndStartTrackingResponse *)ptr)->soap_out(soap, "tptz:MoveAndStartTrackingResponse", id, "");
	case SOAP_TYPE__tptz__MoveAndStartTracking:
		return ((_tptz__MoveAndStartTracking *)ptr)->soap_out(soap, "tptz:MoveAndStartTracking", id, "");
	case SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse:
		return ((_tptz__GetCompatibleConfigurationsResponse *)ptr)->soap_out(soap, "tptz:GetCompatibleConfigurationsResponse", id, "");
	case SOAP_TYPE__tptz__GetCompatibleConfigurations:
		return ((_tptz__GetCompatibleConfigurations *)ptr)->soap_out(soap, "tptz:GetCompatibleConfigurations", id, "");
	case SOAP_TYPE__tptz__RemovePresetTourResponse:
		return ((_tptz__RemovePresetTourResponse *)ptr)->soap_out(soap, "tptz:RemovePresetTourResponse", id, "");
	case SOAP_TYPE__tptz__RemovePresetTour:
		return ((_tptz__RemovePresetTour *)ptr)->soap_out(soap, "tptz:RemovePresetTour", id, "");
	case SOAP_TYPE__tptz__OperatePresetTourResponse:
		return ((_tptz__OperatePresetTourResponse *)ptr)->soap_out(soap, "tptz:OperatePresetTourResponse", id, "");
	case SOAP_TYPE__tptz__OperatePresetTour:
		return ((_tptz__OperatePresetTour *)ptr)->soap_out(soap, "tptz:OperatePresetTour", id, "");
	case SOAP_TYPE__tptz__ModifyPresetTourResponse:
		return ((_tptz__ModifyPresetTourResponse *)ptr)->soap_out(soap, "tptz:ModifyPresetTourResponse", id, "");
	case SOAP_TYPE__tptz__ModifyPresetTour:
		return ((_tptz__ModifyPresetTour *)ptr)->soap_out(soap, "tptz:ModifyPresetTour", id, "");
	case SOAP_TYPE__tptz__CreatePresetTourResponse:
		return ((_tptz__CreatePresetTourResponse *)ptr)->soap_out(soap, "tptz:CreatePresetTourResponse", id, "");
	case SOAP_TYPE__tptz__CreatePresetTour:
		return ((_tptz__CreatePresetTour *)ptr)->soap_out(soap, "tptz:CreatePresetTour", id, "");
	case SOAP_TYPE__tptz__GetPresetTourOptionsResponse:
		return ((_tptz__GetPresetTourOptionsResponse *)ptr)->soap_out(soap, "tptz:GetPresetTourOptionsResponse", id, "");
	case SOAP_TYPE__tptz__GetPresetTourOptions:
		return ((_tptz__GetPresetTourOptions *)ptr)->soap_out(soap, "tptz:GetPresetTourOptions", id, "");
	case SOAP_TYPE__tptz__GetPresetTourResponse:
		return ((_tptz__GetPresetTourResponse *)ptr)->soap_out(soap, "tptz:GetPresetTourResponse", id, "");
	case SOAP_TYPE__tptz__GetPresetTour:
		return ((_tptz__GetPresetTour *)ptr)->soap_out(soap, "tptz:GetPresetTour", id, "");
	case SOAP_TYPE__tptz__GetPresetToursResponse:
		return ((_tptz__GetPresetToursResponse *)ptr)->soap_out(soap, "tptz:GetPresetToursResponse", id, "");
	case SOAP_TYPE__tptz__GetPresetTours:
		return ((_tptz__GetPresetTours *)ptr)->soap_out(soap, "tptz:GetPresetTours", id, "");
	case SOAP_TYPE__tptz__StopResponse:
		return ((_tptz__StopResponse *)ptr)->soap_out(soap, "tptz:StopResponse", id, "");
	case SOAP_TYPE__tptz__Stop:
		return ((_tptz__Stop *)ptr)->soap_out(soap, "tptz:Stop", id, "");
	case SOAP_TYPE__tptz__GeoMoveResponse:
		return ((_tptz__GeoMoveResponse *)ptr)->soap_out(soap, "tptz:GeoMoveResponse", id, "");
	case SOAP_TYPE__tptz__GeoMove:
		return ((_tptz__GeoMove *)ptr)->soap_out(soap, "tptz:GeoMove", id, "");
	case SOAP_TYPE__tptz__AbsoluteMoveResponse:
		return ((_tptz__AbsoluteMoveResponse *)ptr)->soap_out(soap, "tptz:AbsoluteMoveResponse", id, "");
	case SOAP_TYPE__tptz__AbsoluteMove:
		return ((_tptz__AbsoluteMove *)ptr)->soap_out(soap, "tptz:AbsoluteMove", id, "");
	case SOAP_TYPE__tptz__RelativeMoveResponse:
		return ((_tptz__RelativeMoveResponse *)ptr)->soap_out(soap, "tptz:RelativeMoveResponse", id, "");
	case SOAP_TYPE__tptz__RelativeMove:
		return ((_tptz__RelativeMove *)ptr)->soap_out(soap, "tptz:RelativeMove", id, "");
	case SOAP_TYPE__tptz__ContinuousMoveResponse:
		return ((_tptz__ContinuousMoveResponse *)ptr)->soap_out(soap, "tptz:ContinuousMoveResponse", id, "");
	case SOAP_TYPE__tptz__ContinuousMove:
		return ((_tptz__ContinuousMove *)ptr)->soap_out(soap, "tptz:ContinuousMove", id, "");
	case SOAP_TYPE__tptz__SetHomePositionResponse:
		return ((_tptz__SetHomePositionResponse *)ptr)->soap_out(soap, "tptz:SetHomePositionResponse", id, "");
	case SOAP_TYPE__tptz__SetHomePosition:
		return ((_tptz__SetHomePosition *)ptr)->soap_out(soap, "tptz:SetHomePosition", id, "");
	case SOAP_TYPE__tptz__GotoHomePositionResponse:
		return ((_tptz__GotoHomePositionResponse *)ptr)->soap_out(soap, "tptz:GotoHomePositionResponse", id, "");
	case SOAP_TYPE__tptz__GotoHomePosition:
		return ((_tptz__GotoHomePosition *)ptr)->soap_out(soap, "tptz:GotoHomePosition", id, "");
	case SOAP_TYPE__tptz__GetStatusResponse:
		return ((_tptz__GetStatusResponse *)ptr)->soap_out(soap, "tptz:GetStatusResponse", id, "");
	case SOAP_TYPE__tptz__GetStatus:
		return ((_tptz__GetStatus *)ptr)->soap_out(soap, "tptz:GetStatus", id, "");
	case SOAP_TYPE__tptz__GotoPresetResponse:
		return ((_tptz__GotoPresetResponse *)ptr)->soap_out(soap, "tptz:GotoPresetResponse", id, "");
	case SOAP_TYPE__tptz__GotoPreset:
		return ((_tptz__GotoPreset *)ptr)->soap_out(soap, "tptz:GotoPreset", id, "");
	case SOAP_TYPE__tptz__RemovePresetResponse:
		return ((_tptz__RemovePresetResponse *)ptr)->soap_out(soap, "tptz:RemovePresetResponse", id, "");
	case SOAP_TYPE__tptz__RemovePreset:
		return ((_tptz__RemovePreset *)ptr)->soap_out(soap, "tptz:RemovePreset", id, "");
	case SOAP_TYPE__tptz__SetPresetResponse:
		return ((_tptz__SetPresetResponse *)ptr)->soap_out(soap, "tptz:SetPresetResponse", id, "");
	case SOAP_TYPE__tptz__SetPreset:
		return ((_tptz__SetPreset *)ptr)->soap_out(soap, "tptz:SetPreset", id, "");
	case SOAP_TYPE__tptz__GetPresetsResponse:
		return ((_tptz__GetPresetsResponse *)ptr)->soap_out(soap, "tptz:GetPresetsResponse", id, "");
	case SOAP_TYPE__tptz__GetPresets:
		return ((_tptz__GetPresets *)ptr)->soap_out(soap, "tptz:GetPresets", id, "");
	case SOAP_TYPE__tptz__SendAuxiliaryCommandResponse:
		return ((_tptz__SendAuxiliaryCommandResponse *)ptr)->soap_out(soap, "tptz:SendAuxiliaryCommandResponse", id, "");
	case SOAP_TYPE__tptz__SendAuxiliaryCommand:
		return ((_tptz__SendAuxiliaryCommand *)ptr)->soap_out(soap, "tptz:SendAuxiliaryCommand", id, "");
	case SOAP_TYPE__tptz__GetConfigurationOptionsResponse:
		return ((_tptz__GetConfigurationOptionsResponse *)ptr)->soap_out(soap, "tptz:GetConfigurationOptionsResponse", id, "");
	case SOAP_TYPE__tptz__GetConfigurationOptions:
		return ((_tptz__GetConfigurationOptions *)ptr)->soap_out(soap, "tptz:GetConfigurationOptions", id, "");
	case SOAP_TYPE__tptz__SetConfigurationResponse:
		return ((_tptz__SetConfigurationResponse *)ptr)->soap_out(soap, "tptz:SetConfigurationResponse", id, "");
	case SOAP_TYPE__tptz__SetConfiguration:
		return ((_tptz__SetConfiguration *)ptr)->soap_out(soap, "tptz:SetConfiguration", id, "");
	case SOAP_TYPE__tptz__GetConfigurationResponse:
		return ((_tptz__GetConfigurationResponse *)ptr)->soap_out(soap, "tptz:GetConfigurationResponse", id, "");
	case SOAP_TYPE__tptz__GetConfiguration:
		return ((_tptz__GetConfiguration *)ptr)->soap_out(soap, "tptz:GetConfiguration", id, "");
	case SOAP_TYPE__tptz__GetConfigurationsResponse:
		return ((_tptz__GetConfigurationsResponse *)ptr)->soap_out(soap, "tptz:GetConfigurationsResponse", id, "");
	case SOAP_TYPE__tptz__GetConfigurations:
		return ((_tptz__GetConfigurations *)ptr)->soap_out(soap, "tptz:GetConfigurations", id, "");
	case SOAP_TYPE__tptz__GetNodeResponse:
		return ((_tptz__GetNodeResponse *)ptr)->soap_out(soap, "tptz:GetNodeResponse", id, "");
	case SOAP_TYPE__tptz__GetNode:
		return ((_tptz__GetNode *)ptr)->soap_out(soap, "tptz:GetNode", id, "");
	case SOAP_TYPE__tptz__GetNodesResponse:
		return ((_tptz__GetNodesResponse *)ptr)->soap_out(soap, "tptz:GetNodesResponse", id, "");
	case SOAP_TYPE__tptz__GetNodes:
		return ((_tptz__GetNodes *)ptr)->soap_out(soap, "tptz:GetNodes", id, "");
	case SOAP_TYPE__tptz__GetServiceCapabilitiesResponse:
		return ((_tptz__GetServiceCapabilitiesResponse *)ptr)->soap_out(soap, "tptz:GetServiceCapabilitiesResponse", id, "");
	case SOAP_TYPE__tptz__GetServiceCapabilities:
		return ((_tptz__GetServiceCapabilities *)ptr)->soap_out(soap, "tptz:GetServiceCapabilities", id, "");
	case SOAP_TYPE_tptz__Capabilities:
		return ((tptz__Capabilities *)ptr)->soap_out(soap, tag, id, "tptz:Capabilities");
	case SOAP_TYPE__xml__lang:
		return soap_out__xml__lang(soap, "xml:lang", id, (const std::string *)ptr, "");
	case SOAP_TYPE_xsd__token:
		return soap_out_xsd__token(soap, tag, id, (const std::string *)ptr, "xsd:token");
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return soap_out_xsd__nonNegativeInteger(soap, tag, id, (const std::string *)ptr, "xsd:nonNegativeInteger");
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_xsd__duration:
		return soap_out_xsd__duration(soap, tag, id, (const std::string *)ptr, "xsd:duration");
	case SOAP_TYPE_xsd__anyURI:
		return soap_out_xsd__anyURI(soap, tag, id, (const std::string *)ptr, "xsd:anyURI");
	case SOAP_TYPE_xsd__anySimpleType:
		return soap_out_xsd__anySimpleType(soap, tag, id, (const std::string *)ptr, "xsd:anySimpleType");
	case SOAP_TYPE_xsd__NCName:
		return soap_out_xsd__NCName(soap, tag, id, (const std::string *)ptr, "xsd:NCName");
	case SOAP_TYPE_xsd__hexBinary:
		return ((xsd__hexBinary *)ptr)->soap_out(soap, tag, id, "xsd:hexBinary");
	case SOAP_TYPE_xsd__base64Binary:
		return ((xsd__base64Binary *)ptr)->soap_out(soap, tag, id, "xsd:base64Binary");
	case SOAP_TYPE_xsd__QName:
		return soap_out_xsd__QName(soap, tag, id, (const std::string *)ptr, "xsd:QName");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_xsd__anyType:
		return ((xsd__anyType *)ptr)->soap_out(soap, tag, id, "xsd:anyType");
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return soap_out_SOAP_ENV__Envelope(soap, tag, id, (const struct SOAP_ENV__Envelope *)ptr, "SOAP-ENV:Envelope");
	case SOAP_TYPE_chan__ChannelInstanceType:
		return soap_out_chan__ChannelInstanceType(soap, tag, id, (const struct chan__ChannelInstanceType *)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE__wsa5__ProblemAction:
		return soap_out__wsa5__ProblemAction(soap, "wsa5:ProblemAction", id, (const struct wsa5__ProblemActionType *)ptr, "");
	case SOAP_TYPE__wsa5__FaultTo:
		return soap_out__wsa5__FaultTo(soap, "wsa5:FaultTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__From:
		return soap_out__wsa5__From(soap, "wsa5:From", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__ReplyTo:
		return soap_out__wsa5__ReplyTo(soap, "wsa5:ReplyTo", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE__wsa5__RelatesTo:
		return soap_out__wsa5__RelatesTo(soap, "wsa5:RelatesTo", id, (const struct wsa5__RelatesToType *)ptr, "");
	case SOAP_TYPE__wsa5__Metadata:
		return soap_out__wsa5__Metadata(soap, "wsa5:Metadata", id, (const struct wsa5__MetadataType *)ptr, "");
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return soap_out__wsa5__ReferenceParameters(soap, "wsa5:ReferenceParameters", id, (const struct wsa5__ReferenceParametersType *)ptr, "");
	case SOAP_TYPE__wsa5__EndpointReference:
		return soap_out__wsa5__EndpointReference(soap, "wsa5:EndpointReference", id, (const struct wsa5__EndpointReferenceType *)ptr, "");
	case SOAP_TYPE_wsa5__ProblemActionType:
		return soap_out_wsa5__ProblemActionType(soap, tag, id, (const struct wsa5__ProblemActionType *)ptr, "wsa5:ProblemActionType");
	case SOAP_TYPE_wsa5__RelatesToType:
		return soap_out_wsa5__RelatesToType(soap, tag, id, (const struct wsa5__RelatesToType *)ptr, "wsa5:RelatesToType");
	case SOAP_TYPE_wsa5__MetadataType:
		return soap_out_wsa5__MetadataType(soap, tag, id, (const struct wsa5__MetadataType *)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return soap_out_wsa5__ReferenceParametersType(soap, tag, id, (const struct wsa5__ReferenceParametersType *)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return soap_out_wsa5__EndpointReferenceType(soap, tag, id, (const struct wsa5__EndpointReferenceType *)ptr, "wsa5:EndpointReferenceType");
	case SOAP_TYPE__xop__Include:
		return soap_out__xop__Include(soap, "xop:Include", id, (const struct _xop__Include *)ptr, "");
	case SOAP_TYPE_PointerTo_tptz__MoveAndStartTracking:
		return soap_out_PointerTo_tptz__MoveAndStartTracking(soap, tag, id, (_tptz__MoveAndStartTracking *const*)ptr, "tptz:MoveAndStartTracking");
	case SOAP_TYPE_PointerTo_tptz__GetCompatibleConfigurations:
		return soap_out_PointerTo_tptz__GetCompatibleConfigurations(soap, tag, id, (_tptz__GetCompatibleConfigurations *const*)ptr, "tptz:GetCompatibleConfigurations");
	case SOAP_TYPE_PointerTo_tptz__RemovePresetTour:
		return soap_out_PointerTo_tptz__RemovePresetTour(soap, tag, id, (_tptz__RemovePresetTour *const*)ptr, "tptz:RemovePresetTour");
	case SOAP_TYPE_PointerTo_tptz__OperatePresetTour:
		return soap_out_PointerTo_tptz__OperatePresetTour(soap, tag, id, (_tptz__OperatePresetTour *const*)ptr, "tptz:OperatePresetTour");
	case SOAP_TYPE_PointerTo_tptz__ModifyPresetTour:
		return soap_out_PointerTo_tptz__ModifyPresetTour(soap, tag, id, (_tptz__ModifyPresetTour *const*)ptr, "tptz:ModifyPresetTour");
	case SOAP_TYPE_PointerTo_tptz__CreatePresetTour:
		return soap_out_PointerTo_tptz__CreatePresetTour(soap, tag, id, (_tptz__CreatePresetTour *const*)ptr, "tptz:CreatePresetTour");
	case SOAP_TYPE_PointerTo_tptz__GetPresetTourOptions:
		return soap_out_PointerTo_tptz__GetPresetTourOptions(soap, tag, id, (_tptz__GetPresetTourOptions *const*)ptr, "tptz:GetPresetTourOptions");
	case SOAP_TYPE_PointerTo_tptz__GetPresetTour:
		return soap_out_PointerTo_tptz__GetPresetTour(soap, tag, id, (_tptz__GetPresetTour *const*)ptr, "tptz:GetPresetTour");
	case SOAP_TYPE_PointerTo_tptz__GetPresetTours:
		return soap_out_PointerTo_tptz__GetPresetTours(soap, tag, id, (_tptz__GetPresetTours *const*)ptr, "tptz:GetPresetTours");
	case SOAP_TYPE_PointerTo_tptz__Stop:
		return soap_out_PointerTo_tptz__Stop(soap, tag, id, (_tptz__Stop *const*)ptr, "tptz:Stop");
	case SOAP_TYPE_PointerTo_tptz__GeoMove:
		return soap_out_PointerTo_tptz__GeoMove(soap, tag, id, (_tptz__GeoMove *const*)ptr, "tptz:GeoMove");
	case SOAP_TYPE_PointerTo_tptz__AbsoluteMove:
		return soap_out_PointerTo_tptz__AbsoluteMove(soap, tag, id, (_tptz__AbsoluteMove *const*)ptr, "tptz:AbsoluteMove");
	case SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommand:
		return soap_out_PointerTo_tptz__SendAuxiliaryCommand(soap, tag, id, (_tptz__SendAuxiliaryCommand *const*)ptr, "tptz:SendAuxiliaryCommand");
	case SOAP_TYPE_PointerTo_tptz__RelativeMove:
		return soap_out_PointerTo_tptz__RelativeMove(soap, tag, id, (_tptz__RelativeMove *const*)ptr, "tptz:RelativeMove");
	case SOAP_TYPE_PointerTo_tptz__ContinuousMove:
		return soap_out_PointerTo_tptz__ContinuousMove(soap, tag, id, (_tptz__ContinuousMove *const*)ptr, "tptz:ContinuousMove");
	case SOAP_TYPE_PointerTo_tptz__SetHomePosition:
		return soap_out_PointerTo_tptz__SetHomePosition(soap, tag, id, (_tptz__SetHomePosition *const*)ptr, "tptz:SetHomePosition");
	case SOAP_TYPE_PointerTo_tptz__GotoHomePosition:
		return soap_out_PointerTo_tptz__GotoHomePosition(soap, tag, id, (_tptz__GotoHomePosition *const*)ptr, "tptz:GotoHomePosition");
	case SOAP_TYPE_PointerTo_tptz__GetConfigurationOptions:
		return soap_out_PointerTo_tptz__GetConfigurationOptions(soap, tag, id, (_tptz__GetConfigurationOptions *const*)ptr, "tptz:GetConfigurationOptions");
	case SOAP_TYPE_PointerTo_tptz__SetConfiguration:
		return soap_out_PointerTo_tptz__SetConfiguration(soap, tag, id, (_tptz__SetConfiguration *const*)ptr, "tptz:SetConfiguration");
	case SOAP_TYPE_PointerTo_tptz__GetNode:
		return soap_out_PointerTo_tptz__GetNode(soap, tag, id, (_tptz__GetNode *const*)ptr, "tptz:GetNode");
	case SOAP_TYPE_PointerTo_tptz__GetNodes:
		return soap_out_PointerTo_tptz__GetNodes(soap, tag, id, (_tptz__GetNodes *const*)ptr, "tptz:GetNodes");
	case SOAP_TYPE_PointerTo_tptz__GetConfiguration:
		return soap_out_PointerTo_tptz__GetConfiguration(soap, tag, id, (_tptz__GetConfiguration *const*)ptr, "tptz:GetConfiguration");
	case SOAP_TYPE_PointerTo_tptz__GetStatus:
		return soap_out_PointerTo_tptz__GetStatus(soap, tag, id, (_tptz__GetStatus *const*)ptr, "tptz:GetStatus");
	case SOAP_TYPE_PointerTo_tptz__GotoPreset:
		return soap_out_PointerTo_tptz__GotoPreset(soap, tag, id, (_tptz__GotoPreset *const*)ptr, "tptz:GotoPreset");
	case SOAP_TYPE_PointerTo_tptz__RemovePreset:
		return soap_out_PointerTo_tptz__RemovePreset(soap, tag, id, (_tptz__RemovePreset *const*)ptr, "tptz:RemovePreset");
	case SOAP_TYPE_PointerTo_tptz__SetPreset:
		return soap_out_PointerTo_tptz__SetPreset(soap, tag, id, (_tptz__SetPreset *const*)ptr, "tptz:SetPreset");
	case SOAP_TYPE_PointerTo_tptz__GetPresets:
		return soap_out_PointerTo_tptz__GetPresets(soap, tag, id, (_tptz__GetPresets *const*)ptr, "tptz:GetPresets");
	case SOAP_TYPE_PointerTo_tptz__GetConfigurations:
		return soap_out_PointerTo_tptz__GetConfigurations(soap, tag, id, (_tptz__GetConfigurations *const*)ptr, "tptz:GetConfigurations");
	case SOAP_TYPE_PointerTo_tptz__GetServiceCapabilities:
		return soap_out_PointerTo_tptz__GetServiceCapabilities(soap, tag, id, (_tptz__GetServiceCapabilities *const*)ptr, "tptz:GetServiceCapabilities");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		return soap_out_PointerTott__PTZConfigurationExtension(soap, tag, id, (tt__PTZConfigurationExtension *const*)ptr, "tt:PTZConfigurationExtension");
	case SOAP_TYPE_PointerTott__ZoomLimits:
		return soap_out_PointerTott__ZoomLimits(soap, tag, id, (tt__ZoomLimits *const*)ptr, "tt:ZoomLimits");
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		return soap_out_PointerTott__PanTiltLimits(soap, tag, id, (tt__PanTiltLimits *const*)ptr, "tt:PanTiltLimits");
	case SOAP_TYPE_PointerTott__PTZNodeExtension:
		return soap_out_PointerTott__PTZNodeExtension(soap, tag, id, (tt__PTZNodeExtension *const*)ptr, "tt:PTZNodeExtension");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTott__MoveStatus:
		return soap_out_PointerTott__MoveStatus(soap, tag, id, (enum tt__MoveStatus *const*)ptr, "tt:MoveStatus");
	case SOAP_TYPE_PointerTott__PTZMoveStatus:
		return soap_out_PointerTott__PTZMoveStatus(soap, tag, id, (tt__PTZMoveStatus *const*)ptr, "tt:PTZMoveStatus");
	case SOAP_TYPE_PointerToxsd__anyURI:
		return soap_out_PointerToxsd__anyURI(soap, tag, id, (std::string *const*)ptr, "xsd:anyURI");
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptionsExtension:
		return soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, tag, id, (tt__PTZPresetTourStartingConditionOptionsExtension *const*)ptr, "tt:PTZPresetTourStartingConditionOptionsExtension");
	case SOAP_TYPE_PointerTott__IntRange:
		return soap_out_PointerTott__IntRange(soap, tag, id, (tt__IntRange *const*)ptr, "tt:IntRange");
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptionsExtension:
		return soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, tag, id, (tt__PTZPresetTourPresetDetailOptionsExtension *const*)ptr, "tt:PTZPresetTourPresetDetailOptionsExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptions:
		return soap_out_PointerTott__PTZPresetTourPresetDetailOptions(soap, tag, id, (tt__PTZPresetTourPresetDetailOptions *const*)ptr, "tt:PTZPresetTourPresetDetailOptions");
	case SOAP_TYPE_PointerTott__PTZPresetTourSpotOptions:
		return soap_out_PointerTott__PTZPresetTourSpotOptions(soap, tag, id, (tt__PTZPresetTourSpotOptions *const*)ptr, "tt:PTZPresetTourSpotOptions");
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptions:
		return soap_out_PointerTott__PTZPresetTourStartingConditionOptions(soap, tag, id, (tt__PTZPresetTourStartingConditionOptions *const*)ptr, "tt:PTZPresetTourStartingConditionOptions");
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionExtension:
		return soap_out_PointerTott__PTZPresetTourStartingConditionExtension(soap, tag, id, (tt__PTZPresetTourStartingConditionExtension *const*)ptr, "tt:PTZPresetTourStartingConditionExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourDirection:
		return soap_out_PointerTott__PTZPresetTourDirection(soap, tag, id, (enum tt__PTZPresetTourDirection *const*)ptr, "tt:PTZPresetTourDirection");
	case SOAP_TYPE_PointerTott__PTZPresetTourStatusExtension:
		return soap_out_PointerTott__PTZPresetTourStatusExtension(soap, tag, id, (tt__PTZPresetTourStatusExtension *const*)ptr, "tt:PTZPresetTourStatusExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourTypeExtension:
		return soap_out_PointerTott__PTZPresetTourTypeExtension(soap, tag, id, (tt__PTZPresetTourTypeExtension *const*)ptr, "tt:PTZPresetTourTypeExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourSpotExtension:
		return soap_out_PointerTott__PTZPresetTourSpotExtension(soap, tag, id, (tt__PTZPresetTourSpotExtension *const*)ptr, "tt:PTZPresetTourSpotExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetail:
		return soap_out_PointerTott__PTZPresetTourPresetDetail(soap, tag, id, (tt__PTZPresetTourPresetDetail *const*)ptr, "tt:PTZPresetTourPresetDetail");
	case SOAP_TYPE_PointerTott__PTZPresetTourExtension:
		return soap_out_PointerTott__PTZPresetTourExtension(soap, tag, id, (tt__PTZPresetTourExtension *const*)ptr, "tt:PTZPresetTourExtension");
	case SOAP_TYPE_PointerTott__PTZPresetTourSpot:
		return soap_out_PointerTott__PTZPresetTourSpot(soap, tag, id, (tt__PTZPresetTourSpot *const*)ptr, "tt:PTZPresetTourSpot");
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingCondition:
		return soap_out_PointerTott__PTZPresetTourStartingCondition(soap, tag, id, (tt__PTZPresetTourStartingCondition *const*)ptr, "tt:PTZPresetTourStartingCondition");
	case SOAP_TYPE_PointerTott__PTZPresetTourStatus:
		return soap_out_PointerTott__PTZPresetTourStatus(soap, tag, id, (tt__PTZPresetTourStatus *const*)ptr, "tt:PTZPresetTourStatus");
	case SOAP_TYPE_PointerTott__Name:
		return soap_out_PointerTott__Name(soap, tag, id, (std::string *const*)ptr, "tt:Name");
	case SOAP_TYPE_PointerTott__Vector1D:
		return soap_out_PointerTott__Vector1D(soap, tag, id, (tt__Vector1D *const*)ptr, "tt:Vector1D");
	case SOAP_TYPE_PointerTott__Vector2D:
		return soap_out_PointerTott__Vector2D(soap, tag, id, (tt__Vector2D *const*)ptr, "tt:Vector2D");
	case SOAP_TYPE_PointerTott__FloatRange:
		return soap_out_PointerTott__FloatRange(soap, tag, id, (tt__FloatRange *const*)ptr, "tt:FloatRange");
	case SOAP_TYPE_PointerTott__PTZSpacesExtension:
		return soap_out_PointerTott__PTZSpacesExtension(soap, tag, id, (tt__PTZSpacesExtension *const*)ptr, "tt:PTZSpacesExtension");
	case SOAP_TYPE_PointerTott__Space1DDescription:
		return soap_out_PointerTott__Space1DDescription(soap, tag, id, (tt__Space1DDescription *const*)ptr, "tt:Space1DDescription");
	case SOAP_TYPE_PointerTott__Space2DDescription:
		return soap_out_PointerTott__Space2DDescription(soap, tag, id, (tt__Space2DDescription *const*)ptr, "tt:Space2DDescription");
	case SOAP_TYPE_PointerTott__ReverseOptionsExtension:
		return soap_out_PointerTott__ReverseOptionsExtension(soap, tag, id, (tt__ReverseOptionsExtension *const*)ptr, "tt:ReverseOptionsExtension");
	case SOAP_TYPE_PointerTott__EFlipOptionsExtension:
		return soap_out_PointerTott__EFlipOptionsExtension(soap, tag, id, (tt__EFlipOptionsExtension *const*)ptr, "tt:EFlipOptionsExtension");
	case SOAP_TYPE_PointerTott__PTControlDirectionOptionsExtension:
		return soap_out_PointerTott__PTControlDirectionOptionsExtension(soap, tag, id, (tt__PTControlDirectionOptionsExtension *const*)ptr, "tt:PTControlDirectionOptionsExtension");
	case SOAP_TYPE_PointerTott__ReverseOptions:
		return soap_out_PointerTott__ReverseOptions(soap, tag, id, (tt__ReverseOptions *const*)ptr, "tt:ReverseOptions");
	case SOAP_TYPE_PointerTott__EFlipOptions:
		return soap_out_PointerTott__EFlipOptions(soap, tag, id, (tt__EFlipOptions *const*)ptr, "tt:EFlipOptions");
	case SOAP_TYPE_PointerTott__IntAttrList:
		return soap_out_PointerTott__IntAttrList(soap, tag, id, (std::string *const*)ptr, "tt:IntAttrList");
	case SOAP_TYPE_PointerTott__PTZConfigurationOptions2:
		return soap_out_PointerTott__PTZConfigurationOptions2(soap, tag, id, (tt__PTZConfigurationOptions2 *const*)ptr, "tt:PTZConfigurationOptions2");
	case SOAP_TYPE_PointerTott__PTControlDirectionOptions:
		return soap_out_PointerTott__PTControlDirectionOptions(soap, tag, id, (tt__PTControlDirectionOptions *const*)ptr, "tt:PTControlDirectionOptions");
	case SOAP_TYPE_PointerTott__DurationRange:
		return soap_out_PointerTott__DurationRange(soap, tag, id, (tt__DurationRange *const*)ptr, "tt:DurationRange");
	case SOAP_TYPE_PointerTott__PTZSpaces:
		return soap_out_PointerTott__PTZSpaces(soap, tag, id, (tt__PTZSpaces *const*)ptr, "tt:PTZSpaces");
	case SOAP_TYPE_PointerTott__PTControlDirectionExtension:
		return soap_out_PointerTott__PTControlDirectionExtension(soap, tag, id, (tt__PTControlDirectionExtension *const*)ptr, "tt:PTControlDirectionExtension");
	case SOAP_TYPE_PointerTott__Reverse:
		return soap_out_PointerTott__Reverse(soap, tag, id, (tt__Reverse *const*)ptr, "tt:Reverse");
	case SOAP_TYPE_PointerTott__EFlip:
		return soap_out_PointerTott__EFlip(soap, tag, id, (tt__EFlip *const*)ptr, "tt:EFlip");
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension2:
		return soap_out_PointerTott__PTZConfigurationExtension2(soap, tag, id, (tt__PTZConfigurationExtension2 *const*)ptr, "tt:PTZConfigurationExtension2");
	case SOAP_TYPE_PointerTott__PTControlDirection:
		return soap_out_PointerTott__PTControlDirection(soap, tag, id, (tt__PTControlDirection *const*)ptr, "tt:PTControlDirection");
	case SOAP_TYPE_PointerTott__PTZPresetTourSupportedExtension:
		return soap_out_PointerTott__PTZPresetTourSupportedExtension(soap, tag, id, (tt__PTZPresetTourSupportedExtension *const*)ptr, "tt:PTZPresetTourSupportedExtension");
	case SOAP_TYPE_PointerTott__PTZNodeExtension2:
		return soap_out_PointerTott__PTZNodeExtension2(soap, tag, id, (tt__PTZNodeExtension2 *const*)ptr, "tt:PTZNodeExtension2");
	case SOAP_TYPE_PointerTott__PTZPresetTourSupported:
		return soap_out_PointerTott__PTZPresetTourSupported(soap, tag, id, (tt__PTZPresetTourSupported *const*)ptr, "tt:PTZPresetTourSupported");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::string *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTott__PTZPresetTourOptions:
		return soap_out_PointerTott__PTZPresetTourOptions(soap, tag, id, (tt__PTZPresetTourOptions *const*)ptr, "tt:PTZPresetTourOptions");
	case SOAP_TYPE_PointerTott__PresetTour:
		return soap_out_PointerTott__PresetTour(soap, tag, id, (tt__PresetTour *const*)ptr, "tt:PresetTour");
	case SOAP_TYPE_PointerTofloat:
		return soap_out_PointerTofloat(soap, tag, id, (float *const*)ptr, "xsd:float");
	case SOAP_TYPE_PointerTott__GeoLocation:
		return soap_out_PointerTott__GeoLocation(soap, tag, id, (tt__GeoLocation *const*)ptr, "tt:GeoLocation");
	case SOAP_TYPE_PointerTott__PTZVector:
		return soap_out_PointerTott__PTZVector(soap, tag, id, (tt__PTZVector *const*)ptr, "tt:PTZVector");
	case SOAP_TYPE_PointerToxsd__duration:
		return soap_out_PointerToxsd__duration(soap, tag, id, (std::string *const*)ptr, "xsd:duration");
	case SOAP_TYPE_PointerTott__PTZStatus:
		return soap_out_PointerTott__PTZStatus(soap, tag, id, (tt__PTZStatus *const*)ptr, "tt:PTZStatus");
	case SOAP_TYPE_PointerTott__PTZSpeed:
		return soap_out_PointerTott__PTZSpeed(soap, tag, id, (tt__PTZSpeed *const*)ptr, "tt:PTZSpeed");
	case SOAP_TYPE_PointerTott__ReferenceToken:
		return soap_out_PointerTott__ReferenceToken(soap, tag, id, (std::string *const*)ptr, "tt:ReferenceToken");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTott__PTZPreset:
		return soap_out_PointerTott__PTZPreset(soap, tag, id, (tt__PTZPreset *const*)ptr, "tt:PTZPreset");
	case SOAP_TYPE_PointerTott__PTZConfigurationOptions:
		return soap_out_PointerTott__PTZConfigurationOptions(soap, tag, id, (tt__PTZConfigurationOptions *const*)ptr, "tt:PTZConfigurationOptions");
	case SOAP_TYPE_PointerTott__PTZConfiguration:
		return soap_out_PointerTott__PTZConfiguration(soap, tag, id, (tt__PTZConfiguration *const*)ptr, "tt:PTZConfiguration");
	case SOAP_TYPE_PointerTott__PTZNode:
		return soap_out_PointerTott__PTZNode(soap, tag, id, (tt__PTZNode *const*)ptr, "tt:PTZNode");
	case SOAP_TYPE_PointerTotptz__Capabilities:
		return soap_out_PointerTotptz__Capabilities(soap, tag, id, (tptz__Capabilities *const*)ptr, "tptz:Capabilities");
	case SOAP_TYPE_PointerTott__StringList:
		return soap_out_PointerTott__StringList(soap, tag, id, (std::string *const*)ptr, "tt:StringList");
	case SOAP_TYPE_PointerTobool:
		return soap_out_PointerTobool(soap, tag, id, (bool *const*)ptr, "xsd:boolean");
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		return soap_out_PointerTochan__ChannelInstanceType(soap, tag, id, (struct chan__ChannelInstanceType *const*)ptr, "chan:ChannelInstanceType");
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		return soap_out_PointerTo_wsa5__FaultTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:FaultTo");
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		return soap_out_PointerTo_wsa5__ReplyTo(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:ReplyTo");
	case SOAP_TYPE_PointerTo_wsa5__From:
		return soap_out_PointerTo_wsa5__From(soap, tag, id, (struct wsa5__EndpointReferenceType *const*)ptr, "wsa5:From");
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		return soap_out_PointerTo_wsa5__RelatesTo(soap, tag, id, (struct wsa5__RelatesToType *const*)ptr, "wsa5:RelatesTo");
	case SOAP_TYPE__wsa5__ProblemIRI:
		return soap_out_string(soap, "wsa5:ProblemIRI", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE__wsa5__Action:
		return soap_out_string(soap, "wsa5:Action", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__To:
		return soap_out_string(soap, "wsa5:To", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE__wsa5__MessageID:
		return soap_out_string(soap, "wsa5:MessageID", id, (char*const*)(void*)&ptr, "");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		return soap_out_PointerTowsa5__MetadataType(soap, tag, id, (struct wsa5__MetadataType *const*)ptr, "wsa5:MetadataType");
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		return soap_out_PointerTowsa5__ReferenceParametersType(soap, tag, id, (struct wsa5__ReferenceParametersType *const*)ptr, "wsa5:ReferenceParametersType");
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:FaultCodesOpenEnumType");
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "wsa5:RelationshipTypeOpenEnum");
	case SOAP_TYPE_PointerTounsignedByte:
		return soap_out_PointerTounsignedByte(soap, tag, id, (unsigned char *const*)ptr, "xsd:unsignedByte");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.cpp\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag, 0, NULL); /* unknown type to serialize */
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_tt__ReferenceToken:
		soap_serialize_tt__ReferenceToken(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__AuxiliaryData:
		soap_serialize_tt__AuxiliaryData(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__Name:
		soap_serialize_tt__Name(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__StringList:
		soap_serialize_tt__StringList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__IntAttrList:
		soap_serialize_tt__IntAttrList(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_tt__GeoLocation:
		((tt__GeoLocation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZMoveStatus:
		((tt__PTZMoveStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZStatus:
		((tt__PTZStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZVector:
		((tt__PTZVector *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Vector1D:
		((tt__Vector1D *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Vector2D:
		((tt__Vector2D *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__IntRange:
		((tt__IntRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension:
		((tt__PTZPresetTourStartingConditionOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions:
		((tt__PTZPresetTourStartingConditionOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension:
		((tt__PTZPresetTourPresetDetailOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions:
		((tt__PTZPresetTourPresetDetailOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpotOptions:
		((tt__PTZPresetTourSpotOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourOptions:
		((tt__PTZPresetTourOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension:
		((tt__PTZPresetTourStartingConditionExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingCondition:
		((tt__PTZPresetTourStartingCondition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStatusExtension:
		((tt__PTZPresetTourStatusExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStatus:
		((tt__PTZPresetTourStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourTypeExtension:
		((tt__PTZPresetTourTypeExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetail:
		((tt__PTZPresetTourPresetDetail *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpotExtension:
		((tt__PTZPresetTourSpotExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpot:
		((tt__PTZPresetTourSpot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourExtension:
		((tt__PTZPresetTourExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PresetTour:
		((tt__PresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPreset:
		((tt__PTZPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		((tt__PTZSpeed *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		((tt__Space1DDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		((tt__Space2DDescription *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZSpacesExtension:
		((tt__PTZSpacesExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZSpaces:
		((tt__PTZSpaces *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		((tt__ZoomLimits *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		((tt__PanTiltLimits *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ReverseOptionsExtension:
		((tt__ReverseOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ReverseOptions:
		((tt__ReverseOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EFlipOptionsExtension:
		((tt__EFlipOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EFlipOptions:
		((tt__EFlipOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTControlDirectionOptionsExtension:
		((tt__PTControlDirectionOptionsExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTControlDirectionOptions:
		((tt__PTControlDirectionOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfigurationOptions2:
		((tt__PTZConfigurationOptions2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		((tt__PTZConfigurationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__Reverse:
		((tt__Reverse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__EFlip:
		((tt__EFlip *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		((tt__PTControlDirectionExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTControlDirection:
		((tt__PTControlDirection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		((tt__PTZConfigurationExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		((tt__PTZConfigurationExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZConfiguration:
		((tt__PTZConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSupportedExtension:
		((tt__PTZPresetTourSupportedExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSupported:
		((tt__PTZPresetTourSupported *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZNodeExtension2:
		((tt__PTZNodeExtension2 *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZNodeExtension:
		((tt__PTZNodeExtension *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__PTZNode:
		((tt__PTZNode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		((tt__ConfigurationEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DurationRange:
		((tt__DurationRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__FloatRange:
		((tt__FloatRange *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		((tt__DeviceEntity *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__MoveAndStartTrackingResponse:
		((_tptz__MoveAndStartTrackingResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__MoveAndStartTracking:
		((_tptz__MoveAndStartTracking *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse:
		((_tptz__GetCompatibleConfigurationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetCompatibleConfigurations:
		((_tptz__GetCompatibleConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__RemovePresetTourResponse:
		((_tptz__RemovePresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__RemovePresetTour:
		((_tptz__RemovePresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__OperatePresetTourResponse:
		((_tptz__OperatePresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__OperatePresetTour:
		((_tptz__OperatePresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__ModifyPresetTourResponse:
		((_tptz__ModifyPresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__ModifyPresetTour:
		((_tptz__ModifyPresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__CreatePresetTourResponse:
		((_tptz__CreatePresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__CreatePresetTour:
		((_tptz__CreatePresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetPresetTourOptionsResponse:
		((_tptz__GetPresetTourOptionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetPresetTourOptions:
		((_tptz__GetPresetTourOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetPresetTourResponse:
		((_tptz__GetPresetTourResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetPresetTour:
		((_tptz__GetPresetTour *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetPresetToursResponse:
		((_tptz__GetPresetToursResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetPresetTours:
		((_tptz__GetPresetTours *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__StopResponse:
		((_tptz__StopResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__Stop:
		((_tptz__Stop *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GeoMoveResponse:
		((_tptz__GeoMoveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GeoMove:
		((_tptz__GeoMove *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__AbsoluteMoveResponse:
		((_tptz__AbsoluteMoveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__AbsoluteMove:
		((_tptz__AbsoluteMove *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__RelativeMoveResponse:
		((_tptz__RelativeMoveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__RelativeMove:
		((_tptz__RelativeMove *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__ContinuousMoveResponse:
		((_tptz__ContinuousMoveResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__ContinuousMove:
		((_tptz__ContinuousMove *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__SetHomePositionResponse:
		((_tptz__SetHomePositionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__SetHomePosition:
		((_tptz__SetHomePosition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GotoHomePositionResponse:
		((_tptz__GotoHomePositionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GotoHomePosition:
		((_tptz__GotoHomePosition *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetStatusResponse:
		((_tptz__GetStatusResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetStatus:
		((_tptz__GetStatus *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GotoPresetResponse:
		((_tptz__GotoPresetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GotoPreset:
		((_tptz__GotoPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__RemovePresetResponse:
		((_tptz__RemovePresetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__RemovePreset:
		((_tptz__RemovePreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__SetPresetResponse:
		((_tptz__SetPresetResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__SetPreset:
		((_tptz__SetPreset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetPresetsResponse:
		((_tptz__GetPresetsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetPresets:
		((_tptz__GetPresets *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__SendAuxiliaryCommandResponse:
		((_tptz__SendAuxiliaryCommandResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__SendAuxiliaryCommand:
		((_tptz__SendAuxiliaryCommand *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetConfigurationOptionsResponse:
		((_tptz__GetConfigurationOptionsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetConfigurationOptions:
		((_tptz__GetConfigurationOptions *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__SetConfigurationResponse:
		((_tptz__SetConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__SetConfiguration:
		((_tptz__SetConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetConfigurationResponse:
		((_tptz__GetConfigurationResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetConfiguration:
		((_tptz__GetConfiguration *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetConfigurationsResponse:
		((_tptz__GetConfigurationsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetConfigurations:
		((_tptz__GetConfigurations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetNodeResponse:
		((_tptz__GetNodeResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetNode:
		((_tptz__GetNode *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetNodesResponse:
		((_tptz__GetNodesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetNodes:
		((_tptz__GetNodes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetServiceCapabilitiesResponse:
		((_tptz__GetServiceCapabilitiesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__tptz__GetServiceCapabilities:
		((_tptz__GetServiceCapabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_tptz__Capabilities:
		((tptz__Capabilities *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__xml__lang:
		soap_serialize__xml__lang(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__token:
		soap_serialize_xsd__token(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		soap_serialize_xsd__nonNegativeInteger(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__duration:
		soap_serialize_xsd__duration(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyURI:
		soap_serialize_xsd__anyURI(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		soap_serialize_xsd__anySimpleType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__NCName:
		soap_serialize_xsd__NCName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		((xsd__hexBinary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		((xsd__base64Binary *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_xsd__QName:
		soap_serialize_xsd__QName(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__anyType:
		((xsd__anyType *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___tptz__MoveAndStartTracking:
		soap_serialize___tptz__MoveAndStartTracking(soap, (const struct __tptz__MoveAndStartTracking *)ptr);
		break;
	case SOAP_TYPE___tptz__GetCompatibleConfigurations:
		soap_serialize___tptz__GetCompatibleConfigurations(soap, (const struct __tptz__GetCompatibleConfigurations *)ptr);
		break;
	case SOAP_TYPE___tptz__RemovePresetTour:
		soap_serialize___tptz__RemovePresetTour(soap, (const struct __tptz__RemovePresetTour *)ptr);
		break;
	case SOAP_TYPE___tptz__OperatePresetTour:
		soap_serialize___tptz__OperatePresetTour(soap, (const struct __tptz__OperatePresetTour *)ptr);
		break;
	case SOAP_TYPE___tptz__ModifyPresetTour:
		soap_serialize___tptz__ModifyPresetTour(soap, (const struct __tptz__ModifyPresetTour *)ptr);
		break;
	case SOAP_TYPE___tptz__CreatePresetTour:
		soap_serialize___tptz__CreatePresetTour(soap, (const struct __tptz__CreatePresetTour *)ptr);
		break;
	case SOAP_TYPE___tptz__GetPresetTourOptions:
		soap_serialize___tptz__GetPresetTourOptions(soap, (const struct __tptz__GetPresetTourOptions *)ptr);
		break;
	case SOAP_TYPE___tptz__GetPresetTour:
		soap_serialize___tptz__GetPresetTour(soap, (const struct __tptz__GetPresetTour *)ptr);
		break;
	case SOAP_TYPE___tptz__GetPresetTours:
		soap_serialize___tptz__GetPresetTours(soap, (const struct __tptz__GetPresetTours *)ptr);
		break;
	case SOAP_TYPE___tptz__Stop:
		soap_serialize___tptz__Stop(soap, (const struct __tptz__Stop *)ptr);
		break;
	case SOAP_TYPE___tptz__GeoMove:
		soap_serialize___tptz__GeoMove(soap, (const struct __tptz__GeoMove *)ptr);
		break;
	case SOAP_TYPE___tptz__AbsoluteMove:
		soap_serialize___tptz__AbsoluteMove(soap, (const struct __tptz__AbsoluteMove *)ptr);
		break;
	case SOAP_TYPE___tptz__SendAuxiliaryCommand:
		soap_serialize___tptz__SendAuxiliaryCommand(soap, (const struct __tptz__SendAuxiliaryCommand *)ptr);
		break;
	case SOAP_TYPE___tptz__RelativeMove:
		soap_serialize___tptz__RelativeMove(soap, (const struct __tptz__RelativeMove *)ptr);
		break;
	case SOAP_TYPE___tptz__ContinuousMove:
		soap_serialize___tptz__ContinuousMove(soap, (const struct __tptz__ContinuousMove *)ptr);
		break;
	case SOAP_TYPE___tptz__SetHomePosition:
		soap_serialize___tptz__SetHomePosition(soap, (const struct __tptz__SetHomePosition *)ptr);
		break;
	case SOAP_TYPE___tptz__GotoHomePosition:
		soap_serialize___tptz__GotoHomePosition(soap, (const struct __tptz__GotoHomePosition *)ptr);
		break;
	case SOAP_TYPE___tptz__GetConfigurationOptions:
		soap_serialize___tptz__GetConfigurationOptions(soap, (const struct __tptz__GetConfigurationOptions *)ptr);
		break;
	case SOAP_TYPE___tptz__SetConfiguration:
		soap_serialize___tptz__SetConfiguration(soap, (const struct __tptz__SetConfiguration *)ptr);
		break;
	case SOAP_TYPE___tptz__GetNode:
		soap_serialize___tptz__GetNode(soap, (const struct __tptz__GetNode *)ptr);
		break;
	case SOAP_TYPE___tptz__GetNodes:
		soap_serialize___tptz__GetNodes(soap, (const struct __tptz__GetNodes *)ptr);
		break;
	case SOAP_TYPE___tptz__GetConfiguration:
		soap_serialize___tptz__GetConfiguration(soap, (const struct __tptz__GetConfiguration *)ptr);
		break;
	case SOAP_TYPE___tptz__GetStatus:
		soap_serialize___tptz__GetStatus(soap, (const struct __tptz__GetStatus *)ptr);
		break;
	case SOAP_TYPE___tptz__GotoPreset:
		soap_serialize___tptz__GotoPreset(soap, (const struct __tptz__GotoPreset *)ptr);
		break;
	case SOAP_TYPE___tptz__RemovePreset:
		soap_serialize___tptz__RemovePreset(soap, (const struct __tptz__RemovePreset *)ptr);
		break;
	case SOAP_TYPE___tptz__SetPreset:
		soap_serialize___tptz__SetPreset(soap, (const struct __tptz__SetPreset *)ptr);
		break;
	case SOAP_TYPE___tptz__GetPresets:
		soap_serialize___tptz__GetPresets(soap, (const struct __tptz__GetPresets *)ptr);
		break;
	case SOAP_TYPE___tptz__GetConfigurations:
		soap_serialize___tptz__GetConfigurations(soap, (const struct __tptz__GetConfigurations *)ptr);
		break;
	case SOAP_TYPE___tptz__GetServiceCapabilities:
		soap_serialize___tptz__GetServiceCapabilities(soap, (const struct __tptz__GetServiceCapabilities *)ptr);
		break;
	case SOAP_TYPE___tptz__SetConfigurationResponse_sequence:
		soap_serialize___tptz__SetConfigurationResponse_sequence(soap, (const struct __tptz__SetConfigurationResponse_sequence *)ptr);
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		soap_serialize_SOAP_ENV__Envelope(soap, (const struct SOAP_ENV__Envelope *)ptr);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		soap_serialize_chan__ChannelInstanceType(soap, (const struct chan__ChannelInstanceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		soap_serialize__wsa5__ProblemAction(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		soap_serialize__wsa5__FaultTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__From:
		soap_serialize__wsa5__From(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		soap_serialize__wsa5__ReplyTo(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		soap_serialize__wsa5__RelatesTo(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		soap_serialize__wsa5__Metadata(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		soap_serialize__wsa5__ReferenceParameters(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		soap_serialize__wsa5__EndpointReference(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		soap_serialize_wsa5__ProblemActionType(soap, (const struct wsa5__ProblemActionType *)ptr);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		soap_serialize_wsa5__RelatesToType(soap, (const struct wsa5__RelatesToType *)ptr);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		soap_serialize_wsa5__MetadataType(soap, (const struct wsa5__MetadataType *)ptr);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		soap_serialize_wsa5__ReferenceParametersType(soap, (const struct wsa5__ReferenceParametersType *)ptr);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		soap_serialize_wsa5__EndpointReferenceType(soap, (const struct wsa5__EndpointReferenceType *)ptr);
		break;
	case SOAP_TYPE__xop__Include:
		soap_serialize__xop__Include(soap, (const struct _xop__Include *)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__MoveAndStartTracking:
		soap_serialize_PointerTo_tptz__MoveAndStartTracking(soap, (_tptz__MoveAndStartTracking *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetCompatibleConfigurations:
		soap_serialize_PointerTo_tptz__GetCompatibleConfigurations(soap, (_tptz__GetCompatibleConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__RemovePresetTour:
		soap_serialize_PointerTo_tptz__RemovePresetTour(soap, (_tptz__RemovePresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__OperatePresetTour:
		soap_serialize_PointerTo_tptz__OperatePresetTour(soap, (_tptz__OperatePresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__ModifyPresetTour:
		soap_serialize_PointerTo_tptz__ModifyPresetTour(soap, (_tptz__ModifyPresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__CreatePresetTour:
		soap_serialize_PointerTo_tptz__CreatePresetTour(soap, (_tptz__CreatePresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetPresetTourOptions:
		soap_serialize_PointerTo_tptz__GetPresetTourOptions(soap, (_tptz__GetPresetTourOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetPresetTour:
		soap_serialize_PointerTo_tptz__GetPresetTour(soap, (_tptz__GetPresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetPresetTours:
		soap_serialize_PointerTo_tptz__GetPresetTours(soap, (_tptz__GetPresetTours *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__Stop:
		soap_serialize_PointerTo_tptz__Stop(soap, (_tptz__Stop *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GeoMove:
		soap_serialize_PointerTo_tptz__GeoMove(soap, (_tptz__GeoMove *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__AbsoluteMove:
		soap_serialize_PointerTo_tptz__AbsoluteMove(soap, (_tptz__AbsoluteMove *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommand:
		soap_serialize_PointerTo_tptz__SendAuxiliaryCommand(soap, (_tptz__SendAuxiliaryCommand *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__RelativeMove:
		soap_serialize_PointerTo_tptz__RelativeMove(soap, (_tptz__RelativeMove *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__ContinuousMove:
		soap_serialize_PointerTo_tptz__ContinuousMove(soap, (_tptz__ContinuousMove *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__SetHomePosition:
		soap_serialize_PointerTo_tptz__SetHomePosition(soap, (_tptz__SetHomePosition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GotoHomePosition:
		soap_serialize_PointerTo_tptz__GotoHomePosition(soap, (_tptz__GotoHomePosition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetConfigurationOptions:
		soap_serialize_PointerTo_tptz__GetConfigurationOptions(soap, (_tptz__GetConfigurationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__SetConfiguration:
		soap_serialize_PointerTo_tptz__SetConfiguration(soap, (_tptz__SetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetNode:
		soap_serialize_PointerTo_tptz__GetNode(soap, (_tptz__GetNode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetNodes:
		soap_serialize_PointerTo_tptz__GetNodes(soap, (_tptz__GetNodes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetConfiguration:
		soap_serialize_PointerTo_tptz__GetConfiguration(soap, (_tptz__GetConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetStatus:
		soap_serialize_PointerTo_tptz__GetStatus(soap, (_tptz__GetStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GotoPreset:
		soap_serialize_PointerTo_tptz__GotoPreset(soap, (_tptz__GotoPreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__RemovePreset:
		soap_serialize_PointerTo_tptz__RemovePreset(soap, (_tptz__RemovePreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__SetPreset:
		soap_serialize_PointerTo_tptz__SetPreset(soap, (_tptz__SetPreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetPresets:
		soap_serialize_PointerTo_tptz__GetPresets(soap, (_tptz__GetPresets *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetConfigurations:
		soap_serialize_PointerTo_tptz__GetConfigurations(soap, (_tptz__GetConfigurations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_tptz__GetServiceCapabilities:
		soap_serialize_PointerTo_tptz__GetServiceCapabilities(soap, (_tptz__GetServiceCapabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension:
		soap_serialize_PointerTott__PTZConfigurationExtension(soap, (tt__PTZConfigurationExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ZoomLimits:
		soap_serialize_PointerTott__ZoomLimits(soap, (tt__ZoomLimits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PanTiltLimits:
		soap_serialize_PointerTott__PanTiltLimits(soap, (tt__PanTiltLimits *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZNodeExtension:
		soap_serialize_PointerTott__PTZNodeExtension(soap, (tt__PTZNodeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__MoveStatus:
		soap_serialize_PointerTott__MoveStatus(soap, (enum tt__MoveStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZMoveStatus:
		soap_serialize_PointerTott__PTZMoveStatus(soap, (tt__PTZMoveStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__anyURI:
		soap_serialize_PointerToxsd__anyURI(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptionsExtension:
		soap_serialize_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, (tt__PTZPresetTourStartingConditionOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntRange:
		soap_serialize_PointerTott__IntRange(soap, (tt__IntRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptionsExtension:
		soap_serialize_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, (tt__PTZPresetTourPresetDetailOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptions:
		soap_serialize_PointerTott__PTZPresetTourPresetDetailOptions(soap, (tt__PTZPresetTourPresetDetailOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourSpotOptions:
		soap_serialize_PointerTott__PTZPresetTourSpotOptions(soap, (tt__PTZPresetTourSpotOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptions:
		soap_serialize_PointerTott__PTZPresetTourStartingConditionOptions(soap, (tt__PTZPresetTourStartingConditionOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionExtension:
		soap_serialize_PointerTott__PTZPresetTourStartingConditionExtension(soap, (tt__PTZPresetTourStartingConditionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourDirection:
		soap_serialize_PointerTott__PTZPresetTourDirection(soap, (enum tt__PTZPresetTourDirection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourStatusExtension:
		soap_serialize_PointerTott__PTZPresetTourStatusExtension(soap, (tt__PTZPresetTourStatusExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourTypeExtension:
		soap_serialize_PointerTott__PTZPresetTourTypeExtension(soap, (tt__PTZPresetTourTypeExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourSpotExtension:
		soap_serialize_PointerTott__PTZPresetTourSpotExtension(soap, (tt__PTZPresetTourSpotExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourPresetDetail:
		soap_serialize_PointerTott__PTZPresetTourPresetDetail(soap, (tt__PTZPresetTourPresetDetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourExtension:
		soap_serialize_PointerTott__PTZPresetTourExtension(soap, (tt__PTZPresetTourExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourSpot:
		soap_serialize_PointerTott__PTZPresetTourSpot(soap, (tt__PTZPresetTourSpot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourStartingCondition:
		soap_serialize_PointerTott__PTZPresetTourStartingCondition(soap, (tt__PTZPresetTourStartingCondition *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourStatus:
		soap_serialize_PointerTott__PTZPresetTourStatus(soap, (tt__PTZPresetTourStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Name:
		soap_serialize_PointerTott__Name(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector1D:
		soap_serialize_PointerTott__Vector1D(soap, (tt__Vector1D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Vector2D:
		soap_serialize_PointerTott__Vector2D(soap, (tt__Vector2D *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__FloatRange:
		soap_serialize_PointerTott__FloatRange(soap, (tt__FloatRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZSpacesExtension:
		soap_serialize_PointerTott__PTZSpacesExtension(soap, (tt__PTZSpacesExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Space1DDescription:
		soap_serialize_PointerTott__Space1DDescription(soap, (tt__Space1DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Space2DDescription:
		soap_serialize_PointerTott__Space2DDescription(soap, (tt__Space2DDescription *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ReverseOptionsExtension:
		soap_serialize_PointerTott__ReverseOptionsExtension(soap, (tt__ReverseOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EFlipOptionsExtension:
		soap_serialize_PointerTott__EFlipOptionsExtension(soap, (tt__EFlipOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTControlDirectionOptionsExtension:
		soap_serialize_PointerTott__PTControlDirectionOptionsExtension(soap, (tt__PTControlDirectionOptionsExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ReverseOptions:
		soap_serialize_PointerTott__ReverseOptions(soap, (tt__ReverseOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EFlipOptions:
		soap_serialize_PointerTott__EFlipOptions(soap, (tt__EFlipOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__IntAttrList:
		soap_serialize_PointerTott__IntAttrList(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfigurationOptions2:
		soap_serialize_PointerTott__PTZConfigurationOptions2(soap, (tt__PTZConfigurationOptions2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTControlDirectionOptions:
		soap_serialize_PointerTott__PTControlDirectionOptions(soap, (tt__PTControlDirectionOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__DurationRange:
		soap_serialize_PointerTott__DurationRange(soap, (tt__DurationRange *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZSpaces:
		soap_serialize_PointerTott__PTZSpaces(soap, (tt__PTZSpaces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTControlDirectionExtension:
		soap_serialize_PointerTott__PTControlDirectionExtension(soap, (tt__PTControlDirectionExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__Reverse:
		soap_serialize_PointerTott__Reverse(soap, (tt__Reverse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__EFlip:
		soap_serialize_PointerTott__EFlip(soap, (tt__EFlip *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfigurationExtension2:
		soap_serialize_PointerTott__PTZConfigurationExtension2(soap, (tt__PTZConfigurationExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTControlDirection:
		soap_serialize_PointerTott__PTControlDirection(soap, (tt__PTControlDirection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourSupportedExtension:
		soap_serialize_PointerTott__PTZPresetTourSupportedExtension(soap, (tt__PTZPresetTourSupportedExtension *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZNodeExtension2:
		soap_serialize_PointerTott__PTZNodeExtension2(soap, (tt__PTZNodeExtension2 *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourSupported:
		soap_serialize_PointerTott__PTZPresetTourSupported(soap, (tt__PTZPresetTourSupported *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPresetTourOptions:
		soap_serialize_PointerTott__PTZPresetTourOptions(soap, (tt__PTZPresetTourOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PresetTour:
		soap_serialize_PointerTott__PresetTour(soap, (tt__PresetTour *const*)ptr);
		break;
	case SOAP_TYPE_PointerTofloat:
		soap_serialize_PointerTofloat(soap, (float *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__GeoLocation:
		soap_serialize_PointerTott__GeoLocation(soap, (tt__GeoLocation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZVector:
		soap_serialize_PointerTott__PTZVector(soap, (tt__PTZVector *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__duration:
		soap_serialize_PointerToxsd__duration(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZStatus:
		soap_serialize_PointerTott__PTZStatus(soap, (tt__PTZStatus *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZSpeed:
		soap_serialize_PointerTott__PTZSpeed(soap, (tt__PTZSpeed *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__ReferenceToken:
		soap_serialize_PointerTott__ReferenceToken(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZPreset:
		soap_serialize_PointerTott__PTZPreset(soap, (tt__PTZPreset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfigurationOptions:
		soap_serialize_PointerTott__PTZConfigurationOptions(soap, (tt__PTZConfigurationOptions *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__tptz__SetConfigurationResponse_sequence:
		soap_serialize_PointerTo__tptz__SetConfigurationResponse_sequence(soap, (struct __tptz__SetConfigurationResponse_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZConfiguration:
		soap_serialize_PointerTott__PTZConfiguration(soap, (tt__PTZConfiguration *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__PTZNode:
		soap_serialize_PointerTott__PTZNode(soap, (tt__PTZNode *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotptz__Capabilities:
		soap_serialize_PointerTotptz__Capabilities(soap, (tptz__Capabilities *const*)ptr);
		break;
	case SOAP_TYPE_PointerTott__StringList:
		soap_serialize_PointerTott__StringList(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTobool:
		soap_serialize_PointerTobool(soap, (bool *const*)ptr);
		break;
	case SOAP_TYPE_PointerTochan__ChannelInstanceType:
		soap_serialize_PointerTochan__ChannelInstanceType(soap, (struct chan__ChannelInstanceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__FaultTo:
		soap_serialize_PointerTo_wsa5__FaultTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__ReplyTo:
		soap_serialize_PointerTo_wsa5__ReplyTo(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__From:
		soap_serialize_PointerTo_wsa5__From(soap, (struct wsa5__EndpointReferenceType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_wsa5__RelatesTo:
		soap_serialize_PointerTo_wsa5__RelatesTo(soap, (struct wsa5__RelatesToType *const*)ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemIRI:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__ProblemHeaderQName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__Action:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__To:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE__wsa5__MessageID:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__MetadataType:
		soap_serialize_PointerTowsa5__MetadataType(soap, (struct wsa5__MetadataType *const*)ptr);
		break;
	case SOAP_TYPE_PointerTowsa5__ReferenceParametersType:
		soap_serialize_PointerTowsa5__ReferenceParametersType(soap, (struct wsa5__ReferenceParametersType *const*)ptr);
		break;
	case SOAP_TYPE_wsa5__FaultCodesOpenEnumType:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_wsa5__RelationshipTypeOpenEnum:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_PointerTounsignedByte:
		soap_serialize_PointerTounsignedByte(soap, (unsigned char *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#ifdef __cplusplus
}
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}
#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE__xop__Include:
		return (void*)soap_instantiate__xop__Include(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		return (void*)soap_instantiate_wsa5__EndpointReferenceType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		return (void*)soap_instantiate_wsa5__ReferenceParametersType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__MetadataType:
		return (void*)soap_instantiate_wsa5__MetadataType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__ProblemActionType:
		return (void*)soap_instantiate_wsa5__ProblemActionType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_wsa5__RelatesToType:
		return (void*)soap_instantiate_wsa5__RelatesToType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_chan__ChannelInstanceType:
		return (void*)soap_instantiate_chan__ChannelInstanceType(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__anyType:
		return (void*)soap_instantiate_xsd__anyType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_SOAP_ENV__Envelope:
		return (void*)soap_instantiate_SOAP_ENV__Envelope(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__base64Binary:
		return (void*)soap_instantiate_xsd__base64Binary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__hexBinary:
		return (void*)soap_instantiate_xsd__hexBinary(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tptz__Capabilities:
		return (void*)soap_instantiate_tptz__Capabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetServiceCapabilities:
		return (void*)soap_instantiate__tptz__GetServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetServiceCapabilitiesResponse:
		return (void*)soap_instantiate__tptz__GetServiceCapabilitiesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetNodes:
		return (void*)soap_instantiate__tptz__GetNodes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetNodesResponse:
		return (void*)soap_instantiate__tptz__GetNodesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetNode:
		return (void*)soap_instantiate__tptz__GetNode(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetNodeResponse:
		return (void*)soap_instantiate__tptz__GetNodeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetConfigurations:
		return (void*)soap_instantiate__tptz__GetConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetConfigurationsResponse:
		return (void*)soap_instantiate__tptz__GetConfigurationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetConfiguration:
		return (void*)soap_instantiate__tptz__GetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetConfigurationResponse:
		return (void*)soap_instantiate__tptz__GetConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__SetConfiguration:
		return (void*)soap_instantiate__tptz__SetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__SetConfigurationResponse_sequence:
		return (void*)soap_instantiate___tptz__SetConfigurationResponse_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__SetConfigurationResponse:
		return (void*)soap_instantiate__tptz__SetConfigurationResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetConfigurationOptions:
		return (void*)soap_instantiate__tptz__GetConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetConfigurationOptionsResponse:
		return (void*)soap_instantiate__tptz__GetConfigurationOptionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__SendAuxiliaryCommand:
		return (void*)soap_instantiate__tptz__SendAuxiliaryCommand(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__SendAuxiliaryCommandResponse:
		return (void*)soap_instantiate__tptz__SendAuxiliaryCommandResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetPresets:
		return (void*)soap_instantiate__tptz__GetPresets(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetPresetsResponse:
		return (void*)soap_instantiate__tptz__GetPresetsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__SetPreset:
		return (void*)soap_instantiate__tptz__SetPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__SetPresetResponse:
		return (void*)soap_instantiate__tptz__SetPresetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__RemovePreset:
		return (void*)soap_instantiate__tptz__RemovePreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__RemovePresetResponse:
		return (void*)soap_instantiate__tptz__RemovePresetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GotoPreset:
		return (void*)soap_instantiate__tptz__GotoPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GotoPresetResponse:
		return (void*)soap_instantiate__tptz__GotoPresetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetStatus:
		return (void*)soap_instantiate__tptz__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetStatusResponse:
		return (void*)soap_instantiate__tptz__GetStatusResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GotoHomePosition:
		return (void*)soap_instantiate__tptz__GotoHomePosition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GotoHomePositionResponse:
		return (void*)soap_instantiate__tptz__GotoHomePositionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__SetHomePosition:
		return (void*)soap_instantiate__tptz__SetHomePosition(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__SetHomePositionResponse:
		return (void*)soap_instantiate__tptz__SetHomePositionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__ContinuousMove:
		return (void*)soap_instantiate__tptz__ContinuousMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__ContinuousMoveResponse:
		return (void*)soap_instantiate__tptz__ContinuousMoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__RelativeMove:
		return (void*)soap_instantiate__tptz__RelativeMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__RelativeMoveResponse:
		return (void*)soap_instantiate__tptz__RelativeMoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__AbsoluteMove:
		return (void*)soap_instantiate__tptz__AbsoluteMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__AbsoluteMoveResponse:
		return (void*)soap_instantiate__tptz__AbsoluteMoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GeoMove:
		return (void*)soap_instantiate__tptz__GeoMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GeoMoveResponse:
		return (void*)soap_instantiate__tptz__GeoMoveResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__Stop:
		return (void*)soap_instantiate__tptz__Stop(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__StopResponse:
		return (void*)soap_instantiate__tptz__StopResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetPresetTours:
		return (void*)soap_instantiate__tptz__GetPresetTours(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetPresetToursResponse:
		return (void*)soap_instantiate__tptz__GetPresetToursResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetPresetTour:
		return (void*)soap_instantiate__tptz__GetPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetPresetTourResponse:
		return (void*)soap_instantiate__tptz__GetPresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetPresetTourOptions:
		return (void*)soap_instantiate__tptz__GetPresetTourOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetPresetTourOptionsResponse:
		return (void*)soap_instantiate__tptz__GetPresetTourOptionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__CreatePresetTour:
		return (void*)soap_instantiate__tptz__CreatePresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__CreatePresetTourResponse:
		return (void*)soap_instantiate__tptz__CreatePresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__ModifyPresetTour:
		return (void*)soap_instantiate__tptz__ModifyPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__ModifyPresetTourResponse:
		return (void*)soap_instantiate__tptz__ModifyPresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__OperatePresetTour:
		return (void*)soap_instantiate__tptz__OperatePresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__OperatePresetTourResponse:
		return (void*)soap_instantiate__tptz__OperatePresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__RemovePresetTour:
		return (void*)soap_instantiate__tptz__RemovePresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__RemovePresetTourResponse:
		return (void*)soap_instantiate__tptz__RemovePresetTourResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetCompatibleConfigurations:
		return (void*)soap_instantiate__tptz__GetCompatibleConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse:
		return (void*)soap_instantiate__tptz__GetCompatibleConfigurationsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__MoveAndStartTracking:
		return (void*)soap_instantiate__tptz__MoveAndStartTracking(soap, -1, type, arrayType, n);
	case SOAP_TYPE__tptz__MoveAndStartTrackingResponse:
		return (void*)soap_instantiate__tptz__MoveAndStartTrackingResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DeviceEntity:
		return (void*)soap_instantiate_tt__DeviceEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__FloatRange:
		return (void*)soap_instantiate_tt__FloatRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__DurationRange:
		return (void*)soap_instantiate_tt__DurationRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ConfigurationEntity:
		return (void*)soap_instantiate_tt__ConfigurationEntity(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZNodeExtension:
		return (void*)soap_instantiate_tt__PTZNodeExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZNodeExtension2:
		return (void*)soap_instantiate_tt__PTZNodeExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourSupported:
		return (void*)soap_instantiate_tt__PTZPresetTourSupported(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourSupportedExtension:
		return (void*)soap_instantiate_tt__PTZPresetTourSupportedExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		return (void*)soap_instantiate_tt__PTZConfigurationExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		return (void*)soap_instantiate_tt__PTZConfigurationExtension2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTControlDirection:
		return (void*)soap_instantiate_tt__PTControlDirection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		return (void*)soap_instantiate_tt__PTControlDirectionExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EFlip:
		return (void*)soap_instantiate_tt__EFlip(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Reverse:
		return (void*)soap_instantiate_tt__Reverse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		return (void*)soap_instantiate_tt__PTZConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfigurationOptions2:
		return (void*)soap_instantiate_tt__PTZConfigurationOptions2(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTControlDirectionOptions:
		return (void*)soap_instantiate_tt__PTControlDirectionOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTControlDirectionOptionsExtension:
		return (void*)soap_instantiate_tt__PTControlDirectionOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EFlipOptions:
		return (void*)soap_instantiate_tt__EFlipOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__EFlipOptionsExtension:
		return (void*)soap_instantiate_tt__EFlipOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReverseOptions:
		return (void*)soap_instantiate_tt__ReverseOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReverseOptionsExtension:
		return (void*)soap_instantiate_tt__ReverseOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PanTiltLimits:
		return (void*)soap_instantiate_tt__PanTiltLimits(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ZoomLimits:
		return (void*)soap_instantiate_tt__ZoomLimits(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZSpaces:
		return (void*)soap_instantiate_tt__PTZSpaces(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZSpacesExtension:
		return (void*)soap_instantiate_tt__PTZSpacesExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Space2DDescription:
		return (void*)soap_instantiate_tt__Space2DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Space1DDescription:
		return (void*)soap_instantiate_tt__Space1DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZSpeed:
		return (void*)soap_instantiate_tt__PTZSpeed(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPreset:
		return (void*)soap_instantiate_tt__PTZPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PresetTour:
		return (void*)soap_instantiate_tt__PresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourExtension:
		return (void*)soap_instantiate_tt__PTZPresetTourExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourSpot:
		return (void*)soap_instantiate_tt__PTZPresetTourSpot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourSpotExtension:
		return (void*)soap_instantiate_tt__PTZPresetTourSpotExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourPresetDetail:
		return (void*)soap_instantiate_tt__PTZPresetTourPresetDetail(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourTypeExtension:
		return (void*)soap_instantiate_tt__PTZPresetTourTypeExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourStatus:
		return (void*)soap_instantiate_tt__PTZPresetTourStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourStatusExtension:
		return (void*)soap_instantiate_tt__PTZPresetTourStatusExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourStartingCondition:
		return (void*)soap_instantiate_tt__PTZPresetTourStartingCondition(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension:
		return (void*)soap_instantiate_tt__PTZPresetTourStartingConditionExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourOptions:
		return (void*)soap_instantiate_tt__PTZPresetTourOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourSpotOptions:
		return (void*)soap_instantiate_tt__PTZPresetTourSpotOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions:
		return (void*)soap_instantiate_tt__PTZPresetTourPresetDetailOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension:
		return (void*)soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions:
		return (void*)soap_instantiate_tt__PTZPresetTourStartingConditionOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension:
		return (void*)soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntRange:
		return (void*)soap_instantiate_tt__IntRange(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Vector2D:
		return (void*)soap_instantiate_tt__Vector2D(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Vector1D:
		return (void*)soap_instantiate_tt__Vector1D(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZVector:
		return (void*)soap_instantiate_tt__PTZVector(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZStatus:
		return (void*)soap_instantiate_tt__PTZStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZMoveStatus:
		return (void*)soap_instantiate_tt__PTZMoveStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__GeoLocation:
		return (void*)soap_instantiate_tt__GeoLocation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZNode:
		return (void*)soap_instantiate_tt__PTZNode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__PTZConfiguration:
		return (void*)soap_instantiate_tt__PTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetServiceCapabilities:
		return (void*)soap_instantiate___tptz__GetServiceCapabilities(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetConfigurations:
		return (void*)soap_instantiate___tptz__GetConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetPresets:
		return (void*)soap_instantiate___tptz__GetPresets(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__SetPreset:
		return (void*)soap_instantiate___tptz__SetPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__RemovePreset:
		return (void*)soap_instantiate___tptz__RemovePreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GotoPreset:
		return (void*)soap_instantiate___tptz__GotoPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetStatus:
		return (void*)soap_instantiate___tptz__GetStatus(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetConfiguration:
		return (void*)soap_instantiate___tptz__GetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetNodes:
		return (void*)soap_instantiate___tptz__GetNodes(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetNode:
		return (void*)soap_instantiate___tptz__GetNode(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__SetConfiguration:
		return (void*)soap_instantiate___tptz__SetConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetConfigurationOptions:
		return (void*)soap_instantiate___tptz__GetConfigurationOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GotoHomePosition:
		return (void*)soap_instantiate___tptz__GotoHomePosition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__SetHomePosition:
		return (void*)soap_instantiate___tptz__SetHomePosition(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__ContinuousMove:
		return (void*)soap_instantiate___tptz__ContinuousMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__RelativeMove:
		return (void*)soap_instantiate___tptz__RelativeMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__SendAuxiliaryCommand:
		return (void*)soap_instantiate___tptz__SendAuxiliaryCommand(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__AbsoluteMove:
		return (void*)soap_instantiate___tptz__AbsoluteMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GeoMove:
		return (void*)soap_instantiate___tptz__GeoMove(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__Stop:
		return (void*)soap_instantiate___tptz__Stop(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetPresetTours:
		return (void*)soap_instantiate___tptz__GetPresetTours(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetPresetTour:
		return (void*)soap_instantiate___tptz__GetPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetPresetTourOptions:
		return (void*)soap_instantiate___tptz__GetPresetTourOptions(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__CreatePresetTour:
		return (void*)soap_instantiate___tptz__CreatePresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__ModifyPresetTour:
		return (void*)soap_instantiate___tptz__ModifyPresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__OperatePresetTour:
		return (void*)soap_instantiate___tptz__OperatePresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__RemovePresetTour:
		return (void*)soap_instantiate___tptz__RemovePresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__GetCompatibleConfigurations:
		return (void*)soap_instantiate___tptz__GetCompatibleConfigurations(soap, -1, type, arrayType, n);
	case SOAP_TYPE___tptz__MoveAndStartTracking:
		return (void*)soap_instantiate___tptz__MoveAndStartTracking(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__EndpointReference:
		return (void*)soap_instantiate__wsa5__EndpointReference(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReferenceParameters:
		return (void*)soap_instantiate__wsa5__ReferenceParameters(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__Metadata:
		return (void*)soap_instantiate__wsa5__Metadata(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__RelatesTo:
		return (void*)soap_instantiate__wsa5__RelatesTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ReplyTo:
		return (void*)soap_instantiate__wsa5__ReplyTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__From:
		return (void*)soap_instantiate__wsa5__From(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__FaultTo:
		return (void*)soap_instantiate__wsa5__FaultTo(soap, -1, type, arrayType, n);
	case SOAP_TYPE__wsa5__ProblemAction:
		return (void*)soap_instantiate__wsa5__ProblemAction(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__QName:
		return (void*)soap_instantiate_xsd__QName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__NCName:
		return (void*)soap_instantiate_xsd__NCName(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anySimpleType:
		return (void*)soap_instantiate_xsd__anySimpleType(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__anyURI:
		return (void*)soap_instantiate_xsd__anyURI(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__duration:
		return (void*)soap_instantiate_xsd__duration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__nonNegativeInteger:
		return (void*)soap_instantiate_xsd__nonNegativeInteger(soap, -1, type, arrayType, n);
	case SOAP_TYPE_xsd__token:
		return (void*)soap_instantiate_xsd__token(soap, -1, type, arrayType, n);
	case SOAP_TYPE__xml__lang:
		return (void*)soap_instantiate__xml__lang(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__IntAttrList:
		return (void*)soap_instantiate_tt__IntAttrList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__StringList:
		return (void*)soap_instantiate_tt__StringList(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__Name:
		return (void*)soap_instantiate_tt__Name(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__AuxiliaryData:
		return (void*)soap_instantiate_tt__AuxiliaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_tt__ReferenceToken:
		return (void*)soap_instantiate_tt__ReferenceToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		return (void*)soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection:
		return (void*)soap_instantiate_std__vectorTemplateOftt__PTZPresetTourDirection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		return (void*)soap_instantiate_std__vectorTemplateOftt__ReferenceToken(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__ReverseMode:
		return (void*)soap_instantiate_std__vectorTemplateOftt__ReverseMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__EFlipMode:
		return (void*)soap_instantiate_std__vectorTemplateOftt__EFlipMode(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation:
		return (void*)soap_instantiate_std__vectorTemplateOftt__PTZPresetTourOperation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PresetTour(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PTZPreset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTott__PTZNode(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap *soap, struct soap_clist *p)
{
	(void)soap; /* appease -Wall -Werror */
	if (!p->ptr)
		return SOAP_OK;
	switch (p->type)
	{
	case SOAP_TYPE__xop__Include:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct _xop__Include*>(p->ptr), struct _xop__Include);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct _xop__Include*>(p->ptr), struct _xop__Include);
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct chan__ChannelInstanceType*>(p->ptr), struct chan__ChannelInstanceType);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Header*>(p->ptr), struct SOAP_ENV__Header);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Detail*>(p->ptr), struct SOAP_ENV__Detail);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Code*>(p->ptr), struct SOAP_ENV__Code);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Reason*>(p->ptr), struct SOAP_ENV__Reason);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Fault*>(p->ptr), struct SOAP_ENV__Fault);
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__anyType*>(p->ptr), xsd__anyType);
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct SOAP_ENV__Envelope*>(p->ptr), struct SOAP_ENV__Envelope);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct SOAP_ENV__Envelope*>(p->ptr), struct SOAP_ENV__Envelope);
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__base64Binary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__base64Binary*>(p->ptr), xsd__base64Binary);
		break;
	case SOAP_TYPE_xsd__hexBinary:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<xsd__hexBinary*>(p->ptr), xsd__hexBinary);
		break;
	case SOAP_TYPE_tptz__Capabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tptz__Capabilities*>(p->ptr), tptz__Capabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tptz__Capabilities*>(p->ptr), tptz__Capabilities);
		break;
	case SOAP_TYPE__tptz__GetServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetServiceCapabilities*>(p->ptr), _tptz__GetServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetServiceCapabilities*>(p->ptr), _tptz__GetServiceCapabilities);
		break;
	case SOAP_TYPE__tptz__GetServiceCapabilitiesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetServiceCapabilitiesResponse*>(p->ptr), _tptz__GetServiceCapabilitiesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetServiceCapabilitiesResponse*>(p->ptr), _tptz__GetServiceCapabilitiesResponse);
		break;
	case SOAP_TYPE__tptz__GetNodes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetNodes*>(p->ptr), _tptz__GetNodes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetNodes*>(p->ptr), _tptz__GetNodes);
		break;
	case SOAP_TYPE__tptz__GetNodesResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetNodesResponse*>(p->ptr), _tptz__GetNodesResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetNodesResponse*>(p->ptr), _tptz__GetNodesResponse);
		break;
	case SOAP_TYPE__tptz__GetNode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetNode*>(p->ptr), _tptz__GetNode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetNode*>(p->ptr), _tptz__GetNode);
		break;
	case SOAP_TYPE__tptz__GetNodeResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetNodeResponse*>(p->ptr), _tptz__GetNodeResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetNodeResponse*>(p->ptr), _tptz__GetNodeResponse);
		break;
	case SOAP_TYPE__tptz__GetConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetConfigurations*>(p->ptr), _tptz__GetConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetConfigurations*>(p->ptr), _tptz__GetConfigurations);
		break;
	case SOAP_TYPE__tptz__GetConfigurationsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetConfigurationsResponse*>(p->ptr), _tptz__GetConfigurationsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetConfigurationsResponse*>(p->ptr), _tptz__GetConfigurationsResponse);
		break;
	case SOAP_TYPE__tptz__GetConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetConfiguration*>(p->ptr), _tptz__GetConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetConfiguration*>(p->ptr), _tptz__GetConfiguration);
		break;
	case SOAP_TYPE__tptz__GetConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetConfigurationResponse*>(p->ptr), _tptz__GetConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetConfigurationResponse*>(p->ptr), _tptz__GetConfigurationResponse);
		break;
	case SOAP_TYPE__tptz__SetConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__SetConfiguration*>(p->ptr), _tptz__SetConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__SetConfiguration*>(p->ptr), _tptz__SetConfiguration);
		break;
	case SOAP_TYPE___tptz__SetConfigurationResponse_sequence:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__SetConfigurationResponse_sequence*>(p->ptr), struct __tptz__SetConfigurationResponse_sequence);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__SetConfigurationResponse_sequence*>(p->ptr), struct __tptz__SetConfigurationResponse_sequence);
		break;
	case SOAP_TYPE__tptz__SetConfigurationResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__SetConfigurationResponse*>(p->ptr), _tptz__SetConfigurationResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__SetConfigurationResponse*>(p->ptr), _tptz__SetConfigurationResponse);
		break;
	case SOAP_TYPE__tptz__GetConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetConfigurationOptions*>(p->ptr), _tptz__GetConfigurationOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetConfigurationOptions*>(p->ptr), _tptz__GetConfigurationOptions);
		break;
	case SOAP_TYPE__tptz__GetConfigurationOptionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetConfigurationOptionsResponse*>(p->ptr), _tptz__GetConfigurationOptionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetConfigurationOptionsResponse*>(p->ptr), _tptz__GetConfigurationOptionsResponse);
		break;
	case SOAP_TYPE__tptz__SendAuxiliaryCommand:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__SendAuxiliaryCommand*>(p->ptr), _tptz__SendAuxiliaryCommand);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__SendAuxiliaryCommand*>(p->ptr), _tptz__SendAuxiliaryCommand);
		break;
	case SOAP_TYPE__tptz__SendAuxiliaryCommandResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__SendAuxiliaryCommandResponse*>(p->ptr), _tptz__SendAuxiliaryCommandResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__SendAuxiliaryCommandResponse*>(p->ptr), _tptz__SendAuxiliaryCommandResponse);
		break;
	case SOAP_TYPE__tptz__GetPresets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetPresets*>(p->ptr), _tptz__GetPresets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetPresets*>(p->ptr), _tptz__GetPresets);
		break;
	case SOAP_TYPE__tptz__GetPresetsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetPresetsResponse*>(p->ptr), _tptz__GetPresetsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetPresetsResponse*>(p->ptr), _tptz__GetPresetsResponse);
		break;
	case SOAP_TYPE__tptz__SetPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__SetPreset*>(p->ptr), _tptz__SetPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__SetPreset*>(p->ptr), _tptz__SetPreset);
		break;
	case SOAP_TYPE__tptz__SetPresetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__SetPresetResponse*>(p->ptr), _tptz__SetPresetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__SetPresetResponse*>(p->ptr), _tptz__SetPresetResponse);
		break;
	case SOAP_TYPE__tptz__RemovePreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__RemovePreset*>(p->ptr), _tptz__RemovePreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__RemovePreset*>(p->ptr), _tptz__RemovePreset);
		break;
	case SOAP_TYPE__tptz__RemovePresetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__RemovePresetResponse*>(p->ptr), _tptz__RemovePresetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__RemovePresetResponse*>(p->ptr), _tptz__RemovePresetResponse);
		break;
	case SOAP_TYPE__tptz__GotoPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GotoPreset*>(p->ptr), _tptz__GotoPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GotoPreset*>(p->ptr), _tptz__GotoPreset);
		break;
	case SOAP_TYPE__tptz__GotoPresetResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GotoPresetResponse*>(p->ptr), _tptz__GotoPresetResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GotoPresetResponse*>(p->ptr), _tptz__GotoPresetResponse);
		break;
	case SOAP_TYPE__tptz__GetStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetStatus*>(p->ptr), _tptz__GetStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetStatus*>(p->ptr), _tptz__GetStatus);
		break;
	case SOAP_TYPE__tptz__GetStatusResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetStatusResponse*>(p->ptr), _tptz__GetStatusResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetStatusResponse*>(p->ptr), _tptz__GetStatusResponse);
		break;
	case SOAP_TYPE__tptz__GotoHomePosition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GotoHomePosition*>(p->ptr), _tptz__GotoHomePosition);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GotoHomePosition*>(p->ptr), _tptz__GotoHomePosition);
		break;
	case SOAP_TYPE__tptz__GotoHomePositionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GotoHomePositionResponse*>(p->ptr), _tptz__GotoHomePositionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GotoHomePositionResponse*>(p->ptr), _tptz__GotoHomePositionResponse);
		break;
	case SOAP_TYPE__tptz__SetHomePosition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__SetHomePosition*>(p->ptr), _tptz__SetHomePosition);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__SetHomePosition*>(p->ptr), _tptz__SetHomePosition);
		break;
	case SOAP_TYPE__tptz__SetHomePositionResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__SetHomePositionResponse*>(p->ptr), _tptz__SetHomePositionResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__SetHomePositionResponse*>(p->ptr), _tptz__SetHomePositionResponse);
		break;
	case SOAP_TYPE__tptz__ContinuousMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__ContinuousMove*>(p->ptr), _tptz__ContinuousMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__ContinuousMove*>(p->ptr), _tptz__ContinuousMove);
		break;
	case SOAP_TYPE__tptz__ContinuousMoveResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__ContinuousMoveResponse*>(p->ptr), _tptz__ContinuousMoveResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__ContinuousMoveResponse*>(p->ptr), _tptz__ContinuousMoveResponse);
		break;
	case SOAP_TYPE__tptz__RelativeMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__RelativeMove*>(p->ptr), _tptz__RelativeMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__RelativeMove*>(p->ptr), _tptz__RelativeMove);
		break;
	case SOAP_TYPE__tptz__RelativeMoveResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__RelativeMoveResponse*>(p->ptr), _tptz__RelativeMoveResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__RelativeMoveResponse*>(p->ptr), _tptz__RelativeMoveResponse);
		break;
	case SOAP_TYPE__tptz__AbsoluteMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__AbsoluteMove*>(p->ptr), _tptz__AbsoluteMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__AbsoluteMove*>(p->ptr), _tptz__AbsoluteMove);
		break;
	case SOAP_TYPE__tptz__AbsoluteMoveResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__AbsoluteMoveResponse*>(p->ptr), _tptz__AbsoluteMoveResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__AbsoluteMoveResponse*>(p->ptr), _tptz__AbsoluteMoveResponse);
		break;
	case SOAP_TYPE__tptz__GeoMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GeoMove*>(p->ptr), _tptz__GeoMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GeoMove*>(p->ptr), _tptz__GeoMove);
		break;
	case SOAP_TYPE__tptz__GeoMoveResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GeoMoveResponse*>(p->ptr), _tptz__GeoMoveResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GeoMoveResponse*>(p->ptr), _tptz__GeoMoveResponse);
		break;
	case SOAP_TYPE__tptz__Stop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__Stop*>(p->ptr), _tptz__Stop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__Stop*>(p->ptr), _tptz__Stop);
		break;
	case SOAP_TYPE__tptz__StopResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__StopResponse*>(p->ptr), _tptz__StopResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__StopResponse*>(p->ptr), _tptz__StopResponse);
		break;
	case SOAP_TYPE__tptz__GetPresetTours:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetPresetTours*>(p->ptr), _tptz__GetPresetTours);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetPresetTours*>(p->ptr), _tptz__GetPresetTours);
		break;
	case SOAP_TYPE__tptz__GetPresetToursResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetPresetToursResponse*>(p->ptr), _tptz__GetPresetToursResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetPresetToursResponse*>(p->ptr), _tptz__GetPresetToursResponse);
		break;
	case SOAP_TYPE__tptz__GetPresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetPresetTour*>(p->ptr), _tptz__GetPresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetPresetTour*>(p->ptr), _tptz__GetPresetTour);
		break;
	case SOAP_TYPE__tptz__GetPresetTourResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetPresetTourResponse*>(p->ptr), _tptz__GetPresetTourResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetPresetTourResponse*>(p->ptr), _tptz__GetPresetTourResponse);
		break;
	case SOAP_TYPE__tptz__GetPresetTourOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetPresetTourOptions*>(p->ptr), _tptz__GetPresetTourOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetPresetTourOptions*>(p->ptr), _tptz__GetPresetTourOptions);
		break;
	case SOAP_TYPE__tptz__GetPresetTourOptionsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetPresetTourOptionsResponse*>(p->ptr), _tptz__GetPresetTourOptionsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetPresetTourOptionsResponse*>(p->ptr), _tptz__GetPresetTourOptionsResponse);
		break;
	case SOAP_TYPE__tptz__CreatePresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__CreatePresetTour*>(p->ptr), _tptz__CreatePresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__CreatePresetTour*>(p->ptr), _tptz__CreatePresetTour);
		break;
	case SOAP_TYPE__tptz__CreatePresetTourResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__CreatePresetTourResponse*>(p->ptr), _tptz__CreatePresetTourResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__CreatePresetTourResponse*>(p->ptr), _tptz__CreatePresetTourResponse);
		break;
	case SOAP_TYPE__tptz__ModifyPresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__ModifyPresetTour*>(p->ptr), _tptz__ModifyPresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__ModifyPresetTour*>(p->ptr), _tptz__ModifyPresetTour);
		break;
	case SOAP_TYPE__tptz__ModifyPresetTourResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__ModifyPresetTourResponse*>(p->ptr), _tptz__ModifyPresetTourResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__ModifyPresetTourResponse*>(p->ptr), _tptz__ModifyPresetTourResponse);
		break;
	case SOAP_TYPE__tptz__OperatePresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__OperatePresetTour*>(p->ptr), _tptz__OperatePresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__OperatePresetTour*>(p->ptr), _tptz__OperatePresetTour);
		break;
	case SOAP_TYPE__tptz__OperatePresetTourResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__OperatePresetTourResponse*>(p->ptr), _tptz__OperatePresetTourResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__OperatePresetTourResponse*>(p->ptr), _tptz__OperatePresetTourResponse);
		break;
	case SOAP_TYPE__tptz__RemovePresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__RemovePresetTour*>(p->ptr), _tptz__RemovePresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__RemovePresetTour*>(p->ptr), _tptz__RemovePresetTour);
		break;
	case SOAP_TYPE__tptz__RemovePresetTourResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__RemovePresetTourResponse*>(p->ptr), _tptz__RemovePresetTourResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__RemovePresetTourResponse*>(p->ptr), _tptz__RemovePresetTourResponse);
		break;
	case SOAP_TYPE__tptz__GetCompatibleConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetCompatibleConfigurations*>(p->ptr), _tptz__GetCompatibleConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetCompatibleConfigurations*>(p->ptr), _tptz__GetCompatibleConfigurations);
		break;
	case SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__GetCompatibleConfigurationsResponse*>(p->ptr), _tptz__GetCompatibleConfigurationsResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__GetCompatibleConfigurationsResponse*>(p->ptr), _tptz__GetCompatibleConfigurationsResponse);
		break;
	case SOAP_TYPE__tptz__MoveAndStartTracking:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__MoveAndStartTracking*>(p->ptr), _tptz__MoveAndStartTracking);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__MoveAndStartTracking*>(p->ptr), _tptz__MoveAndStartTracking);
		break;
	case SOAP_TYPE__tptz__MoveAndStartTrackingResponse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<_tptz__MoveAndStartTrackingResponse*>(p->ptr), _tptz__MoveAndStartTrackingResponse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<_tptz__MoveAndStartTrackingResponse*>(p->ptr), _tptz__MoveAndStartTrackingResponse);
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DeviceEntity*>(p->ptr), tt__DeviceEntity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DeviceEntity*>(p->ptr), tt__DeviceEntity);
		break;
	case SOAP_TYPE_tt__FloatRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__FloatRange*>(p->ptr), tt__FloatRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__FloatRange*>(p->ptr), tt__FloatRange);
		break;
	case SOAP_TYPE_tt__DurationRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__DurationRange*>(p->ptr), tt__DurationRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__DurationRange*>(p->ptr), tt__DurationRange);
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ConfigurationEntity*>(p->ptr), tt__ConfigurationEntity);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ConfigurationEntity*>(p->ptr), tt__ConfigurationEntity);
		break;
	case SOAP_TYPE_tt__PTZNodeExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZNodeExtension*>(p->ptr), tt__PTZNodeExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZNodeExtension*>(p->ptr), tt__PTZNodeExtension);
		break;
	case SOAP_TYPE_tt__PTZNodeExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZNodeExtension2*>(p->ptr), tt__PTZNodeExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZNodeExtension2*>(p->ptr), tt__PTZNodeExtension2);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSupported:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourSupported*>(p->ptr), tt__PTZPresetTourSupported);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourSupported*>(p->ptr), tt__PTZPresetTourSupported);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSupportedExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourSupportedExtension*>(p->ptr), tt__PTZPresetTourSupportedExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourSupportedExtension*>(p->ptr), tt__PTZPresetTourSupportedExtension);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZConfigurationExtension*>(p->ptr), tt__PTZConfigurationExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZConfigurationExtension*>(p->ptr), tt__PTZConfigurationExtension);
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZConfigurationExtension2*>(p->ptr), tt__PTZConfigurationExtension2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZConfigurationExtension2*>(p->ptr), tt__PTZConfigurationExtension2);
		break;
	case SOAP_TYPE_tt__PTControlDirection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTControlDirection*>(p->ptr), tt__PTControlDirection);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTControlDirection*>(p->ptr), tt__PTControlDirection);
		break;
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTControlDirectionExtension*>(p->ptr), tt__PTControlDirectionExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTControlDirectionExtension*>(p->ptr), tt__PTControlDirectionExtension);
		break;
	case SOAP_TYPE_tt__EFlip:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EFlip*>(p->ptr), tt__EFlip);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EFlip*>(p->ptr), tt__EFlip);
		break;
	case SOAP_TYPE_tt__Reverse:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Reverse*>(p->ptr), tt__Reverse);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Reverse*>(p->ptr), tt__Reverse);
		break;
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZConfigurationOptions*>(p->ptr), tt__PTZConfigurationOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZConfigurationOptions*>(p->ptr), tt__PTZConfigurationOptions);
		break;
	case SOAP_TYPE_tt__PTZConfigurationOptions2:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZConfigurationOptions2*>(p->ptr), tt__PTZConfigurationOptions2);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZConfigurationOptions2*>(p->ptr), tt__PTZConfigurationOptions2);
		break;
	case SOAP_TYPE_tt__PTControlDirectionOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTControlDirectionOptions*>(p->ptr), tt__PTControlDirectionOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTControlDirectionOptions*>(p->ptr), tt__PTControlDirectionOptions);
		break;
	case SOAP_TYPE_tt__PTControlDirectionOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTControlDirectionOptionsExtension*>(p->ptr), tt__PTControlDirectionOptionsExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTControlDirectionOptionsExtension*>(p->ptr), tt__PTControlDirectionOptionsExtension);
		break;
	case SOAP_TYPE_tt__EFlipOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EFlipOptions*>(p->ptr), tt__EFlipOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EFlipOptions*>(p->ptr), tt__EFlipOptions);
		break;
	case SOAP_TYPE_tt__EFlipOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__EFlipOptionsExtension*>(p->ptr), tt__EFlipOptionsExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__EFlipOptionsExtension*>(p->ptr), tt__EFlipOptionsExtension);
		break;
	case SOAP_TYPE_tt__ReverseOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ReverseOptions*>(p->ptr), tt__ReverseOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ReverseOptions*>(p->ptr), tt__ReverseOptions);
		break;
	case SOAP_TYPE_tt__ReverseOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ReverseOptionsExtension*>(p->ptr), tt__ReverseOptionsExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ReverseOptionsExtension*>(p->ptr), tt__ReverseOptionsExtension);
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PanTiltLimits*>(p->ptr), tt__PanTiltLimits);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PanTiltLimits*>(p->ptr), tt__PanTiltLimits);
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__ZoomLimits*>(p->ptr), tt__ZoomLimits);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__ZoomLimits*>(p->ptr), tt__ZoomLimits);
		break;
	case SOAP_TYPE_tt__PTZSpaces:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZSpaces*>(p->ptr), tt__PTZSpaces);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZSpaces*>(p->ptr), tt__PTZSpaces);
		break;
	case SOAP_TYPE_tt__PTZSpacesExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZSpacesExtension*>(p->ptr), tt__PTZSpacesExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZSpacesExtension*>(p->ptr), tt__PTZSpacesExtension);
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Space2DDescription*>(p->ptr), tt__Space2DDescription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Space2DDescription*>(p->ptr), tt__Space2DDescription);
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Space1DDescription*>(p->ptr), tt__Space1DDescription);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Space1DDescription*>(p->ptr), tt__Space1DDescription);
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZSpeed*>(p->ptr), tt__PTZSpeed);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZSpeed*>(p->ptr), tt__PTZSpeed);
		break;
	case SOAP_TYPE_tt__PTZPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPreset*>(p->ptr), tt__PTZPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPreset*>(p->ptr), tt__PTZPreset);
		break;
	case SOAP_TYPE_tt__PresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PresetTour*>(p->ptr), tt__PresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PresetTour*>(p->ptr), tt__PresetTour);
		break;
	case SOAP_TYPE_tt__PTZPresetTourExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourExtension*>(p->ptr), tt__PTZPresetTourExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourExtension*>(p->ptr), tt__PTZPresetTourExtension);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpot:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourSpot*>(p->ptr), tt__PTZPresetTourSpot);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourSpot*>(p->ptr), tt__PTZPresetTourSpot);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpotExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourSpotExtension*>(p->ptr), tt__PTZPresetTourSpotExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourSpotExtension*>(p->ptr), tt__PTZPresetTourSpotExtension);
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetail:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourPresetDetail*>(p->ptr), tt__PTZPresetTourPresetDetail);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourPresetDetail*>(p->ptr), tt__PTZPresetTourPresetDetail);
		break;
	case SOAP_TYPE_tt__PTZPresetTourTypeExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourTypeExtension*>(p->ptr), tt__PTZPresetTourTypeExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourTypeExtension*>(p->ptr), tt__PTZPresetTourTypeExtension);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourStatus*>(p->ptr), tt__PTZPresetTourStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourStatus*>(p->ptr), tt__PTZPresetTourStatus);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStatusExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourStatusExtension*>(p->ptr), tt__PTZPresetTourStatusExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourStatusExtension*>(p->ptr), tt__PTZPresetTourStatusExtension);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingCondition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourStartingCondition*>(p->ptr), tt__PTZPresetTourStartingCondition);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourStartingCondition*>(p->ptr), tt__PTZPresetTourStartingCondition);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourStartingConditionExtension*>(p->ptr), tt__PTZPresetTourStartingConditionExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourStartingConditionExtension*>(p->ptr), tt__PTZPresetTourStartingConditionExtension);
		break;
	case SOAP_TYPE_tt__PTZPresetTourOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourOptions*>(p->ptr), tt__PTZPresetTourOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourOptions*>(p->ptr), tt__PTZPresetTourOptions);
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpotOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourSpotOptions*>(p->ptr), tt__PTZPresetTourSpotOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourSpotOptions*>(p->ptr), tt__PTZPresetTourSpotOptions);
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourPresetDetailOptions*>(p->ptr), tt__PTZPresetTourPresetDetailOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourPresetDetailOptions*>(p->ptr), tt__PTZPresetTourPresetDetailOptions);
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourPresetDetailOptionsExtension*>(p->ptr), tt__PTZPresetTourPresetDetailOptionsExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourPresetDetailOptionsExtension*>(p->ptr), tt__PTZPresetTourPresetDetailOptionsExtension);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourStartingConditionOptions*>(p->ptr), tt__PTZPresetTourStartingConditionOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourStartingConditionOptions*>(p->ptr), tt__PTZPresetTourStartingConditionOptions);
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZPresetTourStartingConditionOptionsExtension*>(p->ptr), tt__PTZPresetTourStartingConditionOptionsExtension);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZPresetTourStartingConditionOptionsExtension*>(p->ptr), tt__PTZPresetTourStartingConditionOptionsExtension);
		break;
	case SOAP_TYPE_tt__IntRange:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__IntRange*>(p->ptr), tt__IntRange);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__IntRange*>(p->ptr), tt__IntRange);
		break;
	case SOAP_TYPE_tt__Vector2D:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Vector2D*>(p->ptr), tt__Vector2D);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Vector2D*>(p->ptr), tt__Vector2D);
		break;
	case SOAP_TYPE_tt__Vector1D:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__Vector1D*>(p->ptr), tt__Vector1D);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__Vector1D*>(p->ptr), tt__Vector1D);
		break;
	case SOAP_TYPE_tt__PTZVector:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZVector*>(p->ptr), tt__PTZVector);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZVector*>(p->ptr), tt__PTZVector);
		break;
	case SOAP_TYPE_tt__PTZStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZStatus*>(p->ptr), tt__PTZStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZStatus*>(p->ptr), tt__PTZStatus);
		break;
	case SOAP_TYPE_tt__PTZMoveStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZMoveStatus*>(p->ptr), tt__PTZMoveStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZMoveStatus*>(p->ptr), tt__PTZMoveStatus);
		break;
	case SOAP_TYPE_tt__GeoLocation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__GeoLocation*>(p->ptr), tt__GeoLocation);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__GeoLocation*>(p->ptr), tt__GeoLocation);
		break;
	case SOAP_TYPE_tt__PTZNode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZNode*>(p->ptr), tt__PTZNode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZNode*>(p->ptr), tt__PTZNode);
		break;
	case SOAP_TYPE_tt__PTZConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<tt__PTZConfiguration*>(p->ptr), tt__PTZConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<tt__PTZConfiguration*>(p->ptr), tt__PTZConfiguration);
		break;
	case SOAP_TYPE___tptz__GetServiceCapabilities:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetServiceCapabilities*>(p->ptr), struct __tptz__GetServiceCapabilities);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetServiceCapabilities*>(p->ptr), struct __tptz__GetServiceCapabilities);
		break;
	case SOAP_TYPE___tptz__GetConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetConfigurations*>(p->ptr), struct __tptz__GetConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetConfigurations*>(p->ptr), struct __tptz__GetConfigurations);
		break;
	case SOAP_TYPE___tptz__GetPresets:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetPresets*>(p->ptr), struct __tptz__GetPresets);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetPresets*>(p->ptr), struct __tptz__GetPresets);
		break;
	case SOAP_TYPE___tptz__SetPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__SetPreset*>(p->ptr), struct __tptz__SetPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__SetPreset*>(p->ptr), struct __tptz__SetPreset);
		break;
	case SOAP_TYPE___tptz__RemovePreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__RemovePreset*>(p->ptr), struct __tptz__RemovePreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__RemovePreset*>(p->ptr), struct __tptz__RemovePreset);
		break;
	case SOAP_TYPE___tptz__GotoPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GotoPreset*>(p->ptr), struct __tptz__GotoPreset);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GotoPreset*>(p->ptr), struct __tptz__GotoPreset);
		break;
	case SOAP_TYPE___tptz__GetStatus:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetStatus*>(p->ptr), struct __tptz__GetStatus);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetStatus*>(p->ptr), struct __tptz__GetStatus);
		break;
	case SOAP_TYPE___tptz__GetConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetConfiguration*>(p->ptr), struct __tptz__GetConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetConfiguration*>(p->ptr), struct __tptz__GetConfiguration);
		break;
	case SOAP_TYPE___tptz__GetNodes:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetNodes*>(p->ptr), struct __tptz__GetNodes);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetNodes*>(p->ptr), struct __tptz__GetNodes);
		break;
	case SOAP_TYPE___tptz__GetNode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetNode*>(p->ptr), struct __tptz__GetNode);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetNode*>(p->ptr), struct __tptz__GetNode);
		break;
	case SOAP_TYPE___tptz__SetConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__SetConfiguration*>(p->ptr), struct __tptz__SetConfiguration);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__SetConfiguration*>(p->ptr), struct __tptz__SetConfiguration);
		break;
	case SOAP_TYPE___tptz__GetConfigurationOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetConfigurationOptions*>(p->ptr), struct __tptz__GetConfigurationOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetConfigurationOptions*>(p->ptr), struct __tptz__GetConfigurationOptions);
		break;
	case SOAP_TYPE___tptz__GotoHomePosition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GotoHomePosition*>(p->ptr), struct __tptz__GotoHomePosition);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GotoHomePosition*>(p->ptr), struct __tptz__GotoHomePosition);
		break;
	case SOAP_TYPE___tptz__SetHomePosition:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__SetHomePosition*>(p->ptr), struct __tptz__SetHomePosition);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__SetHomePosition*>(p->ptr), struct __tptz__SetHomePosition);
		break;
	case SOAP_TYPE___tptz__ContinuousMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__ContinuousMove*>(p->ptr), struct __tptz__ContinuousMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__ContinuousMove*>(p->ptr), struct __tptz__ContinuousMove);
		break;
	case SOAP_TYPE___tptz__RelativeMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__RelativeMove*>(p->ptr), struct __tptz__RelativeMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__RelativeMove*>(p->ptr), struct __tptz__RelativeMove);
		break;
	case SOAP_TYPE___tptz__SendAuxiliaryCommand:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__SendAuxiliaryCommand*>(p->ptr), struct __tptz__SendAuxiliaryCommand);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__SendAuxiliaryCommand*>(p->ptr), struct __tptz__SendAuxiliaryCommand);
		break;
	case SOAP_TYPE___tptz__AbsoluteMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__AbsoluteMove*>(p->ptr), struct __tptz__AbsoluteMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__AbsoluteMove*>(p->ptr), struct __tptz__AbsoluteMove);
		break;
	case SOAP_TYPE___tptz__GeoMove:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GeoMove*>(p->ptr), struct __tptz__GeoMove);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GeoMove*>(p->ptr), struct __tptz__GeoMove);
		break;
	case SOAP_TYPE___tptz__Stop:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__Stop*>(p->ptr), struct __tptz__Stop);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__Stop*>(p->ptr), struct __tptz__Stop);
		break;
	case SOAP_TYPE___tptz__GetPresetTours:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetPresetTours*>(p->ptr), struct __tptz__GetPresetTours);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetPresetTours*>(p->ptr), struct __tptz__GetPresetTours);
		break;
	case SOAP_TYPE___tptz__GetPresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetPresetTour*>(p->ptr), struct __tptz__GetPresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetPresetTour*>(p->ptr), struct __tptz__GetPresetTour);
		break;
	case SOAP_TYPE___tptz__GetPresetTourOptions:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetPresetTourOptions*>(p->ptr), struct __tptz__GetPresetTourOptions);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetPresetTourOptions*>(p->ptr), struct __tptz__GetPresetTourOptions);
		break;
	case SOAP_TYPE___tptz__CreatePresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__CreatePresetTour*>(p->ptr), struct __tptz__CreatePresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__CreatePresetTour*>(p->ptr), struct __tptz__CreatePresetTour);
		break;
	case SOAP_TYPE___tptz__ModifyPresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__ModifyPresetTour*>(p->ptr), struct __tptz__ModifyPresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__ModifyPresetTour*>(p->ptr), struct __tptz__ModifyPresetTour);
		break;
	case SOAP_TYPE___tptz__OperatePresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__OperatePresetTour*>(p->ptr), struct __tptz__OperatePresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__OperatePresetTour*>(p->ptr), struct __tptz__OperatePresetTour);
		break;
	case SOAP_TYPE___tptz__RemovePresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__RemovePresetTour*>(p->ptr), struct __tptz__RemovePresetTour);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__RemovePresetTour*>(p->ptr), struct __tptz__RemovePresetTour);
		break;
	case SOAP_TYPE___tptz__GetCompatibleConfigurations:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__GetCompatibleConfigurations*>(p->ptr), struct __tptz__GetCompatibleConfigurations);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__GetCompatibleConfigurations*>(p->ptr), struct __tptz__GetCompatibleConfigurations);
		break;
	case SOAP_TYPE___tptz__MoveAndStartTracking:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct __tptz__MoveAndStartTracking*>(p->ptr), struct __tptz__MoveAndStartTracking);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct __tptz__MoveAndStartTracking*>(p->ptr), struct __tptz__MoveAndStartTracking);
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ReferenceParametersType*>(p->ptr), struct wsa5__ReferenceParametersType);
		break;
	case SOAP_TYPE__wsa5__Metadata:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__MetadataType*>(p->ptr), struct wsa5__MetadataType);
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__RelatesToType*>(p->ptr), struct wsa5__RelatesToType);
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__From:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__EndpointReferenceType*>(p->ptr), struct wsa5__EndpointReferenceType);
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<struct wsa5__ProblemActionType*>(p->ptr), struct wsa5__ProblemActionType);
		break;
	case SOAP_TYPE_xsd__QName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__NCName:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__anyURI:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__duration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_xsd__token:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE__xml__lang:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__IntAttrList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__StringList:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__Name:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__AuxiliaryData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::string*>(p->ptr), std::string);
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::string*>(p->ptr), std::string);
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__PTZPresetTourDirection> *>(p->ptr), std::vector<enum tt__PTZPresetTourDirection> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__PTZPresetTourDirection> *>(p->ptr), std::vector<enum tt__PTZPresetTourDirection> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<std::string> *>(p->ptr), std::vector<std::string> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__PTZPresetTourSpot *> *>(p->ptr), std::vector<tt__PTZPresetTourSpot *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__PTZPresetTourSpot *> *>(p->ptr), std::vector<tt__PTZPresetTourSpot *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Space1DDescription *> *>(p->ptr), std::vector<tt__Space1DDescription *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Space1DDescription *> *>(p->ptr), std::vector<tt__Space1DDescription *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__Space2DDescription *> *>(p->ptr), std::vector<tt__Space2DDescription *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__Space2DDescription *> *>(p->ptr), std::vector<tt__Space2DDescription *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ReverseMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__ReverseMode> *>(p->ptr), std::vector<enum tt__ReverseMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__ReverseMode> *>(p->ptr), std::vector<enum tt__ReverseMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__EFlipMode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__EFlipMode> *>(p->ptr), std::vector<enum tt__EFlipMode> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__EFlipMode> *>(p->ptr), std::vector<enum tt__EFlipMode> );
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<enum tt__PTZPresetTourOperation> *>(p->ptr), std::vector<enum tt__PTZPresetTourOperation> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<enum tt__PTZPresetTourOperation> *>(p->ptr), std::vector<enum tt__PTZPresetTourOperation> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__PresetTour *> *>(p->ptr), std::vector<tt__PresetTour *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__PresetTour *> *>(p->ptr), std::vector<tt__PresetTour *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__PTZPreset *> *>(p->ptr), std::vector<tt__PTZPreset *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__PTZPreset *> *>(p->ptr), std::vector<tt__PTZPreset *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__PTZConfiguration *> *>(p->ptr), std::vector<tt__PTZConfiguration *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__PTZConfiguration *> *>(p->ptr), std::vector<tt__PTZConfiguration *> );
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode:
		if (p->size < 0)
			SOAP_DELETE(soap, static_cast<std::vector<tt__PTZNode *> *>(p->ptr), std::vector<tt__PTZNode *> );
		else
			SOAP_DELETE_ARRAY(soap, static_cast<std::vector<tt__PTZNode *> *>(p->ptr), std::vector<tt__PTZNode *> );
		break;
	default:
		return SOAP_ERR;
	}
	return SOAP_OK;
}

#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_fbase(int t, int b)
{
	do
	{	switch (t)
		{

		case SOAP_TYPE_tt__PTZNode: t = SOAP_TYPE_tt__DeviceEntity; break;
		case SOAP_TYPE_tt__PTZConfiguration: t = SOAP_TYPE_tt__ConfigurationEntity; break;
		default: return 0;
		}
	}
	while (t != b);
	return 1;
}
#ifdef WIN32
#pragma warning(pop)
#endif

#ifndef WITH_NOIDREF
#ifdef WIN32
#pragma warning(push)
// do not warn on switch w/o cases
#pragma warning(disable:4065)
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_finsert(struct soap *soap, int t, int tt, void *p, size_t index, const void *q, void **x)
{
	(void)soap; (void)t; (void)p; (void)index; (void)q; (void)x; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData:
		if (t == SOAP_TYPE_tt__AuxiliaryData)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection:
		if (t == SOAP_TYPE_tt__PTZPresetTourDirection)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__PTZPresetTourDirection>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__PTZPresetTourDirection> *)p)[index] = *(enum tt__PTZPresetTourDirection *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken:
		if (t == SOAP_TYPE_tt__ReferenceToken)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<std::string>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<std::string> *)p)[index] = *(std::string *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot:
		if (t == SOAP_TYPE_tt__PTZPresetTourSpot || soap_fbase(t, SOAP_TYPE_tt__PTZPresetTourSpot))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__PTZPresetTourSpot *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__PTZPresetTourSpot *> *)p)[index] = *(tt__PTZPresetTourSpot **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription:
		if (t == SOAP_TYPE_tt__Space1DDescription || soap_fbase(t, SOAP_TYPE_tt__Space1DDescription))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Space1DDescription *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Space1DDescription *> *)p)[index] = *(tt__Space1DDescription **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription:
		if (t == SOAP_TYPE_tt__Space2DDescription || soap_fbase(t, SOAP_TYPE_tt__Space2DDescription))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__Space2DDescription *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__Space2DDescription *> *)p)[index] = *(tt__Space2DDescription **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__ReverseMode:
		if (t == SOAP_TYPE_tt__ReverseMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__ReverseMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__ReverseMode> *)p)[index] = *(enum tt__ReverseMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__EFlipMode:
		if (t == SOAP_TYPE_tt__EFlipMode)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__EFlipMode>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__EFlipMode> *)p)[index] = *(enum tt__EFlipMode *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation:
		if (t == SOAP_TYPE_tt__PTZPresetTourOperation)
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<enum tt__PTZPresetTourOperation>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<enum tt__PTZPresetTourOperation> *)p)[index] = *(enum tt__PTZPresetTourOperation *)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour:
		if (t == SOAP_TYPE_tt__PresetTour || soap_fbase(t, SOAP_TYPE_tt__PresetTour))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__PresetTour *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__PresetTour *> *)p)[index] = *(tt__PresetTour **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset:
		if (t == SOAP_TYPE_tt__PTZPreset || soap_fbase(t, SOAP_TYPE_tt__PTZPreset))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__PTZPreset *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__PTZPreset *> *)p)[index] = *(tt__PTZPreset **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration:
		if (t == SOAP_TYPE_tt__PTZConfiguration || soap_fbase(t, SOAP_TYPE_tt__PTZConfiguration))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__PTZConfiguration *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__PTZConfiguration *> *)p)[index] = *(tt__PTZConfiguration **)q;
		}
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode:
		if (t == SOAP_TYPE_tt__PTZNode || soap_fbase(t, SOAP_TYPE_tt__PTZNode))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container std::vector<tt__PTZNode *>  insert type=%d in %d location=%p object=%p at index=%lu\n", t, tt, p, q, (unsigned long)index));
			(*(std::vector<tt__PTZNode *> *)p)[index] = *(tt__PTZNode **)q;
		}
		break;
	case SOAP_TYPE__xop__Include:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct _xop__Include type=%d location=%p object=%p\n", t, p, q));
		*(struct _xop__Include*)p = *(struct _xop__Include*)q;
		break;
	case SOAP_TYPE_wsa5__EndpointReferenceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE_wsa5__ReferenceParametersType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE_wsa5__MetadataType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE_wsa5__ProblemActionType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_wsa5__RelatesToType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE_chan__ChannelInstanceType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct chan__ChannelInstanceType type=%d location=%p object=%p\n", t, p, q));
		*(struct chan__ChannelInstanceType*)p = *(struct chan__ChannelInstanceType*)q;
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Header type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Detail type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Code type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Reason type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Fault type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
		break;
#endif
	case SOAP_TYPE_xsd__anyType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__anyType type=%d location=%p object=%p\n", t, p, q));
		*(xsd__anyType*)p = *(xsd__anyType*)q;
		break;
	case SOAP_TYPE_SOAP_ENV__Envelope:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct SOAP_ENV__Envelope type=%d location=%p object=%p\n", t, p, q));
		*(struct SOAP_ENV__Envelope*)p = *(struct SOAP_ENV__Envelope*)q;
		break;
	case SOAP_TYPE_std__string:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__base64Binary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__base64Binary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__base64Binary*)p = *(xsd__base64Binary*)q;
		break;
	case SOAP_TYPE_xsd__hexBinary:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy xsd__hexBinary type=%d location=%p object=%p\n", t, p, q));
		*(xsd__hexBinary*)p = *(xsd__hexBinary*)q;
		break;
	case SOAP_TYPE_tptz__Capabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tptz__Capabilities type=%d location=%p object=%p\n", t, p, q));
		*(tptz__Capabilities*)p = *(tptz__Capabilities*)q;
		break;
	case SOAP_TYPE__tptz__GetServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetServiceCapabilities*)p = *(_tptz__GetServiceCapabilities*)q;
		break;
	case SOAP_TYPE__tptz__GetServiceCapabilitiesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetServiceCapabilitiesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetServiceCapabilitiesResponse*)p = *(_tptz__GetServiceCapabilitiesResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetNodes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetNodes type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetNodes*)p = *(_tptz__GetNodes*)q;
		break;
	case SOAP_TYPE__tptz__GetNodesResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetNodesResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetNodesResponse*)p = *(_tptz__GetNodesResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetNode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetNode type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetNode*)p = *(_tptz__GetNode*)q;
		break;
	case SOAP_TYPE__tptz__GetNodeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetNodeResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetNodeResponse*)p = *(_tptz__GetNodeResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetConfigurations*)p = *(_tptz__GetConfigurations*)q;
		break;
	case SOAP_TYPE__tptz__GetConfigurationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetConfigurationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetConfigurationsResponse*)p = *(_tptz__GetConfigurationsResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetConfiguration*)p = *(_tptz__GetConfiguration*)q;
		break;
	case SOAP_TYPE__tptz__GetConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetConfigurationResponse*)p = *(_tptz__GetConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tptz__SetConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__SetConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__SetConfiguration*)p = *(_tptz__SetConfiguration*)q;
		break;
	case SOAP_TYPE___tptz__SetConfigurationResponse_sequence:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__SetConfigurationResponse_sequence type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__SetConfigurationResponse_sequence*)p = *(struct __tptz__SetConfigurationResponse_sequence*)q;
		break;
	case SOAP_TYPE__tptz__SetConfigurationResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__SetConfigurationResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__SetConfigurationResponse*)p = *(_tptz__SetConfigurationResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetConfigurationOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetConfigurationOptions type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetConfigurationOptions*)p = *(_tptz__GetConfigurationOptions*)q;
		break;
	case SOAP_TYPE__tptz__GetConfigurationOptionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetConfigurationOptionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetConfigurationOptionsResponse*)p = *(_tptz__GetConfigurationOptionsResponse*)q;
		break;
	case SOAP_TYPE__tptz__SendAuxiliaryCommand:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__SendAuxiliaryCommand type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__SendAuxiliaryCommand*)p = *(_tptz__SendAuxiliaryCommand*)q;
		break;
	case SOAP_TYPE__tptz__SendAuxiliaryCommandResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__SendAuxiliaryCommandResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__SendAuxiliaryCommandResponse*)p = *(_tptz__SendAuxiliaryCommandResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetPresets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetPresets type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetPresets*)p = *(_tptz__GetPresets*)q;
		break;
	case SOAP_TYPE__tptz__GetPresetsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetPresetsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetPresetsResponse*)p = *(_tptz__GetPresetsResponse*)q;
		break;
	case SOAP_TYPE__tptz__SetPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__SetPreset type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__SetPreset*)p = *(_tptz__SetPreset*)q;
		break;
	case SOAP_TYPE__tptz__SetPresetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__SetPresetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__SetPresetResponse*)p = *(_tptz__SetPresetResponse*)q;
		break;
	case SOAP_TYPE__tptz__RemovePreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__RemovePreset type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__RemovePreset*)p = *(_tptz__RemovePreset*)q;
		break;
	case SOAP_TYPE__tptz__RemovePresetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__RemovePresetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__RemovePresetResponse*)p = *(_tptz__RemovePresetResponse*)q;
		break;
	case SOAP_TYPE__tptz__GotoPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GotoPreset type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GotoPreset*)p = *(_tptz__GotoPreset*)q;
		break;
	case SOAP_TYPE__tptz__GotoPresetResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GotoPresetResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GotoPresetResponse*)p = *(_tptz__GotoPresetResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetStatus type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetStatus*)p = *(_tptz__GetStatus*)q;
		break;
	case SOAP_TYPE__tptz__GetStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetStatusResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetStatusResponse*)p = *(_tptz__GetStatusResponse*)q;
		break;
	case SOAP_TYPE__tptz__GotoHomePosition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GotoHomePosition type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GotoHomePosition*)p = *(_tptz__GotoHomePosition*)q;
		break;
	case SOAP_TYPE__tptz__GotoHomePositionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GotoHomePositionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GotoHomePositionResponse*)p = *(_tptz__GotoHomePositionResponse*)q;
		break;
	case SOAP_TYPE__tptz__SetHomePosition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__SetHomePosition type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__SetHomePosition*)p = *(_tptz__SetHomePosition*)q;
		break;
	case SOAP_TYPE__tptz__SetHomePositionResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__SetHomePositionResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__SetHomePositionResponse*)p = *(_tptz__SetHomePositionResponse*)q;
		break;
	case SOAP_TYPE__tptz__ContinuousMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__ContinuousMove type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__ContinuousMove*)p = *(_tptz__ContinuousMove*)q;
		break;
	case SOAP_TYPE__tptz__ContinuousMoveResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__ContinuousMoveResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__ContinuousMoveResponse*)p = *(_tptz__ContinuousMoveResponse*)q;
		break;
	case SOAP_TYPE__tptz__RelativeMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__RelativeMove type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__RelativeMove*)p = *(_tptz__RelativeMove*)q;
		break;
	case SOAP_TYPE__tptz__RelativeMoveResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__RelativeMoveResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__RelativeMoveResponse*)p = *(_tptz__RelativeMoveResponse*)q;
		break;
	case SOAP_TYPE__tptz__AbsoluteMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__AbsoluteMove type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__AbsoluteMove*)p = *(_tptz__AbsoluteMove*)q;
		break;
	case SOAP_TYPE__tptz__AbsoluteMoveResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__AbsoluteMoveResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__AbsoluteMoveResponse*)p = *(_tptz__AbsoluteMoveResponse*)q;
		break;
	case SOAP_TYPE__tptz__GeoMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GeoMove type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GeoMove*)p = *(_tptz__GeoMove*)q;
		break;
	case SOAP_TYPE__tptz__GeoMoveResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GeoMoveResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GeoMoveResponse*)p = *(_tptz__GeoMoveResponse*)q;
		break;
	case SOAP_TYPE__tptz__Stop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__Stop type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__Stop*)p = *(_tptz__Stop*)q;
		break;
	case SOAP_TYPE__tptz__StopResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__StopResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__StopResponse*)p = *(_tptz__StopResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetPresetTours:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetPresetTours type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetPresetTours*)p = *(_tptz__GetPresetTours*)q;
		break;
	case SOAP_TYPE__tptz__GetPresetToursResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetPresetToursResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetPresetToursResponse*)p = *(_tptz__GetPresetToursResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetPresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetPresetTour type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetPresetTour*)p = *(_tptz__GetPresetTour*)q;
		break;
	case SOAP_TYPE__tptz__GetPresetTourResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetPresetTourResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetPresetTourResponse*)p = *(_tptz__GetPresetTourResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetPresetTourOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetPresetTourOptions type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetPresetTourOptions*)p = *(_tptz__GetPresetTourOptions*)q;
		break;
	case SOAP_TYPE__tptz__GetPresetTourOptionsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetPresetTourOptionsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetPresetTourOptionsResponse*)p = *(_tptz__GetPresetTourOptionsResponse*)q;
		break;
	case SOAP_TYPE__tptz__CreatePresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__CreatePresetTour type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__CreatePresetTour*)p = *(_tptz__CreatePresetTour*)q;
		break;
	case SOAP_TYPE__tptz__CreatePresetTourResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__CreatePresetTourResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__CreatePresetTourResponse*)p = *(_tptz__CreatePresetTourResponse*)q;
		break;
	case SOAP_TYPE__tptz__ModifyPresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__ModifyPresetTour type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__ModifyPresetTour*)p = *(_tptz__ModifyPresetTour*)q;
		break;
	case SOAP_TYPE__tptz__ModifyPresetTourResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__ModifyPresetTourResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__ModifyPresetTourResponse*)p = *(_tptz__ModifyPresetTourResponse*)q;
		break;
	case SOAP_TYPE__tptz__OperatePresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__OperatePresetTour type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__OperatePresetTour*)p = *(_tptz__OperatePresetTour*)q;
		break;
	case SOAP_TYPE__tptz__OperatePresetTourResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__OperatePresetTourResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__OperatePresetTourResponse*)p = *(_tptz__OperatePresetTourResponse*)q;
		break;
	case SOAP_TYPE__tptz__RemovePresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__RemovePresetTour type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__RemovePresetTour*)p = *(_tptz__RemovePresetTour*)q;
		break;
	case SOAP_TYPE__tptz__RemovePresetTourResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__RemovePresetTourResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__RemovePresetTourResponse*)p = *(_tptz__RemovePresetTourResponse*)q;
		break;
	case SOAP_TYPE__tptz__GetCompatibleConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetCompatibleConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetCompatibleConfigurations*)p = *(_tptz__GetCompatibleConfigurations*)q;
		break;
	case SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__GetCompatibleConfigurationsResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__GetCompatibleConfigurationsResponse*)p = *(_tptz__GetCompatibleConfigurationsResponse*)q;
		break;
	case SOAP_TYPE__tptz__MoveAndStartTracking:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__MoveAndStartTracking type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__MoveAndStartTracking*)p = *(_tptz__MoveAndStartTracking*)q;
		break;
	case SOAP_TYPE__tptz__MoveAndStartTrackingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy _tptz__MoveAndStartTrackingResponse type=%d location=%p object=%p\n", t, p, q));
		*(_tptz__MoveAndStartTrackingResponse*)p = *(_tptz__MoveAndStartTrackingResponse*)q;
		break;
	case SOAP_TYPE_tt__DeviceEntity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DeviceEntity type=%d location=%p object=%p\n", t, p, q));
		*(tt__DeviceEntity*)p = *(tt__DeviceEntity*)q;
		break;
	case SOAP_TYPE_tt__FloatRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__FloatRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__FloatRange*)p = *(tt__FloatRange*)q;
		break;
	case SOAP_TYPE_tt__DurationRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__DurationRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__DurationRange*)p = *(tt__DurationRange*)q;
		break;
	case SOAP_TYPE_tt__ConfigurationEntity:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ConfigurationEntity type=%d location=%p object=%p\n", t, p, q));
		*(tt__ConfigurationEntity*)p = *(tt__ConfigurationEntity*)q;
		break;
	case SOAP_TYPE_tt__PTZNodeExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZNodeExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZNodeExtension*)p = *(tt__PTZNodeExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZNodeExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZNodeExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZNodeExtension2*)p = *(tt__PTZNodeExtension2*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourSupported:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourSupported type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourSupported*)p = *(tt__PTZPresetTourSupported*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourSupportedExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourSupportedExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourSupportedExtension*)p = *(tt__PTZPresetTourSupportedExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZConfigurationExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZConfigurationExtension*)p = *(tt__PTZConfigurationExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZConfigurationExtension2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZConfigurationExtension2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZConfigurationExtension2*)p = *(tt__PTZConfigurationExtension2*)q;
		break;
	case SOAP_TYPE_tt__PTControlDirection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTControlDirection type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTControlDirection*)p = *(tt__PTControlDirection*)q;
		break;
	case SOAP_TYPE_tt__PTControlDirectionExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTControlDirectionExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTControlDirectionExtension*)p = *(tt__PTControlDirectionExtension*)q;
		break;
	case SOAP_TYPE_tt__EFlip:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EFlip type=%d location=%p object=%p\n", t, p, q));
		*(tt__EFlip*)p = *(tt__EFlip*)q;
		break;
	case SOAP_TYPE_tt__Reverse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Reverse type=%d location=%p object=%p\n", t, p, q));
		*(tt__Reverse*)p = *(tt__Reverse*)q;
		break;
	case SOAP_TYPE_tt__PTZConfigurationOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZConfigurationOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZConfigurationOptions*)p = *(tt__PTZConfigurationOptions*)q;
		break;
	case SOAP_TYPE_tt__PTZConfigurationOptions2:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZConfigurationOptions2 type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZConfigurationOptions2*)p = *(tt__PTZConfigurationOptions2*)q;
		break;
	case SOAP_TYPE_tt__PTControlDirectionOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTControlDirectionOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTControlDirectionOptions*)p = *(tt__PTControlDirectionOptions*)q;
		break;
	case SOAP_TYPE_tt__PTControlDirectionOptionsExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTControlDirectionOptionsExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTControlDirectionOptionsExtension*)p = *(tt__PTControlDirectionOptionsExtension*)q;
		break;
	case SOAP_TYPE_tt__EFlipOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EFlipOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__EFlipOptions*)p = *(tt__EFlipOptions*)q;
		break;
	case SOAP_TYPE_tt__EFlipOptionsExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__EFlipOptionsExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__EFlipOptionsExtension*)p = *(tt__EFlipOptionsExtension*)q;
		break;
	case SOAP_TYPE_tt__ReverseOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ReverseOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__ReverseOptions*)p = *(tt__ReverseOptions*)q;
		break;
	case SOAP_TYPE_tt__ReverseOptionsExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ReverseOptionsExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__ReverseOptionsExtension*)p = *(tt__ReverseOptionsExtension*)q;
		break;
	case SOAP_TYPE_tt__PanTiltLimits:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PanTiltLimits type=%d location=%p object=%p\n", t, p, q));
		*(tt__PanTiltLimits*)p = *(tt__PanTiltLimits*)q;
		break;
	case SOAP_TYPE_tt__ZoomLimits:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__ZoomLimits type=%d location=%p object=%p\n", t, p, q));
		*(tt__ZoomLimits*)p = *(tt__ZoomLimits*)q;
		break;
	case SOAP_TYPE_tt__PTZSpaces:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZSpaces type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZSpaces*)p = *(tt__PTZSpaces*)q;
		break;
	case SOAP_TYPE_tt__PTZSpacesExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZSpacesExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZSpacesExtension*)p = *(tt__PTZSpacesExtension*)q;
		break;
	case SOAP_TYPE_tt__Space2DDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Space2DDescription type=%d location=%p object=%p\n", t, p, q));
		*(tt__Space2DDescription*)p = *(tt__Space2DDescription*)q;
		break;
	case SOAP_TYPE_tt__Space1DDescription:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Space1DDescription type=%d location=%p object=%p\n", t, p, q));
		*(tt__Space1DDescription*)p = *(tt__Space1DDescription*)q;
		break;
	case SOAP_TYPE_tt__PTZSpeed:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZSpeed type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZSpeed*)p = *(tt__PTZSpeed*)q;
		break;
	case SOAP_TYPE_tt__PTZPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPreset type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPreset*)p = *(tt__PTZPreset*)q;
		break;
	case SOAP_TYPE_tt__PresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PresetTour type=%d location=%p object=%p\n", t, p, q));
		*(tt__PresetTour*)p = *(tt__PresetTour*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourExtension*)p = *(tt__PTZPresetTourExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpot:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourSpot type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourSpot*)p = *(tt__PTZPresetTourSpot*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpotExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourSpotExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourSpotExtension*)p = *(tt__PTZPresetTourSpotExtension*)q;
		break;
	case SOAP_TYPE__tt__union_PTZPresetTourPresetDetail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy union _tt__union_PTZPresetTourPresetDetail type=%d location=%p object=%p\n", t, p, q));
		*(union _tt__union_PTZPresetTourPresetDetail*)p = *(union _tt__union_PTZPresetTourPresetDetail*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetail:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourPresetDetail type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourPresetDetail*)p = *(tt__PTZPresetTourPresetDetail*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourTypeExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourTypeExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourTypeExtension*)p = *(tt__PTZPresetTourTypeExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourStatus type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourStatus*)p = *(tt__PTZPresetTourStatus*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourStatusExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourStatusExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourStatusExtension*)p = *(tt__PTZPresetTourStatusExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingCondition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourStartingCondition type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourStartingCondition*)p = *(tt__PTZPresetTourStartingCondition*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourStartingConditionExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourStartingConditionExtension*)p = *(tt__PTZPresetTourStartingConditionExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourOptions*)p = *(tt__PTZPresetTourOptions*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourSpotOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourSpotOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourSpotOptions*)p = *(tt__PTZPresetTourSpotOptions*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourPresetDetailOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourPresetDetailOptions*)p = *(tt__PTZPresetTourPresetDetailOptions*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourPresetDetailOptionsExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourPresetDetailOptionsExtension*)p = *(tt__PTZPresetTourPresetDetailOptionsExtension*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourStartingConditionOptions type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourStartingConditionOptions*)p = *(tt__PTZPresetTourStartingConditionOptions*)q;
		break;
	case SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZPresetTourStartingConditionOptionsExtension type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZPresetTourStartingConditionOptionsExtension*)p = *(tt__PTZPresetTourStartingConditionOptionsExtension*)q;
		break;
	case SOAP_TYPE_tt__IntRange:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__IntRange type=%d location=%p object=%p\n", t, p, q));
		*(tt__IntRange*)p = *(tt__IntRange*)q;
		break;
	case SOAP_TYPE_tt__Vector2D:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Vector2D type=%d location=%p object=%p\n", t, p, q));
		*(tt__Vector2D*)p = *(tt__Vector2D*)q;
		break;
	case SOAP_TYPE_tt__Vector1D:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__Vector1D type=%d location=%p object=%p\n", t, p, q));
		*(tt__Vector1D*)p = *(tt__Vector1D*)q;
		break;
	case SOAP_TYPE_tt__PTZVector:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZVector type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZVector*)p = *(tt__PTZVector*)q;
		break;
	case SOAP_TYPE_tt__PTZStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZStatus type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZStatus*)p = *(tt__PTZStatus*)q;
		break;
	case SOAP_TYPE_tt__PTZMoveStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZMoveStatus type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZMoveStatus*)p = *(tt__PTZMoveStatus*)q;
		break;
	case SOAP_TYPE_tt__GeoLocation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__GeoLocation type=%d location=%p object=%p\n", t, p, q));
		*(tt__GeoLocation*)p = *(tt__GeoLocation*)q;
		break;
	case SOAP_TYPE_tt__PTZNode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZNode type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZNode*)p = *(tt__PTZNode*)q;
		break;
	case SOAP_TYPE_tt__PTZConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy tt__PTZConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(tt__PTZConfiguration*)p = *(tt__PTZConfiguration*)q;
		break;
	case SOAP_TYPE___tptz__GetServiceCapabilities:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetServiceCapabilities type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetServiceCapabilities*)p = *(struct __tptz__GetServiceCapabilities*)q;
		break;
	case SOAP_TYPE___tptz__GetConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetConfigurations*)p = *(struct __tptz__GetConfigurations*)q;
		break;
	case SOAP_TYPE___tptz__GetPresets:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetPresets type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetPresets*)p = *(struct __tptz__GetPresets*)q;
		break;
	case SOAP_TYPE___tptz__SetPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__SetPreset type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__SetPreset*)p = *(struct __tptz__SetPreset*)q;
		break;
	case SOAP_TYPE___tptz__RemovePreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__RemovePreset type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__RemovePreset*)p = *(struct __tptz__RemovePreset*)q;
		break;
	case SOAP_TYPE___tptz__GotoPreset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GotoPreset type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GotoPreset*)p = *(struct __tptz__GotoPreset*)q;
		break;
	case SOAP_TYPE___tptz__GetStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetStatus type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetStatus*)p = *(struct __tptz__GetStatus*)q;
		break;
	case SOAP_TYPE___tptz__GetConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetConfiguration*)p = *(struct __tptz__GetConfiguration*)q;
		break;
	case SOAP_TYPE___tptz__GetNodes:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetNodes type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetNodes*)p = *(struct __tptz__GetNodes*)q;
		break;
	case SOAP_TYPE___tptz__GetNode:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetNode type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetNode*)p = *(struct __tptz__GetNode*)q;
		break;
	case SOAP_TYPE___tptz__SetConfiguration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__SetConfiguration type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__SetConfiguration*)p = *(struct __tptz__SetConfiguration*)q;
		break;
	case SOAP_TYPE___tptz__GetConfigurationOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetConfigurationOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetConfigurationOptions*)p = *(struct __tptz__GetConfigurationOptions*)q;
		break;
	case SOAP_TYPE___tptz__GotoHomePosition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GotoHomePosition type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GotoHomePosition*)p = *(struct __tptz__GotoHomePosition*)q;
		break;
	case SOAP_TYPE___tptz__SetHomePosition:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__SetHomePosition type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__SetHomePosition*)p = *(struct __tptz__SetHomePosition*)q;
		break;
	case SOAP_TYPE___tptz__ContinuousMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__ContinuousMove type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__ContinuousMove*)p = *(struct __tptz__ContinuousMove*)q;
		break;
	case SOAP_TYPE___tptz__RelativeMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__RelativeMove type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__RelativeMove*)p = *(struct __tptz__RelativeMove*)q;
		break;
	case SOAP_TYPE___tptz__SendAuxiliaryCommand:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__SendAuxiliaryCommand type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__SendAuxiliaryCommand*)p = *(struct __tptz__SendAuxiliaryCommand*)q;
		break;
	case SOAP_TYPE___tptz__AbsoluteMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__AbsoluteMove type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__AbsoluteMove*)p = *(struct __tptz__AbsoluteMove*)q;
		break;
	case SOAP_TYPE___tptz__GeoMove:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GeoMove type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GeoMove*)p = *(struct __tptz__GeoMove*)q;
		break;
	case SOAP_TYPE___tptz__Stop:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__Stop type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__Stop*)p = *(struct __tptz__Stop*)q;
		break;
	case SOAP_TYPE___tptz__GetPresetTours:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetPresetTours type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetPresetTours*)p = *(struct __tptz__GetPresetTours*)q;
		break;
	case SOAP_TYPE___tptz__GetPresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetPresetTour type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetPresetTour*)p = *(struct __tptz__GetPresetTour*)q;
		break;
	case SOAP_TYPE___tptz__GetPresetTourOptions:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetPresetTourOptions type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetPresetTourOptions*)p = *(struct __tptz__GetPresetTourOptions*)q;
		break;
	case SOAP_TYPE___tptz__CreatePresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__CreatePresetTour type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__CreatePresetTour*)p = *(struct __tptz__CreatePresetTour*)q;
		break;
	case SOAP_TYPE___tptz__ModifyPresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__ModifyPresetTour type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__ModifyPresetTour*)p = *(struct __tptz__ModifyPresetTour*)q;
		break;
	case SOAP_TYPE___tptz__OperatePresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__OperatePresetTour type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__OperatePresetTour*)p = *(struct __tptz__OperatePresetTour*)q;
		break;
	case SOAP_TYPE___tptz__RemovePresetTour:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__RemovePresetTour type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__RemovePresetTour*)p = *(struct __tptz__RemovePresetTour*)q;
		break;
	case SOAP_TYPE___tptz__GetCompatibleConfigurations:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__GetCompatibleConfigurations type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__GetCompatibleConfigurations*)p = *(struct __tptz__GetCompatibleConfigurations*)q;
		break;
	case SOAP_TYPE___tptz__MoveAndStartTracking:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct __tptz__MoveAndStartTracking type=%d location=%p object=%p\n", t, p, q));
		*(struct __tptz__MoveAndStartTracking*)p = *(struct __tptz__MoveAndStartTracking*)q;
		break;
	case SOAP_TYPE__wsa5__EndpointReference:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ReferenceParameters:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ReferenceParametersType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
		break;
	case SOAP_TYPE__wsa5__Metadata:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__MetadataType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
		break;
	case SOAP_TYPE__wsa5__RelatesTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__RelatesToType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
		break;
	case SOAP_TYPE__wsa5__ReplyTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__From:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__FaultTo:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__EndpointReferenceType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
		break;
	case SOAP_TYPE__wsa5__ProblemAction:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy struct wsa5__ProblemActionType type=%d location=%p object=%p\n", t, p, q));
		*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
		break;
	case SOAP_TYPE_xsd__QName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__NCName:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anySimpleType:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__anyURI:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__duration:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__integer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__nonNegativeInteger:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_xsd__token:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE__xml__lang:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__IntAttrList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__StringList:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__Name:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__AuxiliaryData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	case SOAP_TYPE_tt__ReferenceToken:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copy std::string type=%d location=%p object=%p\n", t, p, q));
		*(std::string*)p = *(std::string*)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", t, tt));
	}
}
#ifdef WIN32
#pragma warning(pop)
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *a = static_cast<char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char)));
	for (char *p = a; p && n--; ++p)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *a = static_cast<int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(int)));
	for (int *p = a; p && n--; ++p)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_float(struct soap *soap, const char *tag, int id, const float *a, const char *type)
{
	return soap_outfloat(soap, tag, id, a, type, SOAP_TYPE_float);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_in_float(struct soap *soap, const char *tag, float *a, const char *type)
{
	a = soap_infloat(soap, tag, a, type, SOAP_TYPE_float);
	return a;
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_new_float(struct soap *soap, int n)
{
	float *a = static_cast<float *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(float)));
	for (float *p = a; p && n--; ++p)
		soap_default_float(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_float(struct soap *soap, const float *a, const char *tag, const char *type)
{
	if (soap_out_float(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float * SOAP_FMAC4 soap_get_float(struct soap *soap, float *p, const char *tag, const char *type)
{
	if ((p = soap_in_float(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	a = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return a;
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_new_double(struct soap *soap, int n)
{
	double *a = static_cast<double *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(double)));
	for (double *p = a; p && n--; ++p)
		soap_default_double(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	if (soap_out_double(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedByte(struct soap *soap, const char *tag, int id, const unsigned char *a, const char *type)
{
	return soap_outunsignedByte(soap, tag, id, a, type, SOAP_TYPE_unsignedByte);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_in_unsignedByte(struct soap *soap, const char *tag, unsigned char *a, const char *type)
{
	a = soap_inunsignedByte(soap, tag, a, type, SOAP_TYPE_unsignedByte);
	return a;
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_new_unsignedByte(struct soap *soap, int n)
{
	unsigned char *a = static_cast<unsigned char *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned char)));
	for (unsigned char *p = a; p && n--; ++p)
		soap_default_unsignedByte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedByte(struct soap *soap, const unsigned char *a, const char *tag, const char *type)
{
	if (soap_out_unsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char * SOAP_FMAC4 soap_get_unsignedByte(struct soap *soap, unsigned char *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_unsignedInt(struct soap *soap, const char *tag, int id, const unsigned int *a, const char *type)
{
	return soap_outunsignedInt(soap, tag, id, a, type, SOAP_TYPE_unsignedInt);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_in_unsignedInt(struct soap *soap, const char *tag, unsigned int *a, const char *type)
{
	a = soap_inunsignedInt(soap, tag, a, type, SOAP_TYPE_unsignedInt);
	return a;
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_new_unsignedInt(struct soap *soap, int n)
{
	unsigned int *a = static_cast<unsigned int *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(unsigned int)));
	for (unsigned int *p = a; p && n--; ++p)
		soap_default_unsignedInt(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_unsignedInt(struct soap *soap, const unsigned int *a, const char *tag, const char *type)
{
	if (soap_out_unsignedInt(soap, tag ? tag : "unsignedInt", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int * SOAP_FMAC4 soap_get_unsignedInt(struct soap *soap, unsigned int *p, const char *tag, const char *type)
{
	if ((p = soap_in_unsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RetryAfter(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RetryAfter(soap, tag ? tag : "wsa5:RetryAfter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ULONG64(struct soap *soap, const char *tag, int id, const ULONG64 *a, const char *type)
{
	return soap_outULONG64(soap, tag, id, a, type, SOAP_TYPE_ULONG64);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_in_ULONG64(struct soap *soap, const char *tag, ULONG64 *a, const char *type)
{
	a = soap_inULONG64(soap, tag, a, type, SOAP_TYPE_ULONG64);
	return a;
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_new_ULONG64(struct soap *soap, int n)
{
	ULONG64 *a = static_cast<ULONG64 *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(ULONG64)));
	for (ULONG64 *p = a; p && n--; ++p)
		soap_default_ULONG64(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ULONG64(struct soap *soap, const ULONG64 *a, const char *tag, const char *type)
{
	if (soap_out_ULONG64(soap, tag ? tag : "unsignedLong", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 * SOAP_FMAC4 soap_get_ULONG64(struct soap *soap, ULONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_ULONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_dateTime(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_dateTime);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_dateTime(struct soap *soap, const char *tag, time_t *a, const char *type)
{
	a = soap_indateTime(soap, tag, a, type, SOAP_TYPE_dateTime);
	return a;
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_new_dateTime(struct soap *soap, int n)
{
	time_t *a = static_cast<time_t *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(time_t)));
	for (time_t *p = a; p && n--; ++p)
		soap_default_dateTime(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_dateTime(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	if (soap_out_dateTime(soap, tag ? tag : "dateTime", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_dateTime(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_dateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (LONG64)false, "false" },
	{ (LONG64)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
	return soap_code_str(soap_codes_bool, n != 0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2bool(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_new_bool(struct soap *soap, int n)
{
	bool *a = static_cast<bool *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(bool)));
	for (bool *p = a; p && n--; ++p)
		soap_default_bool(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	if (soap_out_bool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__MoveStatus[] =
{	{ (LONG64)tt__MoveStatus__IDLE, "IDLE" },
	{ (LONG64)tt__MoveStatus__MOVING, "MOVING" },
	{ (LONG64)tt__MoveStatus__UNKNOWN, "UNKNOWN" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__MoveStatus2s(struct soap *soap, enum tt__MoveStatus n)
{
	const char *s = soap_code_str(soap_codes_tt__MoveStatus, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__MoveStatus(struct soap *soap, const char *tag, int id, const enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__MoveStatus), type) || soap_send(soap, soap_tt__MoveStatus2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__MoveStatus(struct soap *soap, const char *s, enum tt__MoveStatus *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__MoveStatus, s);
	if (map)
		*a = (enum tt__MoveStatus)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__MoveStatus)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_in_tt__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__MoveStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__MoveStatus(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__MoveStatus, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_new_tt__MoveStatus(struct soap *soap, int n)
{
	enum tt__MoveStatus *a = static_cast<enum tt__MoveStatus *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__MoveStatus)));
	for (enum tt__MoveStatus *p = a; p && n--; ++p)
		soap_default_tt__MoveStatus(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__MoveStatus(struct soap *soap, const enum tt__MoveStatus *a, const char *tag, const char *type)
{
	if (soap_out_tt__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus * SOAP_FMAC4 soap_get_tt__MoveStatus(struct soap *soap, enum tt__MoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PTZPresetTourOperation[] =
{	{ (LONG64)tt__PTZPresetTourOperation__Start, "Start" },
	{ (LONG64)tt__PTZPresetTourOperation__Stop, "Stop" },
	{ (LONG64)tt__PTZPresetTourOperation__Pause, "Pause" },
	{ (LONG64)tt__PTZPresetTourOperation__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PTZPresetTourOperation2s(struct soap *soap, enum tt__PTZPresetTourOperation n)
{
	const char *s = soap_code_str(soap_codes_tt__PTZPresetTourOperation, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourOperation(struct soap *soap, const char *tag, int id, const enum tt__PTZPresetTourOperation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourOperation), type) || soap_send(soap, soap_tt__PTZPresetTourOperation2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PTZPresetTourOperation(struct soap *soap, const char *s, enum tt__PTZPresetTourOperation *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PTZPresetTourOperation, s);
	if (map)
		*a = (enum tt__PTZPresetTourOperation)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PTZPresetTourOperation)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation * SOAP_FMAC4 soap_in_tt__PTZPresetTourOperation(struct soap *soap, const char *tag, enum tt__PTZPresetTourOperation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PTZPresetTourOperation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PTZPresetTourOperation(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourOperation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourOperation, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation * SOAP_FMAC4 soap_new_tt__PTZPresetTourOperation(struct soap *soap, int n)
{
	enum tt__PTZPresetTourOperation *a = static_cast<enum tt__PTZPresetTourOperation *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PTZPresetTourOperation)));
	for (enum tt__PTZPresetTourOperation *p = a; p && n--; ++p)
		soap_default_tt__PTZPresetTourOperation(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourOperation(struct soap *soap, const enum tt__PTZPresetTourOperation *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourOperation(soap, tag ? tag : "tt:PTZPresetTourOperation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation * SOAP_FMAC4 soap_get_tt__PTZPresetTourOperation(struct soap *soap, enum tt__PTZPresetTourOperation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PTZPresetTourDirection[] =
{	{ (LONG64)tt__PTZPresetTourDirection__Forward, "Forward" },
	{ (LONG64)tt__PTZPresetTourDirection__Backward, "Backward" },
	{ (LONG64)tt__PTZPresetTourDirection__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PTZPresetTourDirection2s(struct soap *soap, enum tt__PTZPresetTourDirection n)
{
	const char *s = soap_code_str(soap_codes_tt__PTZPresetTourDirection, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourDirection(struct soap *soap, const char *tag, int id, const enum tt__PTZPresetTourDirection *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourDirection), type) || soap_send(soap, soap_tt__PTZPresetTourDirection2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PTZPresetTourDirection(struct soap *soap, const char *s, enum tt__PTZPresetTourDirection *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PTZPresetTourDirection, s);
	if (map)
		*a = (enum tt__PTZPresetTourDirection)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PTZPresetTourDirection)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection * SOAP_FMAC4 soap_in_tt__PTZPresetTourDirection(struct soap *soap, const char *tag, enum tt__PTZPresetTourDirection *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PTZPresetTourDirection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PTZPresetTourDirection(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourDirection, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection * SOAP_FMAC4 soap_new_tt__PTZPresetTourDirection(struct soap *soap, int n)
{
	enum tt__PTZPresetTourDirection *a = static_cast<enum tt__PTZPresetTourDirection *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PTZPresetTourDirection)));
	for (enum tt__PTZPresetTourDirection *p = a; p && n--; ++p)
		soap_default_tt__PTZPresetTourDirection(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourDirection(struct soap *soap, const enum tt__PTZPresetTourDirection *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourDirection(soap, tag ? tag : "tt:PTZPresetTourDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection * SOAP_FMAC4 soap_get_tt__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__PTZPresetTourState[] =
{	{ (LONG64)tt__PTZPresetTourState__Idle, "Idle" },
	{ (LONG64)tt__PTZPresetTourState__Touring, "Touring" },
	{ (LONG64)tt__PTZPresetTourState__Paused, "Paused" },
	{ (LONG64)tt__PTZPresetTourState__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__PTZPresetTourState2s(struct soap *soap, enum tt__PTZPresetTourState n)
{
	const char *s = soap_code_str(soap_codes_tt__PTZPresetTourState, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourState(struct soap *soap, const char *tag, int id, const enum tt__PTZPresetTourState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourState), type) || soap_send(soap, soap_tt__PTZPresetTourState2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__PTZPresetTourState(struct soap *soap, const char *s, enum tt__PTZPresetTourState *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__PTZPresetTourState, s);
	if (map)
		*a = (enum tt__PTZPresetTourState)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__PTZPresetTourState)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__PTZPresetTourState * SOAP_FMAC4 soap_in_tt__PTZPresetTourState(struct soap *soap, const char *tag, enum tt__PTZPresetTourState *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__PTZPresetTourState*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourState, sizeof(enum tt__PTZPresetTourState), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__PTZPresetTourState(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourState, SOAP_TYPE_tt__PTZPresetTourState, sizeof(enum tt__PTZPresetTourState), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__PTZPresetTourState * SOAP_FMAC4 soap_new_tt__PTZPresetTourState(struct soap *soap, int n)
{
	enum tt__PTZPresetTourState *a = static_cast<enum tt__PTZPresetTourState *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__PTZPresetTourState)));
	for (enum tt__PTZPresetTourState *p = a; p && n--; ++p)
		soap_default_tt__PTZPresetTourState(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZPresetTourState(struct soap *soap, const enum tt__PTZPresetTourState *a, const char *tag, const char *type)
{
	if (soap_out_tt__PTZPresetTourState(soap, tag ? tag : "tt:PTZPresetTourState", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourState * SOAP_FMAC4 soap_get_tt__PTZPresetTourState(struct soap *soap, enum tt__PTZPresetTourState *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__ReverseMode[] =
{	{ (LONG64)tt__ReverseMode__OFF, "OFF" },
	{ (LONG64)tt__ReverseMode__ON, "ON" },
	{ (LONG64)tt__ReverseMode__AUTO, "AUTO" },
	{ (LONG64)tt__ReverseMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__ReverseMode2s(struct soap *soap, enum tt__ReverseMode n)
{
	const char *s = soap_code_str(soap_codes_tt__ReverseMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseMode(struct soap *soap, const char *tag, int id, const enum tt__ReverseMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseMode), type) || soap_send(soap, soap_tt__ReverseMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__ReverseMode(struct soap *soap, const char *s, enum tt__ReverseMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__ReverseMode, s);
	if (map)
		*a = (enum tt__ReverseMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 3)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__ReverseMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_in_tt__ReverseMode(struct soap *soap, const char *tag, enum tt__ReverseMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__ReverseMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__ReverseMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__ReverseMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseMode, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_new_tt__ReverseMode(struct soap *soap, int n)
{
	enum tt__ReverseMode *a = static_cast<enum tt__ReverseMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__ReverseMode)));
	for (enum tt__ReverseMode *p = a; p && n--; ++p)
		soap_default_tt__ReverseMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReverseMode(struct soap *soap, const enum tt__ReverseMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReverseMode(soap, tag ? tag : "tt:ReverseMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ReverseMode * SOAP_FMAC4 soap_get_tt__ReverseMode(struct soap *soap, enum tt__ReverseMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_tt__EFlipMode[] =
{	{ (LONG64)tt__EFlipMode__OFF, "OFF" },
	{ (LONG64)tt__EFlipMode__ON, "ON" },
	{ (LONG64)tt__EFlipMode__Extended, "Extended" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_tt__EFlipMode2s(struct soap *soap, enum tt__EFlipMode n)
{
	const char *s = soap_code_str(soap_codes_tt__EFlipMode, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipMode(struct soap *soap, const char *tag, int id, const enum tt__EFlipMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipMode), type) || soap_send(soap, soap_tt__EFlipMode2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2tt__EFlipMode(struct soap *soap, const char *s, enum tt__EFlipMode *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_tt__EFlipMode, s);
	if (map)
		*a = (enum tt__EFlipMode)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 2)
			return soap->error = SOAP_TYPE;
		*a = (enum tt__EFlipMode)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_in_tt__EFlipMode(struct soap *soap, const char *tag, enum tt__EFlipMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum tt__EFlipMode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2tt__EFlipMode(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum tt__EFlipMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipMode, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_new_tt__EFlipMode(struct soap *soap, int n)
{
	enum tt__EFlipMode *a = static_cast<enum tt__EFlipMode *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum tt__EFlipMode)));
	for (enum tt__EFlipMode *p = a; p && n--; ++p)
		soap_default_tt__EFlipMode(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EFlipMode(struct soap *soap, const enum tt__EFlipMode *a, const char *tag, const char *type)
{
	if (soap_out_tt__EFlipMode(soap, tag ? tag : "tt:EFlipMode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__EFlipMode * SOAP_FMAC4 soap_get_tt__EFlipMode(struct soap *soap, enum tt__EFlipMode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes__wsa5__IsReferenceParameter[] =
{	{ (LONG64)_wsa5__IsReferenceParameter__false, "false" },
	{ (LONG64)_wsa5__IsReferenceParameter__true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__wsa5__IsReferenceParameter2s(struct soap *soap, enum _wsa5__IsReferenceParameter n)
{
	const char *s = soap_code_str(soap_codes__wsa5__IsReferenceParameter, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, int id, const enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsa5__IsReferenceParameter), type) || soap_send(soap, soap__wsa5__IsReferenceParameter2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_wsa5__IsReferenceParameter(struct soap *soap, const char *s, enum _wsa5__IsReferenceParameter *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes__wsa5__IsReferenceParameter, s);
	if (map)
		*a = (enum _wsa5__IsReferenceParameter)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (enum _wsa5__IsReferenceParameter)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_in__wsa5__IsReferenceParameter(struct soap *soap, const char *tag, enum _wsa5__IsReferenceParameter *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _wsa5__IsReferenceParameter*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2_wsa5__IsReferenceParameter(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum _wsa5__IsReferenceParameter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsa5__IsReferenceParameter, SOAP_TYPE__wsa5__IsReferenceParameter, sizeof(enum _wsa5__IsReferenceParameter), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_new__wsa5__IsReferenceParameter(struct soap *soap, int n)
{
	enum _wsa5__IsReferenceParameter *a = static_cast<enum _wsa5__IsReferenceParameter *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum _wsa5__IsReferenceParameter)));
	for (enum _wsa5__IsReferenceParameter *p = a; p && n--; ++p)
		soap_default__wsa5__IsReferenceParameter(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__IsReferenceParameter(struct soap *soap, const enum _wsa5__IsReferenceParameter *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__IsReferenceParameter(soap, tag ? tag : "wsa5:IsReferenceParameter", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum _wsa5__IsReferenceParameter * SOAP_FMAC4 soap_get__wsa5__IsReferenceParameter(struct soap *soap, enum _wsa5__IsReferenceParameter *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__IsReferenceParameter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__FaultCodesType[] =
{	{ (LONG64)wsa5__InvalidAddressingHeader, "wsa5:InvalidAddressingHeader" },
	{ (LONG64)wsa5__InvalidAddress, "wsa5:InvalidAddress" },
	{ (LONG64)wsa5__InvalidEPR, "wsa5:InvalidEPR" },
	{ (LONG64)wsa5__InvalidCardinality, "wsa5:InvalidCardinality" },
	{ (LONG64)wsa5__MissingAddressInEPR, "wsa5:MissingAddressInEPR" },
	{ (LONG64)wsa5__DuplicateMessageID, "wsa5:DuplicateMessageID" },
	{ (LONG64)wsa5__ActionMismatch, "wsa5:ActionMismatch" },
	{ (LONG64)wsa5__MessageAddressingHeaderRequired, "wsa5:MessageAddressingHeaderRequired" },
	{ (LONG64)wsa5__DestinationUnreachable, "wsa5:DestinationUnreachable" },
	{ (LONG64)wsa5__ActionNotSupported, "wsa5:ActionNotSupported" },
	{ (LONG64)wsa5__EndpointUnavailable, "wsa5:EndpointUnavailable" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__FaultCodesType2s(struct soap *soap, enum wsa5__FaultCodesType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__FaultCodesType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesType(struct soap *soap, const char *tag, int id, const enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__FaultCodesType), type) || soap_send(soap, soap_wsa5__FaultCodesType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__FaultCodesType(struct soap *soap, const char *s, enum wsa5__FaultCodesType *a)
{
	const struct soap_code_map *map;
	char *t;
	if (!s)
		return soap->error;
	soap_s2QName(soap, s, &t, 0, -1, NULL);
	map = soap_code(soap_codes_wsa5__FaultCodesType, t);
	if (map)
		*a = (enum wsa5__FaultCodesType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 10)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__FaultCodesType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_in_wsa5__FaultCodesType(struct soap *soap, const char *tag, enum wsa5__FaultCodesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__FaultCodesType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__FaultCodesType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__FaultCodesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__FaultCodesType, SOAP_TYPE_wsa5__FaultCodesType, sizeof(enum wsa5__FaultCodesType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_new_wsa5__FaultCodesType(struct soap *soap, int n)
{
	enum wsa5__FaultCodesType *a = static_cast<enum wsa5__FaultCodesType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__FaultCodesType)));
	for (enum wsa5__FaultCodesType *p = a; p && n--; ++p)
		soap_default_wsa5__FaultCodesType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesType(struct soap *soap, const enum wsa5__FaultCodesType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesType(soap, tag ? tag : "wsa5:FaultCodesType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__FaultCodesType * SOAP_FMAC4 soap_get_wsa5__FaultCodesType(struct soap *soap, enum wsa5__FaultCodesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

static const struct soap_code_map soap_codes_wsa5__RelationshipType[] =
{	{ (LONG64)http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply, "http://www.w3.org/2005/08/addressing/reply" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_wsa5__RelationshipType2s(struct soap *soap, enum wsa5__RelationshipType n)
{
	const char *s = soap_code_str(soap_codes_wsa5__RelationshipType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipType(struct soap *soap, const char *tag, int id, const enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__RelationshipType), type) || soap_send(soap, soap_wsa5__RelationshipType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2wsa5__RelationshipType(struct soap *soap, const char *s, enum wsa5__RelationshipType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_wsa5__RelationshipType, s);
	if (map)
		*a = (enum wsa5__RelationshipType)map->code;
	else if (!*s)
		return soap->error = SOAP_EMPTY;
	else
	{	int n;
		if (soap_s2int(soap, s, &n) || n < 0 || n > 0)
			return soap->error = SOAP_TYPE;
		*a = (enum wsa5__RelationshipType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_in_wsa5__RelationshipType(struct soap *soap, const char *tag, enum wsa5__RelationshipType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum wsa5__RelationshipType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (*soap->href != '#')
	{	int err = soap_s2wsa5__RelationshipType(soap, soap_value(soap), a);
		if ((soap->body && soap_element_end_in(soap, tag)) || err)
			return NULL;
	}
	else
	{	a = (enum wsa5__RelationshipType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__RelationshipType, SOAP_TYPE_wsa5__RelationshipType, sizeof(enum wsa5__RelationshipType), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_new_wsa5__RelationshipType(struct soap *soap, int n)
{
	enum wsa5__RelationshipType *a = static_cast<enum wsa5__RelationshipType *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(enum wsa5__RelationshipType)));
	for (enum wsa5__RelationshipType *p = a; p && n--; ++p)
		soap_default_wsa5__RelationshipType(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipType(struct soap *soap, const enum wsa5__RelationshipType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipType(soap, tag ? tag : "wsa5:RelationshipType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum wsa5__RelationshipType * SOAP_FMAC4 soap_get_wsa5__RelationshipType(struct soap *soap, enum wsa5__RelationshipType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__ReferenceToken), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AuxiliaryData(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__AuxiliaryData), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 128, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_tt__AuxiliaryData, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__AuxiliaryData(soap, tag ? tag : "tt:AuxiliaryData", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__Name), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, 64, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__Name, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__Name, SOAP_TYPE_tt__Name, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__StringList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__StringList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__StringList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__StringList, SOAP_TYPE_tt__StringList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__StringList(soap, tag ? tag : "tt:StringList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__StringList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntAttrList(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntAttrList(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_tt__IntAttrList), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_tt__IntAttrList(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IntAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_tt__IntAttrList, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_tt__IntAttrList, SOAP_TYPE_tt__IntAttrList, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntAttrList(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_tt__IntAttrList(soap, tag ? tag : "tt:IntAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_tt__IntAttrList(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__GeoLocation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__GeoLocation::lon = NULL;
	this->tt__GeoLocation::lat = NULL;
	this->tt__GeoLocation::elevation = NULL;
}

void tt__GeoLocation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__GeoLocation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__GeoLocation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__GeoLocation(struct soap *soap, const char *tag, int id, const tt__GeoLocation *a, const char *type)
{
	if (((tt__GeoLocation*)a)->lon)
	{	soap_set_attr(soap, "lon", soap_double2s(soap, *((tt__GeoLocation*)a)->lon), 1);
	}
	if (((tt__GeoLocation*)a)->lat)
	{	soap_set_attr(soap, "lat", soap_double2s(soap, *((tt__GeoLocation*)a)->lat), 1);
	}
	if (((tt__GeoLocation*)a)->elevation)
	{	soap_set_attr(soap, "elevation", soap_float2s(soap, *((tt__GeoLocation*)a)->elevation), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__GeoLocation), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__GeoLocation::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__GeoLocation(soap, tag, this, type);
}

SOAP_FMAC3 tt__GeoLocation * SOAP_FMAC4 soap_in_tt__GeoLocation(struct soap *soap, const char *tag, tt__GeoLocation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__GeoLocation*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__GeoLocation)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__GeoLocation *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "lon", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->lon = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((tt__GeoLocation*)a)->lon))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "lat", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->lat = (double *)soap_malloc(soap, sizeof(double))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2double(soap, t, ((tt__GeoLocation*)a)->lat))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "elevation", 5, 0);
		if (t)
		{
			if (!(((tt__GeoLocation*)a)->elevation = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, ((tt__GeoLocation*)a)->elevation))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__GeoLocation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__GeoLocation, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__GeoLocation * SOAP_FMAC2 soap_instantiate_tt__GeoLocation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__GeoLocation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__GeoLocation *p;
	size_t k = sizeof(tt__GeoLocation);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__GeoLocation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__GeoLocation);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__GeoLocation, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__GeoLocation location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__GeoLocation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__GeoLocation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__GeoLocation(soap, this, tag, type);
}

SOAP_FMAC3 tt__GeoLocation * SOAP_FMAC4 soap_get_tt__GeoLocation(struct soap *soap, tt__GeoLocation *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZMoveStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZMoveStatus::PanTilt = NULL;
	this->tt__PTZMoveStatus::Zoom = NULL;
}

void tt__PTZMoveStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__MoveStatus(soap, &this->tt__PTZMoveStatus::PanTilt);
	soap_serialize_PointerTott__MoveStatus(soap, &this->tt__PTZMoveStatus::Zoom);
#endif
}

int tt__PTZMoveStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZMoveStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZMoveStatus(struct soap *soap, const char *tag, int id, const tt__PTZMoveStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZMoveStatus), type))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:PanTilt", -1, &a->tt__PTZMoveStatus::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__MoveStatus(soap, "tt:Zoom", -1, &a->tt__PTZMoveStatus::Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZMoveStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZMoveStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZMoveStatus * SOAP_FMAC4 soap_in_tt__PTZMoveStatus(struct soap *soap, const char *tag, tt__PTZMoveStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZMoveStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(tt__PTZMoveStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZMoveStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZMoveStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveStatus(soap, "tt:PanTilt", &a->tt__PTZMoveStatus::PanTilt, "tt:MoveStatus"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__MoveStatus(soap, "tt:Zoom", &a->tt__PTZMoveStatus::Zoom, "tt:MoveStatus"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZMoveStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZMoveStatus, SOAP_TYPE_tt__PTZMoveStatus, sizeof(tt__PTZMoveStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZMoveStatus * SOAP_FMAC2 soap_instantiate_tt__PTZMoveStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZMoveStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZMoveStatus *p;
	size_t k = sizeof(tt__PTZMoveStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZMoveStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZMoveStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZMoveStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZMoveStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZMoveStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZMoveStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZMoveStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZMoveStatus * SOAP_FMAC4 soap_get_tt__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZStatus::Position = NULL;
	this->tt__PTZStatus::MoveStatus = NULL;
	this->tt__PTZStatus::Error = NULL;
	soap_default_dateTime(soap, &this->tt__PTZStatus::UtcTime);
}

void tt__PTZStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__PTZStatus::Position);
	soap_serialize_PointerTott__PTZMoveStatus(soap, &this->tt__PTZStatus::MoveStatus);
	soap_serialize_PointerTostd__string(soap, &this->tt__PTZStatus::Error);
#endif
}

int tt__PTZStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZStatus(struct soap *soap, const char *tag, int id, const tt__PTZStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZStatus), type))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:Position", -1, &a->tt__PTZStatus::Position, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", -1, &a->tt__PTZStatus::MoveStatus, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tt:Error", -1, &a->tt__PTZStatus::Error, ""))
		return soap->error;
	if (soap_out_dateTime(soap, "tt:UtcTime", -1, &a->tt__PTZStatus::UtcTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZStatus * SOAP_FMAC4 soap_in_tt__PTZStatus(struct soap *soap, const char *tag, tt__PTZStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZStatus, sizeof(tt__PTZStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_MoveStatus1 = 1;
	size_t soap_flag_Error1 = 1;
	size_t soap_flag_UtcTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:Position", &a->tt__PTZStatus::Position, "tt:PTZVector"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_MoveStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZMoveStatus(soap, "tt:MoveStatus", &a->tt__PTZStatus::MoveStatus, "tt:PTZMoveStatus"))
				{	soap_flag_MoveStatus1--;
					continue;
				}
			}
			if (soap_flag_Error1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tt:Error", &a->tt__PTZStatus::Error, "xsd:string"))
				{	soap_flag_Error1--;
					continue;
				}
			}
			if (soap_flag_UtcTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_dateTime(soap, "tt:UtcTime", &a->tt__PTZStatus::UtcTime, "xsd:dateTime"))
				{	soap_flag_UtcTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UtcTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZStatus, SOAP_TYPE_tt__PTZStatus, sizeof(tt__PTZStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZStatus * SOAP_FMAC2 soap_instantiate_tt__PTZStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZStatus *p;
	size_t k = sizeof(tt__PTZStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZStatus(soap, tag ? tag : "tt:PTZStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZStatus * SOAP_FMAC4 soap_get_tt__PTZStatus(struct soap *soap, tt__PTZStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZVector::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZVector::PanTilt = NULL;
	this->tt__PTZVector::Zoom = NULL;
}

void tt__PTZVector::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &this->tt__PTZVector::PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &this->tt__PTZVector::Zoom);
#endif
}

int tt__PTZVector::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZVector(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZVector(struct soap *soap, const char *tag, int id, const tt__PTZVector *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZVector), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->tt__PTZVector::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->tt__PTZVector::Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZVector::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZVector(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZVector * SOAP_FMAC4 soap_in_tt__PTZVector(struct soap *soap, const char *tag, tt__PTZVector *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZVector*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZVector, sizeof(tt__PTZVector), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZVector)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZVector *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->tt__PTZVector::PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->tt__PTZVector::Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZVector *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZVector, SOAP_TYPE_tt__PTZVector, sizeof(tt__PTZVector), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZVector * SOAP_FMAC2 soap_instantiate_tt__PTZVector(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZVector(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZVector *p;
	size_t k = sizeof(tt__PTZVector);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZVector, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZVector);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZVector, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZVector location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZVector::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZVector(soap, tag ? tag : "tt:PTZVector", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZVector::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZVector(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZVector * SOAP_FMAC4 soap_get_tt__PTZVector(struct soap *soap, tt__PTZVector *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector1D::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__Vector1D::x);
	this->tt__Vector1D::space = NULL;
}

void tt__Vector1D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Vector1D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector1D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector1D(struct soap *soap, const char *tag, int id, const tt__Vector1D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector1D*)a)->x), 1);
	if (((tt__Vector1D*)a)->space)
	{	soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, *((tt__Vector1D*)a)->space), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector1D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Vector1D::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector1D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_in_tt__Vector1D(struct soap *soap, const char *tag, tt__Vector1D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Vector1D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector1D)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Vector1D *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &((tt__Vector1D*)a)->x))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "space", 4, 0);
		if (t)
		{
			if (!(((tt__Vector1D*)a)->space = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__Vector1D*)a)->space))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Vector1D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector1D, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Vector1D * SOAP_FMAC2 soap_instantiate_tt__Vector1D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector1D(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector1D *p;
	size_t k = sizeof(tt__Vector1D);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector1D, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector1D);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector1D, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector1D location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector1D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector1D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector1D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector1D * SOAP_FMAC4 soap_get_tt__Vector1D(struct soap *soap, tt__Vector1D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Vector2D::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__Vector2D::x);
	soap_default_float(soap, &this->tt__Vector2D::y);
	this->tt__Vector2D::space = NULL;
}

void tt__Vector2D::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Vector2D::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Vector2D(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Vector2D(struct soap *soap, const char *tag, int id, const tt__Vector2D *a, const char *type)
{
	soap_set_attr(soap, "x", soap_float2s(soap, ((tt__Vector2D*)a)->x), 1);
	soap_set_attr(soap, "y", soap_float2s(soap, ((tt__Vector2D*)a)->y), 1);
	if (((tt__Vector2D*)a)->space)
	{	soap_set_attr(soap, "space", soap_xsd__anyURI2s(soap, *((tt__Vector2D*)a)->space), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Vector2D), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Vector2D::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Vector2D(soap, tag, this, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_in_tt__Vector2D(struct soap *soap, const char *tag, tt__Vector2D *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Vector2D*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Vector2D)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Vector2D *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2float(soap, soap_attr_value(soap, "x", 5, 1), &((tt__Vector2D*)a)->x))
		return NULL;
	if (soap_s2float(soap, soap_attr_value(soap, "y", 5, 1), &((tt__Vector2D*)a)->y))
		return NULL;
	{
		const char *t = soap_attr_value(soap, "space", 4, 0);
		if (t)
		{
			if (!(((tt__Vector2D*)a)->space = soap_new_xsd__anyURI(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__anyURI(soap, t, ((tt__Vector2D*)a)->space))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Vector2D *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Vector2D, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Vector2D * SOAP_FMAC2 soap_instantiate_tt__Vector2D(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Vector2D(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Vector2D *p;
	size_t k = sizeof(tt__Vector2D);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Vector2D, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Vector2D);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Vector2D, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Vector2D location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Vector2D::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Vector2D::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Vector2D(soap, this, tag, type);
}

SOAP_FMAC3 tt__Vector2D * SOAP_FMAC4 soap_get_tt__Vector2D(struct soap *soap, tt__Vector2D *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__IntRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__IntRange::Min);
	soap_default_int(soap, &this->tt__IntRange::Max);
}

void tt__IntRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__IntRange::Min, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__IntRange::Max, SOAP_TYPE_int);
#endif
}

int tt__IntRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const tt__IntRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), type))
		return soap->error;
	if (soap_out_int(soap, "tt:Min", -1, &a->tt__IntRange::Min, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &a->tt__IntRange::Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__IntRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, tt__IntRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__IntRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__IntRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Min", &a->tt__IntRange::Min, "xsd:int"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:Max", &a->tt__IntRange::Max, "xsd:int"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__IntRange *p;
	size_t k = sizeof(tt__IntRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__IntRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__IntRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__IntRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__IntRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__IntRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__IntRange(soap, tag ? tag : "tt:IntRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStartingConditionOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZPresetTourStartingConditionOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourStartingConditionOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStartingConditionOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStartingConditionOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStartingConditionOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(tt__PTZPresetTourStartingConditionOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStartingConditionOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(tt__PTZPresetTourStartingConditionOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStartingConditionOptionsExtension *p;
	size_t k = sizeof(tt__PTZPresetTourStartingConditionOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStartingConditionOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStartingConditionOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStartingConditionOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStartingConditionOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStartingConditionOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStartingConditionOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, tt__PTZPresetTourStartingConditionOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStartingConditionOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZPresetTourStartingConditionOptions::RecurringTime = NULL;
	this->tt__PTZPresetTourStartingConditionOptions::RecurringDuration = NULL;
	soap_default_std__vectorTemplateOftt__PTZPresetTourDirection(soap, &this->tt__PTZPresetTourStartingConditionOptions::Direction);
	this->tt__PTZPresetTourStartingConditionOptions::Extension = NULL;
}

void tt__PTZPresetTourStartingConditionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__IntRange(soap, &this->tt__PTZPresetTourStartingConditionOptions::RecurringTime);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__PTZPresetTourStartingConditionOptions::RecurringDuration);
	soap_serialize_std__vectorTemplateOftt__PTZPresetTourDirection(soap, &this->tt__PTZPresetTourStartingConditionOptions::Direction);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, &this->tt__PTZPresetTourStartingConditionOptions::Extension);
#endif
}

int tt__PTZPresetTourStartingConditionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStartingConditionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStartingConditionOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions), type))
		return soap->error;
	if (soap_out_PointerTott__IntRange(soap, "tt:RecurringTime", -1, &a->tt__PTZPresetTourStartingConditionOptions::RecurringTime, ""))
		return soap->error;
	if (soap_out_PointerTott__DurationRange(soap, "tt:RecurringDuration", -1, &a->tt__PTZPresetTourStartingConditionOptions::RecurringDuration, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__PTZPresetTourDirection(soap, "tt:Direction", -1, &a->tt__PTZPresetTourStartingConditionOptions::Direction, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourStartingConditionOptions::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStartingConditionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStartingConditionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(tt__PTZPresetTourStartingConditionOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStartingConditionOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_RecurringTime1 = 1;
	size_t soap_flag_RecurringDuration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecurringTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__IntRange(soap, "tt:RecurringTime", &a->tt__PTZPresetTourStartingConditionOptions::RecurringTime, "tt:IntRange"))
				{	soap_flag_RecurringTime1--;
					continue;
				}
			}
			if (soap_flag_RecurringDuration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:RecurringDuration", &a->tt__PTZPresetTourStartingConditionOptions::RecurringDuration, "tt:DurationRange"))
				{	soap_flag_RecurringDuration1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__PTZPresetTourDirection(soap, "tt:Direction", &a->tt__PTZPresetTourStartingConditionOptions::Direction, "tt:PTZPresetTourDirection"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, "tt:Extension", &a->tt__PTZPresetTourStartingConditionOptions::Extension, "tt:PTZPresetTourStartingConditionOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(tt__PTZPresetTourStartingConditionOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStartingConditionOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStartingConditionOptions *p;
	size_t k = sizeof(tt__PTZPresetTourStartingConditionOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStartingConditionOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStartingConditionOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStartingConditionOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStartingConditionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStartingConditionOptions(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStartingConditionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStartingConditionOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionOptions(struct soap *soap, tt__PTZPresetTourStartingConditionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourPresetDetailOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZPresetTourPresetDetailOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourPresetDetailOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourPresetDetailOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourPresetDetailOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetailOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourPresetDetailOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(tt__PTZPresetTourPresetDetailOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourPresetDetailOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourPresetDetailOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(tt__PTZPresetTourPresetDetailOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourPresetDetailOptionsExtension *p;
	size_t k = sizeof(tt__PTZPresetTourPresetDetailOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourPresetDetailOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourPresetDetailOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourPresetDetailOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourPresetDetailOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourPresetDetailOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourPresetDetailOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptionsExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, tt__PTZPresetTourPresetDetailOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourPresetDetailOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__PTZPresetTourPresetDetailOptions::PresetToken);
	this->tt__PTZPresetTourPresetDetailOptions::Home = NULL;
	this->tt__PTZPresetTourPresetDetailOptions::PanTiltPositionSpace = NULL;
	this->tt__PTZPresetTourPresetDetailOptions::ZoomPositionSpace = NULL;
	this->tt__PTZPresetTourPresetDetailOptions::Extension = NULL;
}

void tt__PTZPresetTourPresetDetailOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReferenceToken(soap, &this->tt__PTZPresetTourPresetDetailOptions::PresetToken);
	soap_serialize_PointerTobool(soap, &this->tt__PTZPresetTourPresetDetailOptions::Home);
	soap_serialize_PointerTott__Space2DDescription(soap, &this->tt__PTZPresetTourPresetDetailOptions::PanTiltPositionSpace);
	soap_serialize_PointerTott__Space1DDescription(soap, &this->tt__PTZPresetTourPresetDetailOptions::ZoomPositionSpace);
	soap_serialize_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, &this->tt__PTZPresetTourPresetDetailOptions::Extension);
#endif
}

int tt__PTZPresetTourPresetDetailOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourPresetDetailOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourPresetDetailOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReferenceToken(soap, "tt:PresetToken", -1, &a->tt__PTZPresetTourPresetDetailOptions::PresetToken, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tt:Home", -1, &a->tt__PTZPresetTourPresetDetailOptions::Home, ""))
		return soap->error;
	if (soap_out_PointerTott__Space2DDescription(soap, "tt:PanTiltPositionSpace", -1, &a->tt__PTZPresetTourPresetDetailOptions::PanTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerTott__Space1DDescription(soap, "tt:ZoomPositionSpace", -1, &a->tt__PTZPresetTourPresetDetailOptions::ZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourPresetDetailOptions::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourPresetDetailOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetailOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourPresetDetailOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(tt__PTZPresetTourPresetDetailOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourPresetDetailOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Home1 = 1;
	size_t soap_flag_PanTiltPositionSpace1 = 1;
	size_t soap_flag_ZoomPositionSpace1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReferenceToken(soap, "tt:PresetToken", &a->tt__PTZPresetTourPresetDetailOptions::PresetToken, "tt:ReferenceToken"))
					continue;
			}
			if (soap_flag_Home1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tt:Home", &a->tt__PTZPresetTourPresetDetailOptions::Home, "xsd:boolean"))
				{	soap_flag_Home1--;
					continue;
				}
			}
			if (soap_flag_PanTiltPositionSpace1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:PanTiltPositionSpace", &a->tt__PTZPresetTourPresetDetailOptions::PanTiltPositionSpace, "tt:Space2DDescription"))
				{	soap_flag_PanTiltPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_ZoomPositionSpace1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:ZoomPositionSpace", &a->tt__PTZPresetTourPresetDetailOptions::ZoomPositionSpace, "tt:Space1DDescription"))
				{	soap_flag_ZoomPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, "tt:Extension", &a->tt__PTZPresetTourPresetDetailOptions::Extension, "tt:PTZPresetTourPresetDetailOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourPresetDetailOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(tt__PTZPresetTourPresetDetailOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourPresetDetailOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourPresetDetailOptions *p;
	size_t k = sizeof(tt__PTZPresetTourPresetDetailOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourPresetDetailOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourPresetDetailOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourPresetDetailOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourPresetDetailOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourPresetDetailOptions(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourPresetDetailOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourPresetDetailOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetailOptions(struct soap *soap, tt__PTZPresetTourPresetDetailOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSpotOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZPresetTourSpotOptions::PresetDetail = NULL;
	this->tt__PTZPresetTourSpotOptions::StayTime = NULL;
}

void tt__PTZPresetTourSpotOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourPresetDetailOptions(soap, &this->tt__PTZPresetTourSpotOptions::PresetDetail);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__PTZPresetTourSpotOptions::StayTime);
#endif
}

int tt__PTZPresetTourSpotOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSpotOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSpotOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpotOptions), type))
		return soap->error;
	if (!a->tt__PTZPresetTourSpotOptions::PresetDetail)
	{	if (soap_element_empty(soap, "tt:PresetDetail", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourPresetDetailOptions(soap, "tt:PresetDetail", -1, &a->tt__PTZPresetTourSpotOptions::PresetDetail, ""))
		return soap->error;
	if (!a->tt__PTZPresetTourSpotOptions::StayTime)
	{	if (soap_element_empty(soap, "tt:StayTime", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DurationRange(soap, "tt:StayTime", -1, &a->tt__PTZPresetTourSpotOptions::StayTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSpotOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSpotOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpotOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, tt__PTZPresetTourSpotOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSpotOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(tt__PTZPresetTourSpotOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSpotOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSpotOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PresetDetail1 = 1;
	size_t soap_flag_StayTime1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetDetail1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetailOptions(soap, "tt:PresetDetail", &a->tt__PTZPresetTourSpotOptions::PresetDetail, "tt:PTZPresetTourPresetDetailOptions"))
				{	soap_flag_PresetDetail1--;
					continue;
				}
			}
			if (soap_flag_StayTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:StayTime", &a->tt__PTZPresetTourSpotOptions::StayTime, "tt:DurationRange"))
				{	soap_flag_StayTime1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZPresetTourSpotOptions::PresetDetail || !a->tt__PTZPresetTourSpotOptions::StayTime))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSpotOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotOptions, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(tt__PTZPresetTourSpotOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSpotOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSpotOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSpotOptions *p;
	size_t k = sizeof(tt__PTZPresetTourSpotOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSpotOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSpotOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSpotOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSpotOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSpotOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSpotOptions(soap, tag ? tag : "tt:PTZPresetTourSpotOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSpotOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSpotOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpotOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpotOptions(struct soap *soap, tt__PTZPresetTourSpotOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpotOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->tt__PTZPresetTourOptions::AutoStart);
	this->tt__PTZPresetTourOptions::StartingCondition = NULL;
	this->tt__PTZPresetTourOptions::TourSpot = NULL;
}

void tt__PTZPresetTourOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZPresetTourOptions::AutoStart, SOAP_TYPE_bool);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionOptions(soap, &this->tt__PTZPresetTourOptions::StartingCondition);
	soap_serialize_PointerTott__PTZPresetTourSpotOptions(soap, &this->tt__PTZPresetTourOptions::TourSpot);
#endif
}

int tt__PTZPresetTourOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourOptions(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourOptions), type))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoStart", -1, &a->tt__PTZPresetTourOptions::AutoStart, ""))
		return soap->error;
	if (!a->tt__PTZPresetTourOptions::StartingCondition)
	{	if (soap_element_empty(soap, "tt:StartingCondition", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStartingConditionOptions(soap, "tt:StartingCondition", -1, &a->tt__PTZPresetTourOptions::StartingCondition, ""))
		return soap->error;
	if (!a->tt__PTZPresetTourOptions::TourSpot)
	{	if (soap_element_empty(soap, "tt:TourSpot", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourSpotOptions(soap, "tt:TourSpot", -1, &a->tt__PTZPresetTourOptions::TourSpot, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourOptions * SOAP_FMAC4 soap_in_tt__PTZPresetTourOptions(struct soap *soap, const char *tag, tt__PTZPresetTourOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(tt__PTZPresetTourOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AutoStart1 = 1;
	size_t soap_flag_StartingCondition1 = 1;
	size_t soap_flag_TourSpot1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoStart", &a->tt__PTZPresetTourOptions::AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			}
			if (soap_flag_StartingCondition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionOptions(soap, "tt:StartingCondition", &a->tt__PTZPresetTourOptions::StartingCondition, "tt:PTZPresetTourStartingConditionOptions"))
				{	soap_flag_StartingCondition1--;
					continue;
				}
			}
			if (soap_flag_TourSpot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpotOptions(soap, "tt:TourSpot", &a->tt__PTZPresetTourOptions::TourSpot, "tt:PTZPresetTourSpotOptions"))
				{	soap_flag_TourSpot1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AutoStart1 > 0 || !a->tt__PTZPresetTourOptions::StartingCondition || !a->tt__PTZPresetTourOptions::TourSpot))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourOptions, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(tt__PTZPresetTourOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourOptions * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourOptions *p;
	size_t k = sizeof(tt__PTZPresetTourOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourOptions(soap, tag ? tag : "tt:PTZPresetTourOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourOptions * SOAP_FMAC4 soap_get_tt__PTZPresetTourOptions(struct soap *soap, tt__PTZPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStartingConditionExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZPresetTourStartingConditionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourStartingConditionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStartingConditionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStartingConditionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStartingConditionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStartingConditionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(tt__PTZPresetTourStartingConditionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStartingConditionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(tt__PTZPresetTourStartingConditionExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStartingConditionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStartingConditionExtension *p;
	size_t k = sizeof(tt__PTZPresetTourStartingConditionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStartingConditionExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStartingConditionExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStartingConditionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStartingConditionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStartingConditionExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStartingConditionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStartingConditionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingConditionExtension(struct soap *soap, tt__PTZPresetTourStartingConditionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStartingCondition::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZPresetTourStartingCondition::RecurringTime = NULL;
	this->tt__PTZPresetTourStartingCondition::RecurringDuration = NULL;
	this->tt__PTZPresetTourStartingCondition::Direction = NULL;
	this->tt__PTZPresetTourStartingCondition::Extension = NULL;
	this->tt__PTZPresetTourStartingCondition::RandomPresetOrder = NULL;
}

void tt__PTZPresetTourStartingCondition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &this->tt__PTZPresetTourStartingCondition::RecurringTime);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZPresetTourStartingCondition::RecurringDuration);
	soap_serialize_PointerTott__PTZPresetTourDirection(soap, &this->tt__PTZPresetTourStartingCondition::Direction);
	soap_serialize_PointerTott__PTZPresetTourStartingConditionExtension(soap, &this->tt__PTZPresetTourStartingCondition::Extension);
#endif
}

int tt__PTZPresetTourStartingCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStartingCondition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStartingCondition *a, const char *type)
{
	if (((tt__PTZPresetTourStartingCondition*)a)->RandomPresetOrder)
	{	soap_set_attr(soap, "RandomPresetOrder", soap_bool2s(soap, *((tt__PTZPresetTourStartingCondition*)a)->RandomPresetOrder), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:RecurringTime", -1, &a->tt__PTZPresetTourStartingCondition::RecurringTime, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:RecurringDuration", -1, &a->tt__PTZPresetTourStartingCondition::RecurringDuration, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourDirection(soap, "tt:Direction", -1, &a->tt__PTZPresetTourStartingCondition::Direction, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStartingConditionExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourStartingCondition::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStartingCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStartingCondition(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_in_tt__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, tt__PTZPresetTourStartingCondition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStartingCondition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(tt__PTZPresetTourStartingCondition), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStartingCondition)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStartingCondition *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "RandomPresetOrder", 5, 0);
		if (t)
		{
			if (!(((tt__PTZPresetTourStartingCondition*)a)->RandomPresetOrder = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__PTZPresetTourStartingCondition*)a)->RandomPresetOrder))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_RecurringTime1 = 1;
	size_t soap_flag_RecurringDuration1 = 1;
	size_t soap_flag_Direction1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecurringTime1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "tt:RecurringTime", &a->tt__PTZPresetTourStartingCondition::RecurringTime, "xsd:int"))
				{	soap_flag_RecurringTime1--;
					continue;
				}
			}
			if (soap_flag_RecurringDuration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:RecurringDuration", &a->tt__PTZPresetTourStartingCondition::RecurringDuration, "xsd:duration"))
				{	soap_flag_RecurringDuration1--;
					continue;
				}
			}
			if (soap_flag_Direction1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourDirection(soap, "tt:Direction", &a->tt__PTZPresetTourStartingCondition::Direction, "tt:PTZPresetTourDirection"))
				{	soap_flag_Direction1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingConditionExtension(soap, "tt:Extension", &a->tt__PTZPresetTourStartingCondition::Extension, "tt:PTZPresetTourStartingConditionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStartingCondition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStartingCondition, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(tt__PTZPresetTourStartingCondition), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStartingCondition * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStartingCondition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStartingCondition(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStartingCondition *p;
	size_t k = sizeof(tt__PTZPresetTourStartingCondition);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStartingCondition, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStartingCondition);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStartingCondition, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStartingCondition location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStartingCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStartingCondition(soap, tag ? tag : "tt:PTZPresetTourStartingCondition", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStartingCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStartingCondition(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStartingCondition * SOAP_FMAC4 soap_get_tt__PTZPresetTourStartingCondition(struct soap *soap, tt__PTZPresetTourStartingCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStartingCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStatusExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZPresetTourStatusExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourStatusExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStatusExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStatusExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStatusExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStatusExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStatusExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStatusExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStatusExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStatusExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(tt__PTZPresetTourStatusExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStatusExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStatusExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStatusExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatusExtension, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(tt__PTZPresetTourStatusExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStatusExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatusExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStatusExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStatusExtension *p;
	size_t k = sizeof(tt__PTZPresetTourStatusExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStatusExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStatusExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStatusExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStatusExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStatusExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStatusExtension(soap, tag ? tag : "tt:PTZPresetTourStatusExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStatusExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStatusExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStatusExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourStatusExtension(struct soap *soap, tt__PTZPresetTourStatusExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__PTZPresetTourState(soap, &this->tt__PTZPresetTourStatus::State);
	this->tt__PTZPresetTourStatus::CurrentTourSpot = NULL;
	this->tt__PTZPresetTourStatus::Extension = NULL;
}

void tt__PTZPresetTourStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourSpot(soap, &this->tt__PTZPresetTourStatus::CurrentTourSpot);
	soap_serialize_PointerTott__PTZPresetTourStatusExtension(soap, &this->tt__PTZPresetTourStatus::Extension);
#endif
}

int tt__PTZPresetTourStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourStatus(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourStatus), type))
		return soap->error;
	if (soap_out_tt__PTZPresetTourState(soap, "tt:State", -1, &a->tt__PTZPresetTourStatus::State, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSpot(soap, "tt:CurrentTourSpot", -1, &a->tt__PTZPresetTourStatus::CurrentTourSpot, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourStatusExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourStatus::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourStatus(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourStatus * SOAP_FMAC4 soap_in_tt__PTZPresetTourStatus(struct soap *soap, const char *tag, tt__PTZPresetTourStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(tt__PTZPresetTourStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_State1 = 1;
	size_t soap_flag_CurrentTourSpot1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__PTZPresetTourState(soap, "tt:State", &a->tt__PTZPresetTourStatus::State, "tt:PTZPresetTourState"))
				{	soap_flag_State1--;
					continue;
				}
			}
			if (soap_flag_CurrentTourSpot1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpot(soap, "tt:CurrentTourSpot", &a->tt__PTZPresetTourStatus::CurrentTourSpot, "tt:PTZPresetTourSpot"))
				{	soap_flag_CurrentTourSpot1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStatusExtension(soap, "tt:Extension", &a->tt__PTZPresetTourStatus::Extension, "tt:PTZPresetTourStatusExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourStatus, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(tt__PTZPresetTourStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourStatus * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourStatus *p;
	size_t k = sizeof(tt__PTZPresetTourStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourStatus(soap, tag ? tag : "tt:PTZPresetTourStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourStatus(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourStatus * SOAP_FMAC4 soap_get_tt__PTZPresetTourStatus(struct soap *soap, tt__PTZPresetTourStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourTypeExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZPresetTourTypeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourTypeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourTypeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourTypeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourTypeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourTypeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, tt__PTZPresetTourTypeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourTypeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(tt__PTZPresetTourTypeExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourTypeExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourTypeExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourTypeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourTypeExtension, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(tt__PTZPresetTourTypeExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourTypeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourTypeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourTypeExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourTypeExtension *p;
	size_t k = sizeof(tt__PTZPresetTourTypeExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourTypeExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourTypeExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourTypeExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourTypeExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourTypeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourTypeExtension(soap, tag ? tag : "tt:PTZPresetTourTypeExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourTypeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourTypeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourTypeExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourTypeExtension(struct soap *soap, tt__PTZPresetTourTypeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourTypeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourPresetDetail::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZPresetTourPresetDetail::__union_PTZPresetTourPresetDetail = 0;
}

void tt__PTZPresetTourPresetDetail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__tt__union_PTZPresetTourPresetDetail(soap, this->tt__PTZPresetTourPresetDetail::__union_PTZPresetTourPresetDetail, &this->tt__PTZPresetTourPresetDetail::union_PTZPresetTourPresetDetail);
#endif
}

int tt__PTZPresetTourPresetDetail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourPresetDetail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourPresetDetail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail), type))
		return soap->error;
	if (soap_out__tt__union_PTZPresetTourPresetDetail(soap, a->tt__PTZPresetTourPresetDetail::__union_PTZPresetTourPresetDetail, &a->tt__PTZPresetTourPresetDetail::union_PTZPresetTourPresetDetail))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourPresetDetail::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourPresetDetail(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in_tt__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetail *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourPresetDetail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(tt__PTZPresetTourPresetDetail), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (!tag || *tag == '-' || (soap->body && *soap->href != '#'))
	{
		if (!soap_in__tt__union_PTZPresetTourPresetDetail(soap, &a->__union_PTZPresetTourPresetDetail, &a->union_PTZPresetTourPresetDetail))
			return NULL;
		if (tag && *tag != '-')
		{	soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_TAG_MISMATCH || soap_element_end_in(soap, tag))
				return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourPresetDetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourPresetDetail, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(tt__PTZPresetTourPresetDetail), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourPresetDetail * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourPresetDetail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourPresetDetail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourPresetDetail *p;
	size_t k = sizeof(tt__PTZPresetTourPresetDetail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourPresetDetail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourPresetDetail);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourPresetDetail, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourPresetDetail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourPresetDetail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourPresetDetail(soap, tag ? tag : "tt:PTZPresetTourPresetDetail", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourPresetDetail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourPresetDetail(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetail * SOAP_FMAC4 soap_get_tt__PTZPresetTourPresetDetail(struct soap *soap, tt__PTZPresetTourPresetDetail *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourPresetDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSpotExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZPresetTourSpotExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourSpotExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSpotExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSpotExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSpotExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSpotExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, tt__PTZPresetTourSpotExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSpotExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(tt__PTZPresetTourSpotExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSpotExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSpotExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSpotExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpotExtension, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(tt__PTZPresetTourSpotExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSpotExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpotExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSpotExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSpotExtension *p;
	size_t k = sizeof(tt__PTZPresetTourSpotExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSpotExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSpotExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSpotExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSpotExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSpotExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSpotExtension(soap, tag ? tag : "tt:PTZPresetTourSpotExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSpotExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSpotExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpotExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpotExtension(struct soap *soap, tt__PTZPresetTourSpotExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpotExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSpot::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZPresetTourSpot::PresetDetail = NULL;
	this->tt__PTZPresetTourSpot::Speed = NULL;
	this->tt__PTZPresetTourSpot::StayTime = NULL;
	this->tt__PTZPresetTourSpot::Extension = NULL;
}

void tt__PTZPresetTourSpot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourPresetDetail(soap, &this->tt__PTZPresetTourSpot::PresetDetail);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->tt__PTZPresetTourSpot::Speed);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZPresetTourSpot::StayTime);
	soap_serialize_PointerTott__PTZPresetTourSpotExtension(soap, &this->tt__PTZPresetTourSpot::Extension);
#endif
}

int tt__PTZPresetTourSpot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSpot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSpot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSpot), type))
		return soap->error;
	if (!a->tt__PTZPresetTourSpot::PresetDetail)
	{	if (soap_element_empty(soap, "tt:PresetDetail", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourPresetDetail(soap, "tt:PresetDetail", -1, &a->tt__PTZPresetTourSpot::PresetDetail, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:Speed", -1, &a->tt__PTZPresetTourSpot::Speed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:StayTime", -1, &a->tt__PTZPresetTourSpot::StayTime, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSpotExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourSpot::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSpot::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSpot(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpot * SOAP_FMAC4 soap_in_tt__PTZPresetTourSpot(struct soap *soap, const char *tag, tt__PTZPresetTourSpot *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSpot*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(tt__PTZPresetTourSpot), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSpot)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSpot *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PresetDetail1 = 1;
	size_t soap_flag_Speed1 = 1;
	size_t soap_flag_StayTime1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetDetail1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourPresetDetail(soap, "tt:PresetDetail", &a->tt__PTZPresetTourSpot::PresetDetail, "tt:PTZPresetTourPresetDetail"))
				{	soap_flag_PresetDetail1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tt:Speed", &a->tt__PTZPresetTourSpot::Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_StayTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:StayTime", &a->tt__PTZPresetTourSpot::StayTime, "xsd:duration"))
				{	soap_flag_StayTime1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSpotExtension(soap, "tt:Extension", &a->tt__PTZPresetTourSpot::Extension, "tt:PTZPresetTourSpotExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZPresetTourSpot::PresetDetail))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSpot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSpot, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(tt__PTZPresetTourSpot), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSpot * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSpot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSpot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSpot *p;
	size_t k = sizeof(tt__PTZPresetTourSpot);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSpot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSpot);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSpot, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSpot location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSpot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSpot(soap, tag ? tag : "tt:PTZPresetTourSpot", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSpot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSpot(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSpot * SOAP_FMAC4 soap_get_tt__PTZPresetTourSpot(struct soap *soap, tt__PTZPresetTourSpot *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSpot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZPresetTourExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourExtension(struct soap *soap, const char *tag, tt__PTZPresetTourExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(tt__PTZPresetTourExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourExtension, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(tt__PTZPresetTourExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourExtension *p;
	size_t k = sizeof(tt__PTZPresetTourExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourExtension(soap, tag ? tag : "tt:PTZPresetTourExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourExtension(struct soap *soap, tt__PTZPresetTourExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PresetTour::Name = NULL;
	this->tt__PresetTour::Status = NULL;
	soap_default_bool(soap, &this->tt__PresetTour::AutoStart);
	this->tt__PresetTour::StartingCondition = NULL;
	soap_default_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, &this->tt__PresetTour::TourSpot);
	this->tt__PresetTour::Extension = NULL;
	this->tt__PresetTour::token = NULL;
}

void tt__PresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Name(soap, &this->tt__PresetTour::Name);
	soap_serialize_PointerTott__PTZPresetTourStatus(soap, &this->tt__PresetTour::Status);
	soap_embedded(soap, &this->tt__PresetTour::AutoStart, SOAP_TYPE_bool);
	soap_serialize_PointerTott__PTZPresetTourStartingCondition(soap, &this->tt__PresetTour::StartingCondition);
	soap_serialize_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, &this->tt__PresetTour::TourSpot);
	soap_serialize_PointerTott__PTZPresetTourExtension(soap, &this->tt__PresetTour::Extension);
#endif
}

int tt__PresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PresetTour(struct soap *soap, const char *tag, int id, const tt__PresetTour *a, const char *type)
{
	if (((tt__PresetTour*)a)->token)
	{	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, *((tt__PresetTour*)a)->token), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PresetTour), type))
		return soap->error;
	if (soap_out_PointerTott__Name(soap, "tt:Name", -1, &a->tt__PresetTour::Name, ""))
		return soap->error;
	if (!a->tt__PresetTour::Status)
	{	if (soap_element_empty(soap, "tt:Status", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStatus(soap, "tt:Status", -1, &a->tt__PresetTour::Status, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:AutoStart", -1, &a->tt__PresetTour::AutoStart, ""))
		return soap->error;
	if (!a->tt__PresetTour::StartingCondition)
	{	if (soap_element_empty(soap, "tt:StartingCondition", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourStartingCondition(soap, "tt:StartingCondition", -1, &a->tt__PresetTour::StartingCondition, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, "tt:TourSpot", -1, &a->tt__PresetTour::TourSpot, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourExtension(soap, "tt:Extension", -1, &a->tt__PresetTour::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PresetTour(soap, tag, this, type);
}

SOAP_FMAC3 tt__PresetTour * SOAP_FMAC4 soap_in_tt__PresetTour(struct soap *soap, const char *tag, tt__PresetTour *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PresetTour, sizeof(tt__PresetTour), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PresetTour)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PresetTour *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "token", 1, 0);
		if (t)
		{
			if (!(((tt__PresetTour*)a)->token = soap_new_tt__ReferenceToken(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__ReferenceToken(soap, t, ((tt__PresetTour*)a)->token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_Status1 = 1;
	size_t soap_flag_AutoStart1 = 1;
	size_t soap_flag_StartingCondition1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Name(soap, "tt:Name", &a->tt__PresetTour::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStatus(soap, "tt:Status", &a->tt__PresetTour::Status, "tt:PTZPresetTourStatus"))
				{	soap_flag_Status1--;
					continue;
				}
			}
			if (soap_flag_AutoStart1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:AutoStart", &a->tt__PresetTour::AutoStart, "xsd:boolean"))
				{	soap_flag_AutoStart1--;
					continue;
				}
			}
			if (soap_flag_StartingCondition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourStartingCondition(soap, "tt:StartingCondition", &a->tt__PresetTour::StartingCondition, "tt:PTZPresetTourStartingCondition"))
				{	soap_flag_StartingCondition1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap, "tt:TourSpot", &a->tt__PresetTour::TourSpot, "tt:PTZPresetTourSpot"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourExtension(soap, "tt:Extension", &a->tt__PresetTour::Extension, "tt:PTZPresetTourExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PresetTour::Status || soap_flag_AutoStart1 > 0 || !a->tt__PresetTour::StartingCondition))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PresetTour, SOAP_TYPE_tt__PresetTour, sizeof(tt__PresetTour), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PresetTour * SOAP_FMAC2 soap_instantiate_tt__PresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PresetTour *p;
	size_t k = sizeof(tt__PresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PresetTour);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PresetTour, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PresetTour(soap, tag ? tag : "tt:PresetTour", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PresetTour(soap, this, tag, type);
}

SOAP_FMAC3 tt__PresetTour * SOAP_FMAC4 soap_get_tt__PresetTour(struct soap *soap, tt__PresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZPreset::Name = NULL;
	this->tt__PTZPreset::PTZPosition = NULL;
	this->tt__PTZPreset::token = NULL;
}

void tt__PTZPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Name(soap, &this->tt__PTZPreset::Name);
	soap_serialize_PointerTott__PTZVector(soap, &this->tt__PTZPreset::PTZPosition);
#endif
}

int tt__PTZPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPreset(struct soap *soap, const char *tag, int id, const tt__PTZPreset *a, const char *type)
{
	if (((tt__PTZPreset*)a)->token)
	{	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, *((tt__PTZPreset*)a)->token), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPreset), type))
		return soap->error;
	if (soap_out_PointerTott__Name(soap, "tt:Name", -1, &a->tt__PTZPreset::Name, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->tt__PTZPreset::PTZPosition, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPreset(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPreset * SOAP_FMAC4 soap_in_tt__PTZPreset(struct soap *soap, const char *tag, tt__PTZPreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPreset, sizeof(tt__PTZPreset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPreset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPreset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "token", 1, 0);
		if (t)
		{
			if (!(((tt__PTZPreset*)a)->token = soap_new_tt__ReferenceToken(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__ReferenceToken(soap, t, ((tt__PTZPreset*)a)->token))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_PTZPosition1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Name(soap, "tt:Name", &a->tt__PTZPreset::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_PTZPosition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->tt__PTZPreset::PTZPosition, "tt:PTZVector"))
				{	soap_flag_PTZPosition1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPreset, SOAP_TYPE_tt__PTZPreset, sizeof(tt__PTZPreset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPreset * SOAP_FMAC2 soap_instantiate_tt__PTZPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPreset *p;
	size_t k = sizeof(tt__PTZPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPreset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPreset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPreset(soap, tag ? tag : "tt:PTZPreset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPreset(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPreset * SOAP_FMAC4 soap_get_tt__PTZPreset(struct soap *soap, tt__PTZPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZSpeed::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZSpeed::PanTilt = NULL;
	this->tt__PTZSpeed::Zoom = NULL;
}

void tt__PTZSpeed::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Vector2D(soap, &this->tt__PTZSpeed::PanTilt);
	soap_serialize_PointerTott__Vector1D(soap, &this->tt__PTZSpeed::Zoom);
#endif
}

int tt__PTZSpeed::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpeed(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpeed(struct soap *soap, const char *tag, int id, const tt__PTZSpeed *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpeed), type))
		return soap->error;
	if (soap_out_PointerTott__Vector2D(soap, "tt:PanTilt", -1, &a->tt__PTZSpeed::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTott__Vector1D(soap, "tt:Zoom", -1, &a->tt__PTZSpeed::Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpeed::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZSpeed(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_in_tt__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpeed*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZSpeed)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZSpeed *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector2D(soap, "tt:PanTilt", &a->tt__PTZSpeed::PanTilt, "tt:Vector2D"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Vector1D(soap, "tt:Zoom", &a->tt__PTZSpeed::Zoom, "tt:Vector1D"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpeed *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpeed, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpeed * SOAP_FMAC2 soap_instantiate_tt__PTZSpeed(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpeed(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZSpeed *p;
	size_t k = sizeof(tt__PTZSpeed);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZSpeed, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZSpeed);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZSpeed, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZSpeed location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZSpeed::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpeed::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpeed(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpeed * SOAP_FMAC4 soap_get_tt__PTZSpeed(struct soap *soap, tt__PTZSpeed *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Space1DDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	this->tt__Space1DDescription::XRange = NULL;
}

void tt__Space1DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Space1DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space1DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space1DDescription::XRange);
#endif
}

int tt__Space1DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space1DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space1DDescription(struct soap *soap, const char *tag, int id, const tt__Space1DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space1DDescription), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &a->tt__Space1DDescription::URI, ""))
		return soap->error;
	if (!a->tt__Space1DDescription::XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space1DDescription::XRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Space1DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Space1DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_in_tt__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space1DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Space1DDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Space1DDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", &a->tt__Space1DDescription::URI, "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->tt__Space1DDescription::XRange, "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0 || !a->tt__Space1DDescription::XRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Space1DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space1DDescription * SOAP_FMAC2 soap_instantiate_tt__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Space1DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Space1DDescription *p;
	size_t k = sizeof(tt__Space1DDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Space1DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Space1DDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Space1DDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Space1DDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Space1DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space1DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space1DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space1DDescription * SOAP_FMAC4 soap_get_tt__Space1DDescription(struct soap *soap, tt__Space1DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Space2DDescription::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	this->tt__Space2DDescription::XRange = NULL;
	this->tt__Space2DDescription::YRange = NULL;
}

void tt__Space2DDescription::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__Space2DDescription::URI, SOAP_TYPE_xsd__anyURI);
	soap_serialize_xsd__anyURI(soap, &this->tt__Space2DDescription::URI);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::XRange);
	soap_serialize_PointerTott__FloatRange(soap, &this->tt__Space2DDescription::YRange);
#endif
}

int tt__Space2DDescription::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Space2DDescription(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Space2DDescription(struct soap *soap, const char *tag, int id, const tt__Space2DDescription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Space2DDescription), type))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tt:URI", -1, &a->tt__Space2DDescription::URI, ""))
		return soap->error;
	if (!a->tt__Space2DDescription::XRange)
	{	if (soap_element_empty(soap, "tt:XRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:XRange", -1, &a->tt__Space2DDescription::XRange, ""))
		return soap->error;
	if (!a->tt__Space2DDescription::YRange)
	{	if (soap_element_empty(soap, "tt:YRange", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__FloatRange(soap, "tt:YRange", -1, &a->tt__Space2DDescription::YRange, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Space2DDescription::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Space2DDescription(soap, tag, this, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_in_tt__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Space2DDescription*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Space2DDescription)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Space2DDescription *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_URI1 = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_URI1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__anyURI(soap, "tt:URI", &a->tt__Space2DDescription::URI, "xsd:anyURI"))
				{	soap_flag_URI1--;
					continue;
				}
			}
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:XRange", &a->tt__Space2DDescription::XRange, "tt:FloatRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__FloatRange(soap, "tt:YRange", &a->tt__Space2DDescription::YRange, "tt:FloatRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_URI1 > 0 || !a->tt__Space2DDescription::XRange || !a->tt__Space2DDescription::YRange))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Space2DDescription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Space2DDescription * SOAP_FMAC2 soap_instantiate_tt__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Space2DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Space2DDescription *p;
	size_t k = sizeof(tt__Space2DDescription);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Space2DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Space2DDescription);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Space2DDescription, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Space2DDescription location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Space2DDescription::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Space2DDescription::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Space2DDescription(soap, this, tag, type);
}

SOAP_FMAC3 tt__Space2DDescription * SOAP_FMAC4 soap_get_tt__Space2DDescription(struct soap *soap, tt__Space2DDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZSpacesExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZSpacesExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZSpacesExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpacesExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpacesExtension(struct soap *soap, const char *tag, int id, const tt__PTZSpacesExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpacesExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpacesExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZSpacesExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpacesExtension * SOAP_FMAC4 soap_in_tt__PTZSpacesExtension(struct soap *soap, const char *tag, tt__PTZSpacesExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpacesExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(tt__PTZSpacesExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZSpacesExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZSpacesExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpacesExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpacesExtension, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(tt__PTZSpacesExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpacesExtension * SOAP_FMAC2 soap_instantiate_tt__PTZSpacesExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpacesExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZSpacesExtension *p;
	size_t k = sizeof(tt__PTZSpacesExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZSpacesExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZSpacesExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZSpacesExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZSpacesExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZSpacesExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZSpacesExtension(soap, tag ? tag : "tt:PTZSpacesExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpacesExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpacesExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpacesExtension * SOAP_FMAC4 soap_get_tt__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZSpaces::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::AbsolutePanTiltPositionSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::AbsoluteZoomPositionSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::RelativePanTiltTranslationSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::RelativeZoomTranslationSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::ContinuousPanTiltVelocitySpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ContinuousZoomVelocitySpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::PanTiltSpeedSpace);
	soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ZoomSpeedSpace);
	this->tt__PTZSpaces::Extension = NULL;
}

void tt__PTZSpaces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::AbsolutePanTiltPositionSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::AbsoluteZoomPositionSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::RelativePanTiltTranslationSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::RelativeZoomTranslationSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(soap, &this->tt__PTZSpaces::ContinuousPanTiltVelocitySpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ContinuousZoomVelocitySpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::PanTiltSpeedSpace);
	soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(soap, &this->tt__PTZSpaces::ZoomSpeedSpace);
	soap_serialize_PointerTott__PTZSpacesExtension(soap, &this->tt__PTZSpaces::Extension);
#endif
}

int tt__PTZSpaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZSpaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZSpaces(struct soap *soap, const char *tag, int id, const tt__PTZSpaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZSpaces), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", -1, &a->tt__PTZSpaces::AbsolutePanTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", -1, &a->tt__PTZSpaces::AbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", -1, &a->tt__PTZSpaces::RelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", -1, &a->tt__PTZSpaces::RelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", -1, &a->tt__PTZSpaces::ContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", -1, &a->tt__PTZSpaces::ContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:PanTiltSpeedSpace", -1, &a->tt__PTZSpaces::PanTiltSpeedSpace, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ZoomSpeedSpace", -1, &a->tt__PTZSpaces::ZoomSpeedSpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpacesExtension(soap, "tt:Extension", -1, &a->tt__PTZSpaces::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZSpaces::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZSpaces(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZSpaces * SOAP_FMAC4 soap_in_tt__PTZSpaces(struct soap *soap, const char *tag, tt__PTZSpaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZSpaces*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZSpaces, sizeof(tt__PTZSpaces), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZSpaces)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZSpaces *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:AbsolutePanTiltPositionSpace", &a->tt__PTZSpaces::AbsolutePanTiltPositionSpace, "tt:Space2DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:AbsoluteZoomPositionSpace", &a->tt__PTZSpaces::AbsoluteZoomPositionSpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:RelativePanTiltTranslationSpace", &a->tt__PTZSpaces::RelativePanTiltTranslationSpace, "tt:Space2DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:RelativeZoomTranslationSpace", &a->tt__PTZSpaces::RelativeZoomTranslationSpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(soap, "tt:ContinuousPanTiltVelocitySpace", &a->tt__PTZSpaces::ContinuousPanTiltVelocitySpace, "tt:Space2DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ContinuousZoomVelocitySpace", &a->tt__PTZSpaces::ContinuousZoomVelocitySpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:PanTiltSpeedSpace", &a->tt__PTZSpaces::PanTiltSpeedSpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(soap, "tt:ZoomSpeedSpace", &a->tt__PTZSpaces::ZoomSpeedSpace, "tt:Space1DDescription"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpacesExtension(soap, "tt:Extension", &a->tt__PTZSpaces::Extension, "tt:PTZSpacesExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZSpaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZSpaces, SOAP_TYPE_tt__PTZSpaces, sizeof(tt__PTZSpaces), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZSpaces * SOAP_FMAC2 soap_instantiate_tt__PTZSpaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZSpaces(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZSpaces *p;
	size_t k = sizeof(tt__PTZSpaces);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZSpaces, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZSpaces);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZSpaces, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZSpaces location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZSpaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZSpaces(soap, tag ? tag : "tt:PTZSpaces", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZSpaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZSpaces(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZSpaces * SOAP_FMAC4 soap_get_tt__PTZSpaces(struct soap *soap, tt__PTZSpaces *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ZoomLimits::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ZoomLimits::Range = NULL;
}

void tt__ZoomLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space1DDescription(soap, &this->tt__ZoomLimits::Range);
#endif
}

int tt__ZoomLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ZoomLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ZoomLimits(struct soap *soap, const char *tag, int id, const tt__ZoomLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ZoomLimits), type))
		return soap->error;
	if (!a->tt__ZoomLimits::Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space1DDescription(soap, "tt:Range", -1, &a->tt__ZoomLimits::Range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ZoomLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ZoomLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_in_tt__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ZoomLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ZoomLimits)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ZoomLimits *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space1DDescription(soap, "tt:Range", &a->tt__ZoomLimits::Range, "tt:Space1DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__ZoomLimits::Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ZoomLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ZoomLimits, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ZoomLimits * SOAP_FMAC2 soap_instantiate_tt__ZoomLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ZoomLimits(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ZoomLimits *p;
	size_t k = sizeof(tt__ZoomLimits);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ZoomLimits, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ZoomLimits);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ZoomLimits, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ZoomLimits location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ZoomLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ZoomLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ZoomLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__ZoomLimits * SOAP_FMAC4 soap_get_tt__ZoomLimits(struct soap *soap, tt__ZoomLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PanTiltLimits::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PanTiltLimits::Range = NULL;
}

void tt__PanTiltLimits::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Space2DDescription(soap, &this->tt__PanTiltLimits::Range);
#endif
}

int tt__PanTiltLimits::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PanTiltLimits(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PanTiltLimits(struct soap *soap, const char *tag, int id, const tt__PanTiltLimits *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PanTiltLimits), type))
		return soap->error;
	if (!a->tt__PanTiltLimits::Range)
	{	if (soap_element_empty(soap, "tt:Range", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__Space2DDescription(soap, "tt:Range", -1, &a->tt__PanTiltLimits::Range, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PanTiltLimits::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PanTiltLimits(soap, tag, this, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_in_tt__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PanTiltLimits*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PanTiltLimits)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PanTiltLimits *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Range1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Range1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Space2DDescription(soap, "tt:Range", &a->tt__PanTiltLimits::Range, "tt:Space2DDescription"))
				{	soap_flag_Range1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PanTiltLimits::Range))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PanTiltLimits *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PanTiltLimits, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PanTiltLimits * SOAP_FMAC2 soap_instantiate_tt__PanTiltLimits(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PanTiltLimits(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PanTiltLimits *p;
	size_t k = sizeof(tt__PanTiltLimits);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PanTiltLimits, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PanTiltLimits);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PanTiltLimits, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PanTiltLimits location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PanTiltLimits::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PanTiltLimits::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PanTiltLimits(soap, this, tag, type);
}

SOAP_FMAC3 tt__PanTiltLimits * SOAP_FMAC4 soap_get_tt__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReverseOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__ReverseOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__ReverseOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReverseOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseOptionsExtension(struct soap *soap, const char *tag, int id, const tt__ReverseOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReverseOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReverseOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReverseOptionsExtension * SOAP_FMAC4 soap_in_tt__ReverseOptionsExtension(struct soap *soap, const char *tag, tt__ReverseOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReverseOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(tt__ReverseOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReverseOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReverseOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ReverseOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptionsExtension, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(tt__ReverseOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReverseOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__ReverseOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReverseOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReverseOptionsExtension *p;
	size_t k = sizeof(tt__ReverseOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReverseOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReverseOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReverseOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReverseOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReverseOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReverseOptionsExtension(soap, tag ? tag : "tt:ReverseOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReverseOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReverseOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReverseOptionsExtension * SOAP_FMAC4 soap_get_tt__ReverseOptionsExtension(struct soap *soap, tt__ReverseOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ReverseOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__ReverseMode(soap, &this->tt__ReverseOptions::Mode);
	this->tt__ReverseOptions::Extension = NULL;
}

void tt__ReverseOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__ReverseMode(soap, &this->tt__ReverseOptions::Mode);
	soap_serialize_PointerTott__ReverseOptionsExtension(soap, &this->tt__ReverseOptions::Extension);
#endif
}

int tt__ReverseOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ReverseOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReverseOptions(struct soap *soap, const char *tag, int id, const tt__ReverseOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ReverseOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__ReverseMode(soap, "tt:Mode", -1, &a->tt__ReverseOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__ReverseOptionsExtension(soap, "tt:Extension", -1, &a->tt__ReverseOptions::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ReverseOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ReverseOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__ReverseOptions * SOAP_FMAC4 soap_in_tt__ReverseOptions(struct soap *soap, const char *tag, tt__ReverseOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ReverseOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ReverseOptions, sizeof(tt__ReverseOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ReverseOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ReverseOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__ReverseMode(soap, "tt:Mode", &a->tt__ReverseOptions::Mode, "tt:ReverseMode"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReverseOptionsExtension(soap, "tt:Extension", &a->tt__ReverseOptions::Extension, "tt:ReverseOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ReverseOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ReverseOptions, SOAP_TYPE_tt__ReverseOptions, sizeof(tt__ReverseOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ReverseOptions * SOAP_FMAC2 soap_instantiate_tt__ReverseOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ReverseOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__ReverseOptions *p;
	size_t k = sizeof(tt__ReverseOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ReverseOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ReverseOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ReverseOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ReverseOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ReverseOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ReverseOptions(soap, tag ? tag : "tt:ReverseOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ReverseOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ReverseOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__ReverseOptions * SOAP_FMAC4 soap_get_tt__ReverseOptions(struct soap *soap, tt__ReverseOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReverseOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlipOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__EFlipOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__EFlipOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlipOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipOptionsExtension(struct soap *soap, const char *tag, int id, const tt__EFlipOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EFlipOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlipOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlipOptionsExtension * SOAP_FMAC4 soap_in_tt__EFlipOptionsExtension(struct soap *soap, const char *tag, tt__EFlipOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EFlipOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(tt__EFlipOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlipOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EFlipOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EFlipOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptionsExtension, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(tt__EFlipOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlipOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__EFlipOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EFlipOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlipOptionsExtension *p;
	size_t k = sizeof(tt__EFlipOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlipOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlipOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlipOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlipOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlipOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlipOptionsExtension(soap, tag ? tag : "tt:EFlipOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlipOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlipOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlipOptionsExtension * SOAP_FMAC4 soap_get_tt__EFlipOptionsExtension(struct soap *soap, tt__EFlipOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlipOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOftt__EFlipMode(soap, &this->tt__EFlipOptions::Mode);
	this->tt__EFlipOptions::Extension = NULL;
}

void tt__EFlipOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOftt__EFlipMode(soap, &this->tt__EFlipOptions::Mode);
	soap_serialize_PointerTott__EFlipOptionsExtension(soap, &this->tt__EFlipOptions::Extension);
#endif
}

int tt__EFlipOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlipOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlipOptions(struct soap *soap, const char *tag, int id, const tt__EFlipOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlipOptions), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__EFlipMode(soap, "tt:Mode", -1, &a->tt__EFlipOptions::Mode, ""))
		return soap->error;
	if (soap_out_PointerTott__EFlipOptionsExtension(soap, "tt:Extension", -1, &a->tt__EFlipOptions::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EFlipOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlipOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlipOptions * SOAP_FMAC4 soap_in_tt__EFlipOptions(struct soap *soap, const char *tag, tt__EFlipOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EFlipOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlipOptions, sizeof(tt__EFlipOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlipOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EFlipOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__EFlipMode(soap, "tt:Mode", &a->tt__EFlipOptions::Mode, "tt:EFlipMode"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlipOptionsExtension(soap, "tt:Extension", &a->tt__EFlipOptions::Extension, "tt:EFlipOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__EFlipOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlipOptions, SOAP_TYPE_tt__EFlipOptions, sizeof(tt__EFlipOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlipOptions * SOAP_FMAC2 soap_instantiate_tt__EFlipOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EFlipOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlipOptions *p;
	size_t k = sizeof(tt__EFlipOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlipOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlipOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlipOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlipOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlipOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlipOptions(soap, tag ? tag : "tt:EFlipOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlipOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlipOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlipOptions * SOAP_FMAC4 soap_get_tt__EFlipOptions(struct soap *soap, tt__EFlipOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlipOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirectionOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTControlDirectionOptionsExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTControlDirectionOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirectionOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, int id, const tt__PTControlDirectionOptionsExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirectionOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, tt__PTControlDirectionOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirectionOptionsExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(tt__PTControlDirectionOptionsExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirectionOptionsExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirectionOptionsExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirectionOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(tt__PTControlDirectionOptionsExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirectionOptionsExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirectionOptionsExtension *p;
	size_t k = sizeof(tt__PTControlDirectionOptionsExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirectionOptionsExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirectionOptionsExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirectionOptionsExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirectionOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirectionOptionsExtension(soap, tag ? tag : "tt:PTControlDirectionOptionsExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirectionOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirectionOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirectionOptionsExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionOptionsExtension(struct soap *soap, tt__PTControlDirectionOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirectionOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTControlDirectionOptions::EFlip = NULL;
	this->tt__PTControlDirectionOptions::Reverse = NULL;
	this->tt__PTControlDirectionOptions::Extension = NULL;
}

void tt__PTControlDirectionOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlipOptions(soap, &this->tt__PTControlDirectionOptions::EFlip);
	soap_serialize_PointerTott__ReverseOptions(soap, &this->tt__PTControlDirectionOptions::Reverse);
	soap_serialize_PointerTott__PTControlDirectionOptionsExtension(soap, &this->tt__PTControlDirectionOptions::Extension);
#endif
}

int tt__PTControlDirectionOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirectionOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionOptions(struct soap *soap, const char *tag, int id, const tt__PTControlDirectionOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionOptions), type))
		return soap->error;
	if (soap_out_PointerTott__EFlipOptions(soap, "tt:EFlip", -1, &a->tt__PTControlDirectionOptions::EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__ReverseOptions(soap, "tt:Reverse", -1, &a->tt__PTControlDirectionOptions::Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionOptionsExtension(soap, "tt:Extension", -1, &a->tt__PTControlDirectionOptions::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirectionOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirectionOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirectionOptions * SOAP_FMAC4 soap_in_tt__PTControlDirectionOptions(struct soap *soap, const char *tag, tt__PTControlDirectionOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirectionOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(tt__PTControlDirectionOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirectionOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirectionOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EFlip1 = 1;
	size_t soap_flag_Reverse1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlipOptions(soap, "tt:EFlip", &a->tt__PTControlDirectionOptions::EFlip, "tt:EFlipOptions"))
				{	soap_flag_EFlip1--;
					continue;
				}
			}
			if (soap_flag_Reverse1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ReverseOptions(soap, "tt:Reverse", &a->tt__PTControlDirectionOptions::Reverse, "tt:ReverseOptions"))
				{	soap_flag_Reverse1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionOptionsExtension(soap, "tt:Extension", &a->tt__PTControlDirectionOptions::Extension, "tt:PTControlDirectionOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirectionOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionOptions, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(tt__PTControlDirectionOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionOptions * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirectionOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirectionOptions *p;
	size_t k = sizeof(tt__PTControlDirectionOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirectionOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirectionOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirectionOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirectionOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirectionOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirectionOptions(soap, tag ? tag : "tt:PTControlDirectionOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirectionOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirectionOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirectionOptions * SOAP_FMAC4 soap_get_tt__PTControlDirectionOptions(struct soap *soap, tt__PTControlDirectionOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationOptions2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZConfigurationOptions2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZConfigurationOptions2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationOptions2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions2(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationOptions2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationOptions2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationOptions2(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions2(struct soap *soap, const char *tag, tt__PTZConfigurationOptions2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationOptions2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(tt__PTZConfigurationOptions2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationOptions2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationOptions2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions2, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(tt__PTZConfigurationOptions2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationOptions2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationOptions2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationOptions2 *p;
	size_t k = sizeof(tt__PTZConfigurationOptions2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationOptions2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationOptions2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationOptions2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationOptions2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationOptions2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationOptions2(soap, tag ? tag : "tt:PTZConfigurationOptions2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationOptions2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationOptions2(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions2(struct soap *soap, tt__PTZConfigurationOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZConfigurationOptions::Spaces = NULL;
	this->tt__PTZConfigurationOptions::PTZTimeout = NULL;
	this->tt__PTZConfigurationOptions::PTControlDirection = NULL;
	this->tt__PTZConfigurationOptions::Extension = NULL;
	this->tt__PTZConfigurationOptions::PTZRamps = NULL;
}

void tt__PTZConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZSpaces(soap, &this->tt__PTZConfigurationOptions::Spaces);
	soap_serialize_PointerTott__DurationRange(soap, &this->tt__PTZConfigurationOptions::PTZTimeout);
	soap_serialize_PointerTott__PTControlDirectionOptions(soap, &this->tt__PTZConfigurationOptions::PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationOptions2(soap, &this->tt__PTZConfigurationOptions::Extension);
#endif
}

int tt__PTZConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationOptions *a, const char *type)
{
	if (((tt__PTZConfigurationOptions*)a)->PTZRamps)
	{	soap_set_attr(soap, "PTZRamps", soap_tt__IntAttrList2s(soap, *((tt__PTZConfigurationOptions*)a)->PTZRamps), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationOptions), type))
		return soap->error;
	if (!a->tt__PTZConfigurationOptions::Spaces)
	{	if (soap_element_empty(soap, "tt:Spaces", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpaces(soap, "tt:Spaces", -1, &a->tt__PTZConfigurationOptions::Spaces, ""))
		return soap->error;
	if (!a->tt__PTZConfigurationOptions::PTZTimeout)
	{	if (soap_element_empty(soap, "tt:PTZTimeout", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__DurationRange(soap, "tt:PTZTimeout", -1, &a->tt__PTZConfigurationOptions::PTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionOptions(soap, "tt:PTControlDirection", -1, &a->tt__PTZConfigurationOptions::PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationOptions2(soap, "tt:Extension", -1, &a->tt__PTZConfigurationOptions::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions * SOAP_FMAC4 soap_in_tt__PTZConfigurationOptions(struct soap *soap, const char *tag, tt__PTZConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(tt__PTZConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "PTZRamps", 1, 0);
		if (t)
		{
			if (!(((tt__PTZConfigurationOptions*)a)->PTZRamps = soap_new_tt__IntAttrList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__IntAttrList(soap, t, ((tt__PTZConfigurationOptions*)a)->PTZRamps))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	size_t soap_flag_Spaces1 = 1;
	size_t soap_flag_PTZTimeout1 = 1;
	size_t soap_flag_PTControlDirection1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Spaces1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpaces(soap, "tt:Spaces", &a->tt__PTZConfigurationOptions::Spaces, "tt:PTZSpaces"))
				{	soap_flag_Spaces1--;
					continue;
				}
			}
			if (soap_flag_PTZTimeout1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__DurationRange(soap, "tt:PTZTimeout", &a->tt__PTZConfigurationOptions::PTZTimeout, "tt:DurationRange"))
				{	soap_flag_PTZTimeout1--;
					continue;
				}
			}
			if (soap_flag_PTControlDirection1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionOptions(soap, "tt:PTControlDirection", &a->tt__PTZConfigurationOptions::PTControlDirection, "tt:PTControlDirectionOptions"))
				{	soap_flag_PTControlDirection1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationOptions2(soap, "tt:Extension", &a->tt__PTZConfigurationOptions::Extension, "tt:PTZConfigurationOptions2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZConfigurationOptions::Spaces || !a->tt__PTZConfigurationOptions::PTZTimeout))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationOptions, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(tt__PTZConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationOptions *p;
	size_t k = sizeof(tt__PTZConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationOptions(soap, tag ? tag : "tt:PTZConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions * SOAP_FMAC4 soap_get_tt__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__Reverse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReverseMode(soap, &this->tt__Reverse::Mode);
}

void tt__Reverse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__Reverse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Reverse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Reverse(struct soap *soap, const char *tag, int id, const tt__Reverse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Reverse), type))
		return soap->error;
	if (soap_out_tt__ReverseMode(soap, "tt:Mode", -1, &a->tt__Reverse::Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Reverse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__Reverse(soap, tag, this, type);
}

SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_in_tt__Reverse(struct soap *soap, const char *tag, tt__Reverse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Reverse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__Reverse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__Reverse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__ReverseMode(soap, "tt:Mode", &a->tt__Reverse::Mode, "tt:ReverseMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__Reverse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Reverse, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__Reverse * SOAP_FMAC2 soap_instantiate_tt__Reverse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Reverse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__Reverse *p;
	size_t k = sizeof(tt__Reverse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__Reverse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__Reverse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__Reverse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__Reverse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__Reverse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__Reverse(soap, tag ? tag : "tt:Reverse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Reverse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Reverse(soap, this, tag, type);
}

SOAP_FMAC3 tt__Reverse * SOAP_FMAC4 soap_get_tt__Reverse(struct soap *soap, tt__Reverse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__EFlip::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__EFlipMode(soap, &this->tt__EFlip::Mode);
}

void tt__EFlip::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__EFlip::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__EFlip(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EFlip(struct soap *soap, const char *tag, int id, const tt__EFlip *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EFlip), type))
		return soap->error;
	if (soap_out_tt__EFlipMode(soap, "tt:Mode", -1, &a->tt__EFlip::Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__EFlip::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__EFlip(soap, tag, this, type);
}

SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_in_tt__EFlip(struct soap *soap, const char *tag, tt__EFlip *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__EFlip*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__EFlip)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__EFlip *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Mode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__EFlipMode(soap, "tt:Mode", &a->tt__EFlip::Mode, "tt:EFlipMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__EFlip *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EFlip, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__EFlip * SOAP_FMAC2 soap_instantiate_tt__EFlip(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__EFlip(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__EFlip *p;
	size_t k = sizeof(tt__EFlip);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__EFlip, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__EFlip);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__EFlip, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__EFlip location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__EFlip::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__EFlip(soap, tag ? tag : "tt:EFlip", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__EFlip::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__EFlip(soap, this, tag, type);
}

SOAP_FMAC3 tt__EFlip * SOAP_FMAC4 soap_get_tt__EFlip(struct soap *soap, tt__EFlip *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirectionExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTControlDirectionExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTControlDirectionExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirectionExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, const tt__PTControlDirectionExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirectionExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirectionExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirectionExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_in_tt__PTControlDirectionExtension(struct soap *soap, const char *tag, tt__PTControlDirectionExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirectionExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirectionExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirectionExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirectionExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirectionExtension, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirectionExtension * SOAP_FMAC2 soap_instantiate_tt__PTControlDirectionExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirectionExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirectionExtension *p;
	size_t k = sizeof(tt__PTControlDirectionExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirectionExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirectionExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirectionExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirectionExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirectionExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirectionExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirectionExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirectionExtension * SOAP_FMAC4 soap_get_tt__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTControlDirection::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTControlDirection::EFlip = NULL;
	this->tt__PTControlDirection::Reverse = NULL;
	this->tt__PTControlDirection::Extension = NULL;
}

void tt__PTControlDirection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__EFlip(soap, &this->tt__PTControlDirection::EFlip);
	soap_serialize_PointerTott__Reverse(soap, &this->tt__PTControlDirection::Reverse);
	soap_serialize_PointerTott__PTControlDirectionExtension(soap, &this->tt__PTControlDirection::Extension);
#endif
}

int tt__PTControlDirection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTControlDirection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTControlDirection(struct soap *soap, const char *tag, int id, const tt__PTControlDirection *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTControlDirection), type))
		return soap->error;
	if (soap_out_PointerTott__EFlip(soap, "tt:EFlip", -1, &a->tt__PTControlDirection::EFlip, ""))
		return soap->error;
	if (soap_out_PointerTott__Reverse(soap, "tt:Reverse", -1, &a->tt__PTControlDirection::Reverse, ""))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", -1, &a->tt__PTControlDirection::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTControlDirection::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTControlDirection(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_in_tt__PTControlDirection(struct soap *soap, const char *tag, tt__PTControlDirection *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTControlDirection*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTControlDirection)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTControlDirection *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_EFlip1 = 1;
	size_t soap_flag_Reverse1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EFlip1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__EFlip(soap, "tt:EFlip", &a->tt__PTControlDirection::EFlip, "tt:EFlip"))
				{	soap_flag_EFlip1--;
					continue;
				}
			}
			if (soap_flag_Reverse1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__Reverse(soap, "tt:Reverse", &a->tt__PTControlDirection::Reverse, "tt:Reverse"))
				{	soap_flag_Reverse1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirectionExtension(soap, "tt:Extension", &a->tt__PTControlDirection::Extension, "tt:PTControlDirectionExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTControlDirection *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTControlDirection, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTControlDirection * SOAP_FMAC2 soap_instantiate_tt__PTControlDirection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTControlDirection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTControlDirection *p;
	size_t k = sizeof(tt__PTControlDirection);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTControlDirection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTControlDirection);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTControlDirection, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTControlDirection location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTControlDirection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTControlDirection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTControlDirection(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTControlDirection * SOAP_FMAC4 soap_get_tt__PTControlDirection(struct soap *soap, tt__PTControlDirection *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZConfigurationExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension2(struct soap *soap, const char *tag, tt__PTZConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension2, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationExtension2 *p;
	size_t k = sizeof(tt__PTZConfigurationExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZConfigurationExtension::PTControlDirection = NULL;
	this->tt__PTZConfigurationExtension::Extension = NULL;
}

void tt__PTZConfigurationExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTControlDirection(soap, &this->tt__PTZConfigurationExtension::PTControlDirection);
	soap_serialize_PointerTott__PTZConfigurationExtension2(soap, &this->tt__PTZConfigurationExtension::Extension);
#endif
}

int tt__PTZConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__PTZConfigurationExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfigurationExtension), type))
		return soap->error;
	if (soap_out_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", -1, &a->tt__PTZConfigurationExtension::PTControlDirection, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", -1, &a->tt__PTZConfigurationExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_in_tt__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfigurationExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfigurationExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfigurationExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PTControlDirection1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTControlDirection1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTControlDirection(soap, "tt:PTControlDirection", &a->tt__PTZConfigurationExtension::PTControlDirection, "tt:PTControlDirection"))
				{	soap_flag_PTControlDirection1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension2(soap, "tt:Extension", &a->tt__PTZConfigurationExtension::Extension, "tt:PTZConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfigurationExtension, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__PTZConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfigurationExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfigurationExtension *p;
	size_t k = sizeof(tt__PTZConfigurationExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfigurationExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfigurationExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfigurationExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfigurationExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension * SOAP_FMAC4 soap_get_tt__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace = NULL;
	this->tt__PTZConfiguration::DefaultPTZSpeed = NULL;
	this->tt__PTZConfiguration::DefaultPTZTimeout = NULL;
	this->tt__PTZConfiguration::PanTiltLimits = NULL;
	this->tt__PTZConfiguration::ZoomLimits = NULL;
	this->tt__PTZConfiguration::Extension = NULL;
	this->tt__PTZConfiguration::MoveRamp = NULL;
	this->tt__PTZConfiguration::PresetRamp = NULL;
	this->tt__PTZConfiguration::PresetTourRamp = NULL;
}

void tt__PTZConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZConfiguration::NodeToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->tt__PTZConfiguration::NodeToken);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace);
	soap_serialize_PointerToxsd__anyURI(soap, &this->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->tt__PTZConfiguration::DefaultPTZSpeed);
	soap_serialize_PointerToxsd__duration(soap, &this->tt__PTZConfiguration::DefaultPTZTimeout);
	soap_serialize_PointerTott__PanTiltLimits(soap, &this->tt__PTZConfiguration::PanTiltLimits);
	soap_serialize_PointerTott__ZoomLimits(soap, &this->tt__PTZConfiguration::ZoomLimits);
	soap_serialize_PointerTott__PTZConfigurationExtension(soap, &this->tt__PTZConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
#endif
}

int tt__PTZConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZConfiguration(struct soap *soap, const char *tag, int id, const tt__PTZConfiguration *a, const char *type)
{
	if (((tt__PTZConfiguration*)a)->MoveRamp)
	{	soap_set_attr(soap, "MoveRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->MoveRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->PresetRamp)
	{	soap_set_attr(soap, "PresetRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->PresetRamp), 1);
	}
	if (((tt__PTZConfiguration*)a)->PresetTourRamp)
	{	soap_set_attr(soap, "PresetTourRamp", soap_int2s(soap, *((tt__PTZConfiguration*)a)->PresetTourRamp), 1);
	}
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZConfiguration), type ? type : "tt:PTZConfiguration"))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tt:NodeToken", -1, &a->tt__PTZConfiguration::NodeToken, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", -1, &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", -1, &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", -1, &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", -1, &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", -1, &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", -1, &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", -1, &a->tt__PTZConfiguration::DefaultPTZSpeed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", -1, &a->tt__PTZConfiguration::DefaultPTZTimeout, ""))
		return soap->error;
	if (soap_out_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", -1, &a->tt__PTZConfiguration::PanTiltLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", -1, &a->tt__PTZConfiguration::ZoomLimits, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", -1, &a->tt__PTZConfiguration::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_in_tt__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "MoveRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->MoveRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->MoveRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PresetRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->PresetRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->PresetRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "PresetTourRamp", 5, 0);
		if (t)
		{
			if (!(((tt__PTZConfiguration*)a)->PresetTourRamp = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, ((tt__PTZConfiguration*)a)->PresetTourRamp))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_NodeToken1 = 1;
	size_t soap_flag_DefaultAbsolutePantTiltPositionSpace1 = 1;
	size_t soap_flag_DefaultAbsoluteZoomPositionSpace1 = 1;
	size_t soap_flag_DefaultRelativePanTiltTranslationSpace1 = 1;
	size_t soap_flag_DefaultRelativeZoomTranslationSpace1 = 1;
	size_t soap_flag_DefaultContinuousPanTiltVelocitySpace1 = 1;
	size_t soap_flag_DefaultContinuousZoomVelocitySpace1 = 1;
	size_t soap_flag_DefaultPTZSpeed1 = 1;
	size_t soap_flag_DefaultPTZTimeout1 = 1;
	size_t soap_flag_PanTiltLimits1 = 1;
	size_t soap_flag_ZoomLimits1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			}
			if (soap_flag_NodeToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tt:NodeToken", &a->tt__PTZConfiguration::NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken1--;
					continue;
				}
			}
			if (soap_flag_DefaultAbsolutePantTiltPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsolutePantTiltPositionSpace", &a->tt__PTZConfiguration::DefaultAbsolutePantTiltPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsolutePantTiltPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultAbsoluteZoomPositionSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultAbsoluteZoomPositionSpace", &a->tt__PTZConfiguration::DefaultAbsoluteZoomPositionSpace, "xsd:anyURI"))
				{	soap_flag_DefaultAbsoluteZoomPositionSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultRelativePanTiltTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativePanTiltTranslationSpace", &a->tt__PTZConfiguration::DefaultRelativePanTiltTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativePanTiltTranslationSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultRelativeZoomTranslationSpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultRelativeZoomTranslationSpace", &a->tt__PTZConfiguration::DefaultRelativeZoomTranslationSpace, "xsd:anyURI"))
				{	soap_flag_DefaultRelativeZoomTranslationSpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultContinuousPanTiltVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousPanTiltVelocitySpace", &a->tt__PTZConfiguration::DefaultContinuousPanTiltVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousPanTiltVelocitySpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultContinuousZoomVelocitySpace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__anyURI(soap, "tt:DefaultContinuousZoomVelocitySpace", &a->tt__PTZConfiguration::DefaultContinuousZoomVelocitySpace, "xsd:anyURI"))
				{	soap_flag_DefaultContinuousZoomVelocitySpace1--;
					continue;
				}
			}
			if (soap_flag_DefaultPTZSpeed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tt:DefaultPTZSpeed", &a->tt__PTZConfiguration::DefaultPTZSpeed, "tt:PTZSpeed"))
				{	soap_flag_DefaultPTZSpeed1--;
					continue;
				}
			}
			if (soap_flag_DefaultPTZTimeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tt:DefaultPTZTimeout", &a->tt__PTZConfiguration::DefaultPTZTimeout, "xsd:duration"))
				{	soap_flag_DefaultPTZTimeout1--;
					continue;
				}
			}
			if (soap_flag_PanTiltLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PanTiltLimits(soap, "tt:PanTiltLimits", &a->tt__PTZConfiguration::PanTiltLimits, "tt:PanTiltLimits"))
				{	soap_flag_PanTiltLimits1--;
					continue;
				}
			}
			if (soap_flag_ZoomLimits1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__ZoomLimits(soap, "tt:ZoomLimits", &a->tt__PTZConfiguration::ZoomLimits, "tt:ZoomLimits"))
				{	soap_flag_ZoomLimits1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationExtension(soap, "tt:Extension", &a->tt__PTZConfiguration::Extension, "tt:PTZConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_NodeToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZConfiguration, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZConfiguration * SOAP_FMAC2 soap_instantiate_tt__PTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZConfiguration *p;
	size_t k = sizeof(tt__PTZConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZConfiguration * SOAP_FMAC4 soap_get_tt__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSupportedExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZPresetTourSupportedExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZPresetTourSupportedExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSupportedExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSupportedExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSupportedExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_in_tt__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, tt__PTZPresetTourSupportedExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSupportedExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(tt__PTZPresetTourSupportedExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSupportedExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSupportedExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSupportedExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(tt__PTZPresetTourSupportedExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSupportedExtension * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupportedExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSupportedExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSupportedExtension *p;
	size_t k = sizeof(tt__PTZPresetTourSupportedExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSupportedExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSupportedExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSupportedExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSupportedExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSupportedExtension(soap, tag ? tag : "tt:PTZPresetTourSupportedExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSupportedExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSupportedExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSupportedExtension * SOAP_FMAC4 soap_get_tt__PTZPresetTourSupportedExtension(struct soap *soap, tt__PTZPresetTourSupportedExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZPresetTourSupported::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->tt__PTZPresetTourSupported::MaximumNumberOfPresetTours);
	soap_default_std__vectorTemplateOftt__PTZPresetTourOperation(soap, &this->tt__PTZPresetTourSupported::PTZPresetTourOperation);
	this->tt__PTZPresetTourSupported::Extension = NULL;
}

void tt__PTZPresetTourSupported::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__PTZPresetTourSupported::MaximumNumberOfPresetTours, SOAP_TYPE_int);
	soap_serialize_std__vectorTemplateOftt__PTZPresetTourOperation(soap, &this->tt__PTZPresetTourSupported::PTZPresetTourOperation);
	soap_serialize_PointerTott__PTZPresetTourSupportedExtension(soap, &this->tt__PTZPresetTourSupported::Extension);
#endif
}

int tt__PTZPresetTourSupported::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZPresetTourSupported(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZPresetTourSupported(struct soap *soap, const char *tag, int id, const tt__PTZPresetTourSupported *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZPresetTourSupported), type))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresetTours", -1, &a->tt__PTZPresetTourSupported::MaximumNumberOfPresetTours, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__PTZPresetTourOperation(soap, "tt:PTZPresetTourOperation", -1, &a->tt__PTZPresetTourSupported::PTZPresetTourOperation, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSupportedExtension(soap, "tt:Extension", -1, &a->tt__PTZPresetTourSupported::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZPresetTourSupported::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZPresetTourSupported(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZPresetTourSupported * SOAP_FMAC4 soap_in_tt__PTZPresetTourSupported(struct soap *soap, const char *tag, tt__PTZPresetTourSupported *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZPresetTourSupported*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(tt__PTZPresetTourSupported), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZPresetTourSupported)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZPresetTourSupported *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_MaximumNumberOfPresetTours1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaximumNumberOfPresetTours1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfPresetTours", &a->tt__PTZPresetTourSupported::MaximumNumberOfPresetTours, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresetTours1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__PTZPresetTourOperation(soap, "tt:PTZPresetTourOperation", &a->tt__PTZPresetTourSupported::PTZPresetTourOperation, "tt:PTZPresetTourOperation"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSupportedExtension(soap, "tt:Extension", &a->tt__PTZPresetTourSupported::Extension, "tt:PTZPresetTourSupportedExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaximumNumberOfPresetTours1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZPresetTourSupported *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZPresetTourSupported, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(tt__PTZPresetTourSupported), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZPresetTourSupported * SOAP_FMAC2 soap_instantiate_tt__PTZPresetTourSupported(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZPresetTourSupported(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZPresetTourSupported *p;
	size_t k = sizeof(tt__PTZPresetTourSupported);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZPresetTourSupported, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZPresetTourSupported);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZPresetTourSupported, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZPresetTourSupported location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZPresetTourSupported::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZPresetTourSupported(soap, tag ? tag : "tt:PTZPresetTourSupported", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZPresetTourSupported::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZPresetTourSupported(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZPresetTourSupported * SOAP_FMAC4 soap_get_tt__PTZPresetTourSupported(struct soap *soap, tt__PTZPresetTourSupported *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZPresetTourSupported(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZNodeExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void tt__PTZNodeExtension2::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__PTZNodeExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZNodeExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension2(struct soap *soap, const char *tag, int id, const tt__PTZNodeExtension2 *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension2), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZNodeExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZNodeExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZNodeExtension2 * SOAP_FMAC4 soap_in_tt__PTZNodeExtension2(struct soap *soap, const char *tag, tt__PTZNodeExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZNodeExtension2*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(tt__PTZNodeExtension2), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZNodeExtension2)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZNodeExtension2 *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZNodeExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension2, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(tt__PTZNodeExtension2), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZNodeExtension2 * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZNodeExtension2(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZNodeExtension2 *p;
	size_t k = sizeof(tt__PTZNodeExtension2);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZNodeExtension2, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZNodeExtension2);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZNodeExtension2, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZNodeExtension2 location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZNodeExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZNodeExtension2(soap, tag ? tag : "tt:PTZNodeExtension2", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZNodeExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZNodeExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZNodeExtension2 * SOAP_FMAC4 soap_get_tt__PTZNodeExtension2(struct soap *soap, tt__PTZNodeExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZNodeExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__PTZNodeExtension::SupportedPresetTour = NULL;
	this->tt__PTZNodeExtension::Extension = NULL;
}

void tt__PTZNodeExtension::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourSupported(soap, &this->tt__PTZNodeExtension::SupportedPresetTour);
	soap_serialize_PointerTott__PTZNodeExtension2(soap, &this->tt__PTZNodeExtension::Extension);
#endif
}

int tt__PTZNodeExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZNodeExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNodeExtension(struct soap *soap, const char *tag, int id, const tt__PTZNodeExtension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNodeExtension), type))
		return soap->error;
	if (soap_out_PointerTott__PTZPresetTourSupported(soap, "tt:SupportedPresetTour", -1, &a->tt__PTZNodeExtension::SupportedPresetTour, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZNodeExtension2(soap, "tt:Extension", -1, &a->tt__PTZNodeExtension::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZNodeExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZNodeExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZNodeExtension * SOAP_FMAC4 soap_in_tt__PTZNodeExtension(struct soap *soap, const char *tag, tt__PTZNodeExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZNodeExtension*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZNodeExtension)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZNodeExtension *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_SupportedPresetTour1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SupportedPresetTour1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourSupported(soap, "tt:SupportedPresetTour", &a->tt__PTZNodeExtension::SupportedPresetTour, "tt:PTZPresetTourSupported"))
				{	soap_flag_SupportedPresetTour1--;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNodeExtension2(soap, "tt:Extension", &a->tt__PTZNodeExtension::Extension, "tt:PTZNodeExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__PTZNodeExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNodeExtension, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZNodeExtension * SOAP_FMAC2 soap_instantiate_tt__PTZNodeExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZNodeExtension(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZNodeExtension *p;
	size_t k = sizeof(tt__PTZNodeExtension);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZNodeExtension, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZNodeExtension);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZNodeExtension, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZNodeExtension location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZNodeExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZNodeExtension(soap, tag ? tag : "tt:PTZNodeExtension", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZNodeExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZNodeExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZNodeExtension * SOAP_FMAC4 soap_get_tt__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__PTZNode::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	this->tt__PTZNode::Name = NULL;
	this->tt__PTZNode::SupportedPTZSpaces = NULL;
	soap_default_int(soap, &this->tt__PTZNode::MaximumNumberOfPresets);
	soap_default_bool(soap, &this->tt__PTZNode::HomeSupported);
	soap_default_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__PTZNode::AuxiliaryCommands);
	this->tt__PTZNode::Extension = NULL;
	this->tt__PTZNode::FixedHomePosition = NULL;
	this->tt__PTZNode::GeoMove = NULL;
}

void tt__PTZNode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__Name(soap, &this->tt__PTZNode::Name);
	soap_serialize_PointerTott__PTZSpaces(soap, &this->tt__PTZNode::SupportedPTZSpaces);
	soap_embedded(soap, &this->tt__PTZNode::MaximumNumberOfPresets, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__PTZNode::HomeSupported, SOAP_TYPE_bool);
	soap_serialize_std__vectorTemplateOftt__AuxiliaryData(soap, &this->tt__PTZNode::AuxiliaryCommands);
	soap_serialize_PointerTott__PTZNodeExtension(soap, &this->tt__PTZNode::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
#endif
}

int tt__PTZNode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__PTZNode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNode(struct soap *soap, const char *tag, int id, const tt__PTZNode *a, const char *type)
{
	if (((tt__PTZNode*)a)->FixedHomePosition)
	{	soap_set_attr(soap, "FixedHomePosition", soap_bool2s(soap, *((tt__PTZNode*)a)->FixedHomePosition), 1);
	}
	if (((tt__PTZNode*)a)->GeoMove)
	{	soap_set_attr(soap, "GeoMove", soap_bool2s(soap, *((tt__PTZNode*)a)->GeoMove), 1);
	}
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNode), type ? type : "tt:PTZNode"))
		return soap->error;
	if (soap_out_PointerTott__Name(soap, "tt:Name", -1, &a->tt__PTZNode::Name, ""))
		return soap->error;
	if (!a->tt__PTZNode::SupportedPTZSpaces)
	{	if (soap_element_empty(soap, "tt:SupportedPTZSpaces", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", -1, &a->tt__PTZNode::SupportedPTZSpaces, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresets", -1, &a->tt__PTZNode::MaximumNumberOfPresets, ""))
		return soap->error;
	if (soap_out_bool(soap, "tt:HomeSupported", -1, &a->tt__PTZNode::HomeSupported, ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, &a->tt__PTZNode::AuxiliaryCommands, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZNodeExtension(soap, "tt:Extension", -1, &a->tt__PTZNode::Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__PTZNode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__PTZNode(soap, tag, this, type);
}

SOAP_FMAC3 tt__PTZNode * SOAP_FMAC4 soap_in_tt__PTZNode(struct soap *soap, const char *tag, tt__PTZNode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__PTZNode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNode, sizeof(tt__PTZNode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__PTZNode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__PTZNode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "FixedHomePosition", 5, 0);
		if (t)
		{
			if (!(((tt__PTZNode*)a)->FixedHomePosition = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__PTZNode*)a)->FixedHomePosition))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GeoMove", 5, 0);
		if (t)
		{
			if (!(((tt__PTZNode*)a)->GeoMove = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__PTZNode*)a)->GeoMove))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_SupportedPTZSpaces1 = 1;
	size_t soap_flag_MaximumNumberOfPresets1 = 1;
	size_t soap_flag_HomeSupported1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__Name(soap, "tt:Name", &a->tt__PTZNode::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_SupportedPTZSpaces1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", &a->tt__PTZNode::SupportedPTZSpaces, "tt:PTZSpaces"))
				{	soap_flag_SupportedPTZSpaces1--;
					continue;
				}
			}
			if (soap_flag_MaximumNumberOfPresets1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:MaximumNumberOfPresets", &a->tt__PTZNode::MaximumNumberOfPresets, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresets1--;
					continue;
				}
			}
			if (soap_flag_HomeSupported1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tt:HomeSupported", &a->tt__PTZNode::HomeSupported, "xsd:boolean"))
				{	soap_flag_HomeSupported1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOftt__AuxiliaryData(soap, "tt:AuxiliaryCommands", &a->tt__PTZNode::AuxiliaryCommands, "tt:AuxiliaryData"))
					continue;
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNodeExtension(soap, "tt:Extension", &a->tt__PTZNode::Extension, "tt:PTZNodeExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->tt__PTZNode::SupportedPTZSpaces || soap_flag_MaximumNumberOfPresets1 > 0 || soap_flag_HomeSupported1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNode, SOAP_TYPE_tt__PTZNode, sizeof(tt__PTZNode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__PTZNode * SOAP_FMAC2 soap_instantiate_tt__PTZNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__PTZNode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__PTZNode *p;
	size_t k = sizeof(tt__PTZNode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__PTZNode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__PTZNode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__PTZNode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__PTZNode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__PTZNode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__PTZNode(soap, tag ? tag : "tt:PTZNode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__PTZNode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__PTZNode(soap, this, tag, type);
}

SOAP_FMAC3 tt__PTZNode * SOAP_FMAC4 soap_get_tt__PTZNode(struct soap *soap, tt__PTZNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__ConfigurationEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
}

void tt__ConfigurationEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__ConfigurationEntity::Name, SOAP_TYPE_tt__Name);
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
#endif
}

int tt__ConfigurationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigurationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const tt__ConfigurationEntity *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__ConfigurationEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &a->tt__ConfigurationEntity::UseCount, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigurationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__ConfigurationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, tt__ConfigurationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigurationEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__ConfigurationEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__ConfigurationEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__ConfigurationEntity*)a)->token))
		return NULL;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_UseCount1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__Name(soap, "tt:Name", &a->tt__ConfigurationEntity::Name, "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			}
			if (soap_flag_UseCount1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_int(soap, "tt:UseCount", &a->tt__ConfigurationEntity::UseCount, "xsd:int"))
				{	soap_flag_UseCount1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_UseCount1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigurationEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZConfiguration"))
		return soap_instantiate_tt__PTZConfiguration(soap, n, NULL, NULL, size);
	tt__ConfigurationEntity *p;
	size_t k = sizeof(tt__ConfigurationEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__ConfigurationEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__ConfigurationEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__ConfigurationEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__ConfigurationEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__ConfigurationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__ConfigurationEntity(soap, tag ? tag : "tt:ConfigurationEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigurationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigurationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DurationRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Max);
}

void tt__DurationRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__DurationRange::Min, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_embedded(soap, &this->tt__DurationRange::Max, SOAP_TYPE_xsd__duration);
	soap_serialize_xsd__duration(soap, &this->tt__DurationRange::Max);
#endif
}

int tt__DurationRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DurationRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const tt__DurationRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Min", -1, &a->tt__DurationRange::Min, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Max", -1, &a->tt__DurationRange::Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DurationRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DurationRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, tt__DurationRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DurationRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DurationRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DurationRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:Min", &a->tt__DurationRange::Min, "xsd:duration"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_xsd__duration(soap, "tt:Max", &a->tt__DurationRange::Max, "xsd:duration"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DurationRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__DurationRange *p;
	size_t k = sizeof(tt__DurationRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DurationRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DurationRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DurationRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DurationRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DurationRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DurationRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DurationRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__FloatRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_float(soap, &this->tt__FloatRange::Min);
	soap_default_float(soap, &this->tt__FloatRange::Max);
}

void tt__FloatRange::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->tt__FloatRange::Min, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FloatRange::Max, SOAP_TYPE_float);
#endif
}

int tt__FloatRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FloatRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const tt__FloatRange *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), type))
		return soap->error;
	if (soap_out_float(soap, "tt:Min", -1, &a->tt__FloatRange::Min, ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &a->tt__FloatRange::Max, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FloatRange::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__FloatRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, tt__FloatRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FloatRange*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__FloatRange)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__FloatRange *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Min", &a->tt__FloatRange::Min, "xsd:float"))
				{	soap_flag_Min1--;
					continue;
				}
			}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_float(soap, "tt:Max", &a->tt__FloatRange::Max, "xsd:float"))
				{	soap_flag_Max1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FloatRange(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tt__FloatRange *p;
	size_t k = sizeof(tt__FloatRange);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__FloatRange, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__FloatRange);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__FloatRange, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__FloatRange location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__FloatRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FloatRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FloatRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tt__DeviceEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
}

void tt__DeviceEntity::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tt__DeviceEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const tt__DeviceEntity *a, const char *type)
{
	soap_set_attr(soap, "token", soap_tt__ReferenceToken2s(soap, ((tt__DeviceEntity*)a)->token), 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DeviceEntity), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DeviceEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tt__DeviceEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, tt__DeviceEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DeviceEntity*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tt__DeviceEntity)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tt__DeviceEntity *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap_s2tt__ReferenceToken(soap, soap_attr_value(soap, "token", 1, 1), &((tt__DeviceEntity*)a)->token))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DeviceEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DeviceEntity, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceEntity(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	if (soap && type && !soap_match_tag(soap, type, "tt:PTZNode"))
		return soap_instantiate_tt__PTZNode(soap, n, NULL, NULL, size);
	tt__DeviceEntity *p;
	size_t k = sizeof(tt__DeviceEntity);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tt__DeviceEntity, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tt__DeviceEntity);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tt__DeviceEntity, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tt__DeviceEntity location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tt__DeviceEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tt__DeviceEntity(soap, tag ? tag : "tt:DeviceEntity", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__MoveAndStartTrackingResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__MoveAndStartTrackingResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__MoveAndStartTrackingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__MoveAndStartTrackingResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__MoveAndStartTrackingResponse(struct soap *soap, const char *tag, int id, const _tptz__MoveAndStartTrackingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__MoveAndStartTrackingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__MoveAndStartTrackingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__MoveAndStartTrackingResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__MoveAndStartTrackingResponse * SOAP_FMAC4 soap_in__tptz__MoveAndStartTrackingResponse(struct soap *soap, const char *tag, _tptz__MoveAndStartTrackingResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__MoveAndStartTrackingResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__MoveAndStartTrackingResponse, sizeof(_tptz__MoveAndStartTrackingResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__MoveAndStartTrackingResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__MoveAndStartTrackingResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__MoveAndStartTrackingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__MoveAndStartTrackingResponse, SOAP_TYPE__tptz__MoveAndStartTrackingResponse, sizeof(_tptz__MoveAndStartTrackingResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__MoveAndStartTrackingResponse * SOAP_FMAC2 soap_instantiate__tptz__MoveAndStartTrackingResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__MoveAndStartTrackingResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__MoveAndStartTrackingResponse *p;
	size_t k = sizeof(_tptz__MoveAndStartTrackingResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__MoveAndStartTrackingResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__MoveAndStartTrackingResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__MoveAndStartTrackingResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__MoveAndStartTrackingResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__MoveAndStartTrackingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__MoveAndStartTrackingResponse(soap, tag ? tag : "tptz:MoveAndStartTrackingResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__MoveAndStartTrackingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__MoveAndStartTrackingResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__MoveAndStartTrackingResponse * SOAP_FMAC4 soap_get__tptz__MoveAndStartTrackingResponse(struct soap *soap, _tptz__MoveAndStartTrackingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__MoveAndStartTrackingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__MoveAndStartTracking::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__MoveAndStartTracking::ProfileToken);
	this->_tptz__MoveAndStartTracking::PresetToken = NULL;
	this->_tptz__MoveAndStartTracking::GeoLocation = NULL;
	this->_tptz__MoveAndStartTracking::TargetPosition = NULL;
	this->_tptz__MoveAndStartTracking::Speed = NULL;
	this->_tptz__MoveAndStartTracking::ObjectID = NULL;
}

void _tptz__MoveAndStartTracking::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__MoveAndStartTracking::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__MoveAndStartTracking::ProfileToken);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->_tptz__MoveAndStartTracking::PresetToken);
	soap_serialize_PointerTott__GeoLocation(soap, &this->_tptz__MoveAndStartTracking::GeoLocation);
	soap_serialize_PointerTott__PTZVector(soap, &this->_tptz__MoveAndStartTracking::TargetPosition);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->_tptz__MoveAndStartTracking::Speed);
	soap_serialize_PointerToxsd__integer(soap, &this->_tptz__MoveAndStartTracking::ObjectID);
#endif
}

int _tptz__MoveAndStartTracking::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__MoveAndStartTracking(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__MoveAndStartTracking(struct soap *soap, const char *tag, int id, const _tptz__MoveAndStartTracking *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__MoveAndStartTracking), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__MoveAndStartTracking::ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tptz:PresetToken", -1, &a->_tptz__MoveAndStartTracking::PresetToken, ""))
		return soap->error;
	if (soap_out_PointerTott__GeoLocation(soap, "tptz:GeoLocation", -1, &a->_tptz__MoveAndStartTracking::GeoLocation, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZVector(soap, "tptz:TargetPosition", -1, &a->_tptz__MoveAndStartTracking::TargetPosition, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->_tptz__MoveAndStartTracking::Speed, ""))
		return soap->error;
	if (soap_out_PointerToxsd__integer(soap, "tptz:ObjectID", -1, &a->_tptz__MoveAndStartTracking::ObjectID, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__MoveAndStartTracking::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__MoveAndStartTracking(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__MoveAndStartTracking * SOAP_FMAC4 soap_in__tptz__MoveAndStartTracking(struct soap *soap, const char *tag, _tptz__MoveAndStartTracking *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__MoveAndStartTracking*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__MoveAndStartTracking, sizeof(_tptz__MoveAndStartTracking), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__MoveAndStartTracking)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__MoveAndStartTracking *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetToken1 = 1;
	size_t soap_flag_GeoLocation1 = 1;
	size_t soap_flag_TargetPosition1 = 1;
	size_t soap_flag_Speed1 = 1;
	size_t soap_flag_ObjectID1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__MoveAndStartTracking::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tptz:PresetToken", &a->_tptz__MoveAndStartTracking::PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken1--;
					continue;
				}
			}
			if (soap_flag_GeoLocation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoLocation(soap, "tptz:GeoLocation", &a->_tptz__MoveAndStartTracking::GeoLocation, "tt:GeoLocation"))
				{	soap_flag_GeoLocation1--;
					continue;
				}
			}
			if (soap_flag_TargetPosition1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tptz:TargetPosition", &a->_tptz__MoveAndStartTracking::TargetPosition, "tt:PTZVector"))
				{	soap_flag_TargetPosition1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->_tptz__MoveAndStartTracking::Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_ObjectID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__integer(soap, "tptz:ObjectID", &a->_tptz__MoveAndStartTracking::ObjectID, "xsd:integer"))
				{	soap_flag_ObjectID1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__MoveAndStartTracking *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__MoveAndStartTracking, SOAP_TYPE__tptz__MoveAndStartTracking, sizeof(_tptz__MoveAndStartTracking), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__MoveAndStartTracking * SOAP_FMAC2 soap_instantiate__tptz__MoveAndStartTracking(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__MoveAndStartTracking(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__MoveAndStartTracking *p;
	size_t k = sizeof(_tptz__MoveAndStartTracking);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__MoveAndStartTracking, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__MoveAndStartTracking);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__MoveAndStartTracking, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__MoveAndStartTracking location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__MoveAndStartTracking::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__MoveAndStartTracking(soap, tag ? tag : "tptz:MoveAndStartTracking", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__MoveAndStartTracking::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__MoveAndStartTracking(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__MoveAndStartTracking * SOAP_FMAC4 soap_get__tptz__MoveAndStartTracking(struct soap *soap, _tptz__MoveAndStartTracking *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__MoveAndStartTracking(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetCompatibleConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, &this->_tptz__GetCompatibleConfigurationsResponse::PTZConfiguration);
}

void _tptz__GetCompatibleConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, &this->_tptz__GetCompatibleConfigurationsResponse::PTZConfiguration);
#endif
}

int _tptz__GetCompatibleConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetCompatibleConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tptz__GetCompatibleConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "tptz:PTZConfiguration");
	if (soap_out_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->_tptz__GetCompatibleConfigurationsResponse::PTZConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetCompatibleConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetCompatibleConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC4 soap_in__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, const char *tag, _tptz__GetCompatibleConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetCompatibleConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(_tptz__GetCompatibleConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetCompatibleConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->_tptz__GetCompatibleConfigurationsResponse::PTZConfiguration, "tt:PTZConfiguration"))
					continue;
			}
			soap_check_result(soap, "tptz:PTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GetCompatibleConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, sizeof(_tptz__GetCompatibleConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetCompatibleConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetCompatibleConfigurationsResponse *p;
	size_t k = sizeof(_tptz__GetCompatibleConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetCompatibleConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetCompatibleConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetCompatibleConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetCompatibleConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetCompatibleConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetCompatibleConfigurationsResponse(soap, tag ? tag : "tptz:GetCompatibleConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetCompatibleConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetCompatibleConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetCompatibleConfigurationsResponse * SOAP_FMAC4 soap_get__tptz__GetCompatibleConfigurationsResponse(struct soap *soap, _tptz__GetCompatibleConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetCompatibleConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetCompatibleConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetCompatibleConfigurations::ProfileToken);
}

void _tptz__GetCompatibleConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetCompatibleConfigurations::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetCompatibleConfigurations::ProfileToken);
#endif
}

int _tptz__GetCompatibleConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetCompatibleConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, int id, const _tptz__GetCompatibleConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetCompatibleConfigurations), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GetCompatibleConfigurations::ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetCompatibleConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetCompatibleConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_in__tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, _tptz__GetCompatibleConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetCompatibleConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(_tptz__GetCompatibleConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetCompatibleConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetCompatibleConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GetCompatibleConfigurations::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetCompatibleConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetCompatibleConfigurations, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(_tptz__GetCompatibleConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetCompatibleConfigurations * SOAP_FMAC2 soap_instantiate__tptz__GetCompatibleConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetCompatibleConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetCompatibleConfigurations *p;
	size_t k = sizeof(_tptz__GetCompatibleConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetCompatibleConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetCompatibleConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetCompatibleConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetCompatibleConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetCompatibleConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetCompatibleConfigurations(soap, tag ? tag : "tptz:GetCompatibleConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetCompatibleConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetCompatibleConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_get__tptz__GetCompatibleConfigurations(struct soap *soap, _tptz__GetCompatibleConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetCompatibleConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__RemovePresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__RemovePresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__RemovePresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__RemovePresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, int id, const _tptz__RemovePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__RemovePresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__RemovePresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_in__tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, _tptz__RemovePresetTourResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__RemovePresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(_tptz__RemovePresetTourResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__RemovePresetTourResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__RemovePresetTourResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__RemovePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTourResponse, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(_tptz__RemovePresetTourResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__RemovePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__RemovePresetTourResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__RemovePresetTourResponse *p;
	size_t k = sizeof(_tptz__RemovePresetTourResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__RemovePresetTourResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__RemovePresetTourResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__RemovePresetTourResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__RemovePresetTourResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__RemovePresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__RemovePresetTourResponse(soap, tag ? tag : "tptz:RemovePresetTourResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__RemovePresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__RemovePresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_get__tptz__RemovePresetTourResponse(struct soap *soap, _tptz__RemovePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__RemovePresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__RemovePresetTour::ProfileToken);
	soap_default_tt__ReferenceToken(soap, &this->_tptz__RemovePresetTour::PresetTourToken);
}

void _tptz__RemovePresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__RemovePresetTour::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__RemovePresetTour::ProfileToken);
	soap_embedded(soap, &this->_tptz__RemovePresetTour::PresetTourToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__RemovePresetTour::PresetTourToken);
#endif
}

int _tptz__RemovePresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__RemovePresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, const _tptz__RemovePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetTour), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__RemovePresetTour::ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->_tptz__RemovePresetTour::PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__RemovePresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__RemovePresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__RemovePresetTour * SOAP_FMAC4 soap_in__tptz__RemovePresetTour(struct soap *soap, const char *tag, _tptz__RemovePresetTour *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__RemovePresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(_tptz__RemovePresetTour), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__RemovePresetTour)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__RemovePresetTour *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetTourToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__RemovePresetTour::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetTourToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->_tptz__RemovePresetTour::PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || soap_flag_PresetTourToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__RemovePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTour, SOAP_TYPE__tptz__RemovePresetTour, sizeof(_tptz__RemovePresetTour), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__RemovePresetTour * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__RemovePresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__RemovePresetTour *p;
	size_t k = sizeof(_tptz__RemovePresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__RemovePresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__RemovePresetTour);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__RemovePresetTour, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__RemovePresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__RemovePresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__RemovePresetTour(soap, tag ? tag : "tptz:RemovePresetTour", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__RemovePresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__RemovePresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__RemovePresetTour * SOAP_FMAC4 soap_get__tptz__RemovePresetTour(struct soap *soap, _tptz__RemovePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__OperatePresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__OperatePresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__OperatePresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__OperatePresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, int id, const _tptz__OperatePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__OperatePresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__OperatePresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__OperatePresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_in__tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, _tptz__OperatePresetTourResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__OperatePresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(_tptz__OperatePresetTourResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__OperatePresetTourResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__OperatePresetTourResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__OperatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTourResponse, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(_tptz__OperatePresetTourResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__OperatePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__OperatePresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__OperatePresetTourResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__OperatePresetTourResponse *p;
	size_t k = sizeof(_tptz__OperatePresetTourResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__OperatePresetTourResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__OperatePresetTourResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__OperatePresetTourResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__OperatePresetTourResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__OperatePresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__OperatePresetTourResponse(soap, tag ? tag : "tptz:OperatePresetTourResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__OperatePresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__OperatePresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_get__tptz__OperatePresetTourResponse(struct soap *soap, _tptz__OperatePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__OperatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__OperatePresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__OperatePresetTour::ProfileToken);
	soap_default_tt__ReferenceToken(soap, &this->_tptz__OperatePresetTour::PresetTourToken);
	soap_default_tt__PTZPresetTourOperation(soap, &this->_tptz__OperatePresetTour::Operation);
}

void _tptz__OperatePresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__OperatePresetTour::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__OperatePresetTour::ProfileToken);
	soap_embedded(soap, &this->_tptz__OperatePresetTour::PresetTourToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__OperatePresetTour::PresetTourToken);
#endif
}

int _tptz__OperatePresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__OperatePresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, const _tptz__OperatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__OperatePresetTour), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__OperatePresetTour::ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->_tptz__OperatePresetTour::PresetTourToken, ""))
		return soap->error;
	if (soap_out_tt__PTZPresetTourOperation(soap, "tptz:Operation", -1, &a->_tptz__OperatePresetTour::Operation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__OperatePresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__OperatePresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__OperatePresetTour * SOAP_FMAC4 soap_in__tptz__OperatePresetTour(struct soap *soap, const char *tag, _tptz__OperatePresetTour *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__OperatePresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(_tptz__OperatePresetTour), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__OperatePresetTour)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__OperatePresetTour *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetTourToken1 = 1;
	size_t soap_flag_Operation1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__OperatePresetTour::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetTourToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->_tptz__OperatePresetTour::PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken1--;
					continue;
				}
			}
			if (soap_flag_Operation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_tt__PTZPresetTourOperation(soap, "tptz:Operation", &a->_tptz__OperatePresetTour::Operation, "tt:PTZPresetTourOperation"))
				{	soap_flag_Operation1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || soap_flag_PresetTourToken1 > 0 || soap_flag_Operation1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__OperatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTour, SOAP_TYPE__tptz__OperatePresetTour, sizeof(_tptz__OperatePresetTour), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__OperatePresetTour * SOAP_FMAC2 soap_instantiate__tptz__OperatePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__OperatePresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__OperatePresetTour *p;
	size_t k = sizeof(_tptz__OperatePresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__OperatePresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__OperatePresetTour);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__OperatePresetTour, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__OperatePresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__OperatePresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__OperatePresetTour(soap, tag ? tag : "tptz:OperatePresetTour", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__OperatePresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__OperatePresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__OperatePresetTour * SOAP_FMAC4 soap_get__tptz__OperatePresetTour(struct soap *soap, _tptz__OperatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__ModifyPresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__ModifyPresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__ModifyPresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__ModifyPresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, int id, const _tptz__ModifyPresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__ModifyPresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__ModifyPresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_in__tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, _tptz__ModifyPresetTourResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__ModifyPresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(_tptz__ModifyPresetTourResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__ModifyPresetTourResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__ModifyPresetTourResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__ModifyPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTourResponse, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(_tptz__ModifyPresetTourResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__ModifyPresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__ModifyPresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__ModifyPresetTourResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__ModifyPresetTourResponse *p;
	size_t k = sizeof(_tptz__ModifyPresetTourResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__ModifyPresetTourResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__ModifyPresetTourResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__ModifyPresetTourResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__ModifyPresetTourResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__ModifyPresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__ModifyPresetTourResponse(soap, tag ? tag : "tptz:ModifyPresetTourResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__ModifyPresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__ModifyPresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_get__tptz__ModifyPresetTourResponse(struct soap *soap, _tptz__ModifyPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ModifyPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__ModifyPresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__ModifyPresetTour::ProfileToken);
	this->_tptz__ModifyPresetTour::PresetTour = NULL;
}

void _tptz__ModifyPresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__ModifyPresetTour::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__ModifyPresetTour::ProfileToken);
	soap_serialize_PointerTott__PresetTour(soap, &this->_tptz__ModifyPresetTour::PresetTour);
#endif
}

int _tptz__ModifyPresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__ModifyPresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, const _tptz__ModifyPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ModifyPresetTour), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__ModifyPresetTour::ProfileToken, ""))
		return soap->error;
	if (!a->_tptz__ModifyPresetTour::PresetTour)
	{	if (soap_element_empty(soap, "tptz:PresetTour", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->_tptz__ModifyPresetTour::PresetTour, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__ModifyPresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__ModifyPresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__ModifyPresetTour * SOAP_FMAC4 soap_in__tptz__ModifyPresetTour(struct soap *soap, const char *tag, _tptz__ModifyPresetTour *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__ModifyPresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(_tptz__ModifyPresetTour), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__ModifyPresetTour)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__ModifyPresetTour *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetTour1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__ModifyPresetTour::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetTour1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PresetTour(soap, "tptz:PresetTour", &a->_tptz__ModifyPresetTour::PresetTour, "tt:PresetTour"))
				{	soap_flag_PresetTour1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || !a->_tptz__ModifyPresetTour::PresetTour))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__ModifyPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTour, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(_tptz__ModifyPresetTour), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__ModifyPresetTour * SOAP_FMAC2 soap_instantiate__tptz__ModifyPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__ModifyPresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__ModifyPresetTour *p;
	size_t k = sizeof(_tptz__ModifyPresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__ModifyPresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__ModifyPresetTour);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__ModifyPresetTour, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__ModifyPresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__ModifyPresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__ModifyPresetTour(soap, tag ? tag : "tptz:ModifyPresetTour", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__ModifyPresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__ModifyPresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__ModifyPresetTour * SOAP_FMAC4 soap_get__tptz__ModifyPresetTour(struct soap *soap, _tptz__ModifyPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__CreatePresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__CreatePresetTourResponse::PresetTourToken);
}

void _tptz__CreatePresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__CreatePresetTourResponse::PresetTourToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__CreatePresetTourResponse::PresetTourToken);
#endif
}

int _tptz__CreatePresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__CreatePresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, int id, const _tptz__CreatePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__CreatePresetTourResponse), type))
		return soap->error;
	soap_element_result(soap, "tptz:PresetTourToken");
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->_tptz__CreatePresetTourResponse::PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__CreatePresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__CreatePresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_in__tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, _tptz__CreatePresetTourResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__CreatePresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(_tptz__CreatePresetTourResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__CreatePresetTourResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__CreatePresetTourResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PresetTourToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetTourToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->_tptz__CreatePresetTourResponse::PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PresetTourToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetTourToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__CreatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTourResponse, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(_tptz__CreatePresetTourResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__CreatePresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__CreatePresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__CreatePresetTourResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__CreatePresetTourResponse *p;
	size_t k = sizeof(_tptz__CreatePresetTourResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__CreatePresetTourResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__CreatePresetTourResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__CreatePresetTourResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__CreatePresetTourResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__CreatePresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__CreatePresetTourResponse(soap, tag ? tag : "tptz:CreatePresetTourResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__CreatePresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__CreatePresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_get__tptz__CreatePresetTourResponse(struct soap *soap, _tptz__CreatePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__CreatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__CreatePresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__CreatePresetTour::ProfileToken);
}

void _tptz__CreatePresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__CreatePresetTour::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__CreatePresetTour::ProfileToken);
#endif
}

int _tptz__CreatePresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__CreatePresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, const _tptz__CreatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__CreatePresetTour), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__CreatePresetTour::ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__CreatePresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__CreatePresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__CreatePresetTour * SOAP_FMAC4 soap_in__tptz__CreatePresetTour(struct soap *soap, const char *tag, _tptz__CreatePresetTour *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__CreatePresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(_tptz__CreatePresetTour), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__CreatePresetTour)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__CreatePresetTour *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__CreatePresetTour::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__CreatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTour, SOAP_TYPE__tptz__CreatePresetTour, sizeof(_tptz__CreatePresetTour), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__CreatePresetTour * SOAP_FMAC2 soap_instantiate__tptz__CreatePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__CreatePresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__CreatePresetTour *p;
	size_t k = sizeof(_tptz__CreatePresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__CreatePresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__CreatePresetTour);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__CreatePresetTour, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__CreatePresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__CreatePresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__CreatePresetTour(soap, tag ? tag : "tptz:CreatePresetTour", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__CreatePresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__CreatePresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__CreatePresetTour * SOAP_FMAC4 soap_get__tptz__CreatePresetTour(struct soap *soap, _tptz__CreatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetPresetTourOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__GetPresetTourOptionsResponse::Options = NULL;
}

void _tptz__GetPresetTourOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZPresetTourOptions(soap, &this->_tptz__GetPresetTourOptionsResponse::Options);
#endif
}

int _tptz__GetPresetTourOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetPresetTourOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, int id, const _tptz__GetPresetTourOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "tptz:Options");
	if (!a->_tptz__GetPresetTourOptionsResponse::Options)
	{	if (soap_element_empty(soap, "tptz:Options", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZPresetTourOptions(soap, "tptz:Options", -1, &a->_tptz__GetPresetTourOptionsResponse::Options, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetPresetTourOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetPresetTourOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_in__tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, _tptz__GetPresetTourOptionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetPresetTourOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(_tptz__GetPresetTourOptionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetPresetTourOptionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetPresetTourOptionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Options1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZPresetTourOptions(soap, "tptz:Options", &a->_tptz__GetPresetTourOptionsResponse::Options, "tt:PTZPresetTourOptions"))
				{	soap_flag_Options1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tptz__GetPresetTourOptionsResponse::Options))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetPresetTourOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(_tptz__GetPresetTourOptionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetPresetTourOptionsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetPresetTourOptionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetPresetTourOptionsResponse *p;
	size_t k = sizeof(_tptz__GetPresetTourOptionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetPresetTourOptionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetPresetTourOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetPresetTourOptionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetPresetTourOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetPresetTourOptionsResponse(soap, tag ? tag : "tptz:GetPresetTourOptionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetPresetTourOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetPresetTourOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_get__tptz__GetPresetTourOptionsResponse(struct soap *soap, _tptz__GetPresetTourOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetPresetTourOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetPresetTourOptions::ProfileToken);
	this->_tptz__GetPresetTourOptions::PresetTourToken = NULL;
}

void _tptz__GetPresetTourOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetPresetTourOptions::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetPresetTourOptions::ProfileToken);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->_tptz__GetPresetTourOptions::PresetTourToken);
#endif
}

int _tptz__GetPresetTourOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetPresetTourOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, const _tptz__GetPresetTourOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GetPresetTourOptions::ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->_tptz__GetPresetTourOptions::PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetPresetTourOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetPresetTourOptions(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_in__tptz__GetPresetTourOptions(struct soap *soap, const char *tag, _tptz__GetPresetTourOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetPresetTourOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(_tptz__GetPresetTourOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetPresetTourOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetPresetTourOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetTourToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GetPresetTourOptions::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetTourToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tptz:PresetTourToken", &a->_tptz__GetPresetTourOptions::PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptions, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(_tptz__GetPresetTourOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetPresetTourOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetPresetTourOptions *p;
	size_t k = sizeof(_tptz__GetPresetTourOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetPresetTourOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetPresetTourOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetPresetTourOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetPresetTourOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetPresetTourOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetPresetTourOptions(soap, tag ? tag : "tptz:GetPresetTourOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetPresetTourOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetPresetTourOptions(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_get__tptz__GetPresetTourOptions(struct soap *soap, _tptz__GetPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetPresetTourResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__GetPresetTourResponse::PresetTour = NULL;
}

void _tptz__GetPresetTourResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PresetTour(soap, &this->_tptz__GetPresetTourResponse::PresetTour);
#endif
}

int _tptz__GetPresetTourResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetPresetTourResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourResponse(struct soap *soap, const char *tag, int id, const _tptz__GetPresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourResponse), type))
		return soap->error;
	if (a->PresetTour)
		soap_element_result(soap, "tptz:PresetTour");
	if (!a->_tptz__GetPresetTourResponse::PresetTour)
	{	if (soap_element_empty(soap, "tptz:PresetTour", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->_tptz__GetPresetTourResponse::PresetTour, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetPresetTourResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetPresetTourResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_in__tptz__GetPresetTourResponse(struct soap *soap, const char *tag, _tptz__GetPresetTourResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetPresetTourResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(_tptz__GetPresetTourResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetPresetTourResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetPresetTourResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PresetTour1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetTour1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PresetTour(soap, "tptz:PresetTour", &a->_tptz__GetPresetTourResponse::PresetTour, "tt:PresetTour"))
				{	soap_flag_PresetTour1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PresetTour");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tptz__GetPresetTourResponse::PresetTour))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourResponse, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(_tptz__GetPresetTourResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetPresetTourResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTourResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetPresetTourResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetPresetTourResponse *p;
	size_t k = sizeof(_tptz__GetPresetTourResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetPresetTourResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetPresetTourResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetPresetTourResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetPresetTourResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetPresetTourResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetPresetTourResponse(soap, tag ? tag : "tptz:GetPresetTourResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetPresetTourResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetPresetTourResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_get__tptz__GetPresetTourResponse(struct soap *soap, _tptz__GetPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetPresetTour::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetPresetTour::ProfileToken);
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetPresetTour::PresetTourToken);
}

void _tptz__GetPresetTour::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetPresetTour::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetPresetTour::ProfileToken);
	soap_embedded(soap, &this->_tptz__GetPresetTour::PresetTourToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetPresetTour::PresetTourToken);
#endif
}

int _tptz__GetPresetTour::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetPresetTour(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTour(struct soap *soap, const char *tag, int id, const _tptz__GetPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTour), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GetPresetTour::ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->_tptz__GetPresetTour::PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetPresetTour::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetPresetTour(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetPresetTour * SOAP_FMAC4 soap_in__tptz__GetPresetTour(struct soap *soap, const char *tag, _tptz__GetPresetTour *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetPresetTour*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTour, sizeof(_tptz__GetPresetTour), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetPresetTour)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetPresetTour *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetTourToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GetPresetTour::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetTourToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->_tptz__GetPresetTour::PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || soap_flag_PresetTourToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTour, SOAP_TYPE__tptz__GetPresetTour, sizeof(_tptz__GetPresetTour), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetPresetTour * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetPresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetPresetTour *p;
	size_t k = sizeof(_tptz__GetPresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetPresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetPresetTour);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetPresetTour, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetPresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetPresetTour::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetPresetTour(soap, tag ? tag : "tptz:GetPresetTour", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetPresetTour::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetPresetTour(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetPresetTour * SOAP_FMAC4 soap_get__tptz__GetPresetTour(struct soap *soap, _tptz__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetPresetToursResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__PresetTour(soap, &this->_tptz__GetPresetToursResponse::PresetTour);
}

void _tptz__GetPresetToursResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PresetTour(soap, &this->_tptz__GetPresetToursResponse::PresetTour);
#endif
}

int _tptz__GetPresetToursResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetPresetToursResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetToursResponse(struct soap *soap, const char *tag, int id, const _tptz__GetPresetToursResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetToursResponse), type))
		return soap->error;
	soap_element_result(soap, "tptz:PresetTour");
	if (soap_out_std__vectorTemplateOfPointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->_tptz__GetPresetToursResponse::PresetTour, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetPresetToursResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetPresetToursResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_in__tptz__GetPresetToursResponse(struct soap *soap, const char *tag, _tptz__GetPresetToursResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetPresetToursResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(_tptz__GetPresetToursResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetPresetToursResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetPresetToursResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PresetTour(soap, "tptz:PresetTour", &a->_tptz__GetPresetToursResponse::PresetTour, "tt:PresetTour"))
					continue;
			}
			soap_check_result(soap, "tptz:PresetTour");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GetPresetToursResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetToursResponse, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(_tptz__GetPresetToursResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetPresetToursResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetToursResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetPresetToursResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetPresetToursResponse *p;
	size_t k = sizeof(_tptz__GetPresetToursResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetPresetToursResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetPresetToursResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetPresetToursResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetPresetToursResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetPresetToursResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetPresetToursResponse(soap, tag ? tag : "tptz:GetPresetToursResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetPresetToursResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetPresetToursResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_get__tptz__GetPresetToursResponse(struct soap *soap, _tptz__GetPresetToursResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetToursResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetPresetTours::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetPresetTours::ProfileToken);
}

void _tptz__GetPresetTours::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetPresetTours::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetPresetTours::ProfileToken);
#endif
}

int _tptz__GetPresetTours::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetPresetTours(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTours(struct soap *soap, const char *tag, int id, const _tptz__GetPresetTours *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTours), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GetPresetTours::ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetPresetTours::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetPresetTours(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetPresetTours * SOAP_FMAC4 soap_in__tptz__GetPresetTours(struct soap *soap, const char *tag, _tptz__GetPresetTours *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetPresetTours*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTours, sizeof(_tptz__GetPresetTours), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetPresetTours)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetPresetTours *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GetPresetTours::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetPresetTours *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTours, SOAP_TYPE__tptz__GetPresetTours, sizeof(_tptz__GetPresetTours), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetPresetTours * SOAP_FMAC2 soap_instantiate__tptz__GetPresetTours(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetPresetTours(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetPresetTours *p;
	size_t k = sizeof(_tptz__GetPresetTours);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetPresetTours, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetPresetTours);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetPresetTours, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetPresetTours location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetPresetTours::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetPresetTours(soap, tag ? tag : "tptz:GetPresetTours", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetPresetTours::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetPresetTours(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetPresetTours * SOAP_FMAC4 soap_get__tptz__GetPresetTours(struct soap *soap, _tptz__GetPresetTours *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__StopResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__StopResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__StopResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__StopResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__StopResponse(struct soap *soap, const char *tag, int id, const _tptz__StopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__StopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__StopResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__StopResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__StopResponse * SOAP_FMAC4 soap_in__tptz__StopResponse(struct soap *soap, const char *tag, _tptz__StopResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__StopResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__StopResponse, sizeof(_tptz__StopResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__StopResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__StopResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__StopResponse, SOAP_TYPE__tptz__StopResponse, sizeof(_tptz__StopResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__StopResponse * SOAP_FMAC2 soap_instantiate__tptz__StopResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__StopResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__StopResponse *p;
	size_t k = sizeof(_tptz__StopResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__StopResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__StopResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__StopResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__StopResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__StopResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__StopResponse(soap, tag ? tag : "tptz:StopResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__StopResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__StopResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__StopResponse * SOAP_FMAC4 soap_get__tptz__StopResponse(struct soap *soap, _tptz__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__Stop::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__Stop::ProfileToken);
	this->_tptz__Stop::PanTilt = NULL;
	this->_tptz__Stop::Zoom = NULL;
}

void _tptz__Stop::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__Stop::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__Stop::ProfileToken);
	soap_serialize_PointerTobool(soap, &this->_tptz__Stop::PanTilt);
	soap_serialize_PointerTobool(soap, &this->_tptz__Stop::Zoom);
#endif
}

int _tptz__Stop::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__Stop(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__Stop(struct soap *soap, const char *tag, int id, const _tptz__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__Stop), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__Stop::ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tptz:PanTilt", -1, &a->_tptz__Stop::PanTilt, ""))
		return soap->error;
	if (soap_out_PointerTobool(soap, "tptz:Zoom", -1, &a->_tptz__Stop::Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__Stop::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__Stop(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__Stop * SOAP_FMAC4 soap_in__tptz__Stop(struct soap *soap, const char *tag, _tptz__Stop *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__Stop*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__Stop, sizeof(_tptz__Stop), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__Stop)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__Stop *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PanTilt1 = 1;
	size_t soap_flag_Zoom1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__Stop::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PanTilt1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tptz:PanTilt", &a->_tptz__Stop::PanTilt, "xsd:boolean"))
				{	soap_flag_PanTilt1--;
					continue;
				}
			}
			if (soap_flag_Zoom1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTobool(soap, "tptz:Zoom", &a->_tptz__Stop::Zoom, "xsd:boolean"))
				{	soap_flag_Zoom1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__Stop, SOAP_TYPE__tptz__Stop, sizeof(_tptz__Stop), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__Stop * SOAP_FMAC2 soap_instantiate__tptz__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__Stop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__Stop *p;
	size_t k = sizeof(_tptz__Stop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__Stop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__Stop);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__Stop, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__Stop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__Stop::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__Stop(soap, tag ? tag : "tptz:Stop", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__Stop::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__Stop(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__Stop * SOAP_FMAC4 soap_get__tptz__Stop(struct soap *soap, _tptz__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GeoMoveResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__GeoMoveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__GeoMoveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GeoMoveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GeoMoveResponse(struct soap *soap, const char *tag, int id, const _tptz__GeoMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GeoMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GeoMoveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GeoMoveResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GeoMoveResponse * SOAP_FMAC4 soap_in__tptz__GeoMoveResponse(struct soap *soap, const char *tag, _tptz__GeoMoveResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GeoMoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GeoMoveResponse, sizeof(_tptz__GeoMoveResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GeoMoveResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GeoMoveResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GeoMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GeoMoveResponse, SOAP_TYPE__tptz__GeoMoveResponse, sizeof(_tptz__GeoMoveResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GeoMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__GeoMoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GeoMoveResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GeoMoveResponse *p;
	size_t k = sizeof(_tptz__GeoMoveResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GeoMoveResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GeoMoveResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GeoMoveResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GeoMoveResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GeoMoveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GeoMoveResponse(soap, tag ? tag : "tptz:GeoMoveResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GeoMoveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GeoMoveResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GeoMoveResponse * SOAP_FMAC4 soap_get__tptz__GeoMoveResponse(struct soap *soap, _tptz__GeoMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GeoMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GeoMove::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GeoMove::ProfileToken);
	this->_tptz__GeoMove::Target = NULL;
	this->_tptz__GeoMove::Speed = NULL;
	this->_tptz__GeoMove::AreaHeight = NULL;
	this->_tptz__GeoMove::AreaWidth = NULL;
}

void _tptz__GeoMove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GeoMove::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GeoMove::ProfileToken);
	soap_serialize_PointerTott__GeoLocation(soap, &this->_tptz__GeoMove::Target);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->_tptz__GeoMove::Speed);
	soap_serialize_PointerTofloat(soap, &this->_tptz__GeoMove::AreaHeight);
	soap_serialize_PointerTofloat(soap, &this->_tptz__GeoMove::AreaWidth);
#endif
}

int _tptz__GeoMove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GeoMove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GeoMove(struct soap *soap, const char *tag, int id, const _tptz__GeoMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GeoMove), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GeoMove::ProfileToken, ""))
		return soap->error;
	if (!a->_tptz__GeoMove::Target)
	{	if (soap_element_empty(soap, "tptz:Target", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__GeoLocation(soap, "tptz:Target", -1, &a->_tptz__GeoMove::Target, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->_tptz__GeoMove::Speed, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tptz:AreaHeight", -1, &a->_tptz__GeoMove::AreaHeight, ""))
		return soap->error;
	if (soap_out_PointerTofloat(soap, "tptz:AreaWidth", -1, &a->_tptz__GeoMove::AreaWidth, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GeoMove::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GeoMove(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GeoMove * SOAP_FMAC4 soap_in__tptz__GeoMove(struct soap *soap, const char *tag, _tptz__GeoMove *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GeoMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GeoMove, sizeof(_tptz__GeoMove), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GeoMove)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GeoMove *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_Target1 = 1;
	size_t soap_flag_Speed1 = 1;
	size_t soap_flag_AreaHeight1 = 1;
	size_t soap_flag_AreaWidth1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GeoMove::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_Target1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__GeoLocation(soap, "tptz:Target", &a->_tptz__GeoMove::Target, "tt:GeoLocation"))
				{	soap_flag_Target1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->_tptz__GeoMove::Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap_flag_AreaHeight1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tptz:AreaHeight", &a->_tptz__GeoMove::AreaHeight, "xsd:float"))
				{	soap_flag_AreaHeight1--;
					continue;
				}
			}
			if (soap_flag_AreaWidth1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTofloat(soap, "tptz:AreaWidth", &a->_tptz__GeoMove::AreaWidth, "xsd:float"))
				{	soap_flag_AreaWidth1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || !a->_tptz__GeoMove::Target))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GeoMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GeoMove, SOAP_TYPE__tptz__GeoMove, sizeof(_tptz__GeoMove), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GeoMove * SOAP_FMAC2 soap_instantiate__tptz__GeoMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GeoMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GeoMove *p;
	size_t k = sizeof(_tptz__GeoMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GeoMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GeoMove);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GeoMove, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GeoMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GeoMove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GeoMove(soap, tag ? tag : "tptz:GeoMove", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GeoMove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GeoMove(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GeoMove * SOAP_FMAC4 soap_get__tptz__GeoMove(struct soap *soap, _tptz__GeoMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GeoMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__AbsoluteMoveResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__AbsoluteMoveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__AbsoluteMoveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__AbsoluteMoveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, int id, const _tptz__AbsoluteMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__AbsoluteMoveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__AbsoluteMoveResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_in__tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, _tptz__AbsoluteMoveResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__AbsoluteMoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(_tptz__AbsoluteMoveResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__AbsoluteMoveResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__AbsoluteMoveResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__AbsoluteMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMoveResponse, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(_tptz__AbsoluteMoveResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__AbsoluteMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__AbsoluteMoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__AbsoluteMoveResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__AbsoluteMoveResponse *p;
	size_t k = sizeof(_tptz__AbsoluteMoveResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__AbsoluteMoveResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__AbsoluteMoveResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__AbsoluteMoveResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__AbsoluteMoveResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__AbsoluteMoveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__AbsoluteMoveResponse(soap, tag ? tag : "tptz:AbsoluteMoveResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__AbsoluteMoveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__AbsoluteMoveResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_get__tptz__AbsoluteMoveResponse(struct soap *soap, _tptz__AbsoluteMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__AbsoluteMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__AbsoluteMove::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__AbsoluteMove::ProfileToken);
	this->_tptz__AbsoluteMove::Position = NULL;
	this->_tptz__AbsoluteMove::Speed = NULL;
}

void _tptz__AbsoluteMove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__AbsoluteMove::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__AbsoluteMove::ProfileToken);
	soap_serialize_PointerTott__PTZVector(soap, &this->_tptz__AbsoluteMove::Position);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->_tptz__AbsoluteMove::Speed);
#endif
}

int _tptz__AbsoluteMove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__AbsoluteMove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, const _tptz__AbsoluteMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__AbsoluteMove), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__AbsoluteMove::ProfileToken, ""))
		return soap->error;
	if (!a->_tptz__AbsoluteMove::Position)
	{	if (soap_element_empty(soap, "tptz:Position", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tptz:Position", -1, &a->_tptz__AbsoluteMove::Position, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->_tptz__AbsoluteMove::Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__AbsoluteMove::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__AbsoluteMove(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__AbsoluteMove * SOAP_FMAC4 soap_in__tptz__AbsoluteMove(struct soap *soap, const char *tag, _tptz__AbsoluteMove *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__AbsoluteMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(_tptz__AbsoluteMove), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__AbsoluteMove)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__AbsoluteMove *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_Position1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__AbsoluteMove::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_Position1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tptz:Position", &a->_tptz__AbsoluteMove::Position, "tt:PTZVector"))
				{	soap_flag_Position1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->_tptz__AbsoluteMove::Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || !a->_tptz__AbsoluteMove::Position))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__AbsoluteMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMove, SOAP_TYPE__tptz__AbsoluteMove, sizeof(_tptz__AbsoluteMove), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__AbsoluteMove * SOAP_FMAC2 soap_instantiate__tptz__AbsoluteMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__AbsoluteMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__AbsoluteMove *p;
	size_t k = sizeof(_tptz__AbsoluteMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__AbsoluteMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__AbsoluteMove);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__AbsoluteMove, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__AbsoluteMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__AbsoluteMove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__AbsoluteMove(soap, tag ? tag : "tptz:AbsoluteMove", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__AbsoluteMove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__AbsoluteMove(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__AbsoluteMove * SOAP_FMAC4 soap_get__tptz__AbsoluteMove(struct soap *soap, _tptz__AbsoluteMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__RelativeMoveResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__RelativeMoveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__RelativeMoveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__RelativeMoveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RelativeMoveResponse(struct soap *soap, const char *tag, int id, const _tptz__RelativeMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RelativeMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__RelativeMoveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__RelativeMoveResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_in__tptz__RelativeMoveResponse(struct soap *soap, const char *tag, _tptz__RelativeMoveResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__RelativeMoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(_tptz__RelativeMoveResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__RelativeMoveResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__RelativeMoveResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__RelativeMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMoveResponse, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(_tptz__RelativeMoveResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__RelativeMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__RelativeMoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__RelativeMoveResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__RelativeMoveResponse *p;
	size_t k = sizeof(_tptz__RelativeMoveResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__RelativeMoveResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__RelativeMoveResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__RelativeMoveResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__RelativeMoveResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__RelativeMoveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__RelativeMoveResponse(soap, tag ? tag : "tptz:RelativeMoveResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__RelativeMoveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__RelativeMoveResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_get__tptz__RelativeMoveResponse(struct soap *soap, _tptz__RelativeMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RelativeMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__RelativeMove::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__RelativeMove::ProfileToken);
	this->_tptz__RelativeMove::Translation = NULL;
	this->_tptz__RelativeMove::Speed = NULL;
}

void _tptz__RelativeMove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__RelativeMove::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__RelativeMove::ProfileToken);
	soap_serialize_PointerTott__PTZVector(soap, &this->_tptz__RelativeMove::Translation);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->_tptz__RelativeMove::Speed);
#endif
}

int _tptz__RelativeMove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__RelativeMove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RelativeMove(struct soap *soap, const char *tag, int id, const _tptz__RelativeMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RelativeMove), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__RelativeMove::ProfileToken, ""))
		return soap->error;
	if (!a->_tptz__RelativeMove::Translation)
	{	if (soap_element_empty(soap, "tptz:Translation", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZVector(soap, "tptz:Translation", -1, &a->_tptz__RelativeMove::Translation, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->_tptz__RelativeMove::Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__RelativeMove::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__RelativeMove(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__RelativeMove * SOAP_FMAC4 soap_in__tptz__RelativeMove(struct soap *soap, const char *tag, _tptz__RelativeMove *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__RelativeMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMove, sizeof(_tptz__RelativeMove), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__RelativeMove)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__RelativeMove *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_Translation1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__RelativeMove::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_Translation1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZVector(soap, "tptz:Translation", &a->_tptz__RelativeMove::Translation, "tt:PTZVector"))
				{	soap_flag_Translation1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->_tptz__RelativeMove::Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || !a->_tptz__RelativeMove::Translation))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__RelativeMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMove, SOAP_TYPE__tptz__RelativeMove, sizeof(_tptz__RelativeMove), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__RelativeMove * SOAP_FMAC2 soap_instantiate__tptz__RelativeMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__RelativeMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__RelativeMove *p;
	size_t k = sizeof(_tptz__RelativeMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__RelativeMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__RelativeMove);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__RelativeMove, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__RelativeMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__RelativeMove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__RelativeMove(soap, tag ? tag : "tptz:RelativeMove", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__RelativeMove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__RelativeMove(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__RelativeMove * SOAP_FMAC4 soap_get__tptz__RelativeMove(struct soap *soap, _tptz__RelativeMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__ContinuousMoveResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__ContinuousMoveResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__ContinuousMoveResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__ContinuousMoveResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, int id, const _tptz__ContinuousMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ContinuousMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__ContinuousMoveResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__ContinuousMoveResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_in__tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, _tptz__ContinuousMoveResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__ContinuousMoveResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(_tptz__ContinuousMoveResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__ContinuousMoveResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__ContinuousMoveResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__ContinuousMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMoveResponse, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(_tptz__ContinuousMoveResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__ContinuousMoveResponse * SOAP_FMAC2 soap_instantiate__tptz__ContinuousMoveResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__ContinuousMoveResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__ContinuousMoveResponse *p;
	size_t k = sizeof(_tptz__ContinuousMoveResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__ContinuousMoveResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__ContinuousMoveResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__ContinuousMoveResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__ContinuousMoveResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__ContinuousMoveResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__ContinuousMoveResponse(soap, tag ? tag : "tptz:ContinuousMoveResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__ContinuousMoveResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__ContinuousMoveResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_get__tptz__ContinuousMoveResponse(struct soap *soap, _tptz__ContinuousMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ContinuousMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__ContinuousMove::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__ContinuousMove::ProfileToken);
	this->_tptz__ContinuousMove::Velocity = NULL;
	this->_tptz__ContinuousMove::Timeout = NULL;
}

void _tptz__ContinuousMove::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__ContinuousMove::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__ContinuousMove::ProfileToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->_tptz__ContinuousMove::Velocity);
	soap_serialize_PointerToxsd__duration(soap, &this->_tptz__ContinuousMove::Timeout);
#endif
}

int _tptz__ContinuousMove::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__ContinuousMove(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ContinuousMove(struct soap *soap, const char *tag, int id, const _tptz__ContinuousMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ContinuousMove), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__ContinuousMove::ProfileToken, ""))
		return soap->error;
	if (!a->_tptz__ContinuousMove::Velocity)
	{	if (soap_element_empty(soap, "tptz:Velocity", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Velocity", -1, &a->_tptz__ContinuousMove::Velocity, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tptz:Timeout", -1, &a->_tptz__ContinuousMove::Timeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__ContinuousMove::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__ContinuousMove(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__ContinuousMove * SOAP_FMAC4 soap_in__tptz__ContinuousMove(struct soap *soap, const char *tag, _tptz__ContinuousMove *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__ContinuousMove*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMove, sizeof(_tptz__ContinuousMove), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__ContinuousMove)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__ContinuousMove *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_Velocity1 = 1;
	size_t soap_flag_Timeout1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__ContinuousMove::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_Velocity1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Velocity", &a->_tptz__ContinuousMove::Velocity, "tt:PTZSpeed"))
				{	soap_flag_Velocity1--;
					continue;
				}
			}
			if (soap_flag_Timeout1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerToxsd__duration(soap, "tptz:Timeout", &a->_tptz__ContinuousMove::Timeout, "xsd:duration"))
				{	soap_flag_Timeout1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || !a->_tptz__ContinuousMove::Velocity))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__ContinuousMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMove, SOAP_TYPE__tptz__ContinuousMove, sizeof(_tptz__ContinuousMove), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__ContinuousMove * SOAP_FMAC2 soap_instantiate__tptz__ContinuousMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__ContinuousMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__ContinuousMove *p;
	size_t k = sizeof(_tptz__ContinuousMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__ContinuousMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__ContinuousMove);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__ContinuousMove, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__ContinuousMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__ContinuousMove::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__ContinuousMove(soap, tag ? tag : "tptz:ContinuousMove", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__ContinuousMove::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__ContinuousMove(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__ContinuousMove * SOAP_FMAC4 soap_get__tptz__ContinuousMove(struct soap *soap, _tptz__ContinuousMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__SetHomePositionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__SetHomePositionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__SetHomePositionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__SetHomePositionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetHomePositionResponse(struct soap *soap, const char *tag, int id, const _tptz__SetHomePositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetHomePositionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__SetHomePositionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__SetHomePositionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_in__tptz__SetHomePositionResponse(struct soap *soap, const char *tag, _tptz__SetHomePositionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__SetHomePositionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(_tptz__SetHomePositionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__SetHomePositionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__SetHomePositionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__SetHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePositionResponse, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(_tptz__SetHomePositionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__SetHomePositionResponse * SOAP_FMAC2 soap_instantiate__tptz__SetHomePositionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__SetHomePositionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__SetHomePositionResponse *p;
	size_t k = sizeof(_tptz__SetHomePositionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__SetHomePositionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__SetHomePositionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__SetHomePositionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__SetHomePositionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__SetHomePositionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__SetHomePositionResponse(soap, tag ? tag : "tptz:SetHomePositionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__SetHomePositionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__SetHomePositionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_get__tptz__SetHomePositionResponse(struct soap *soap, _tptz__SetHomePositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__SetHomePosition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__SetHomePosition::ProfileToken);
}

void _tptz__SetHomePosition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__SetHomePosition::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__SetHomePosition::ProfileToken);
#endif
}

int _tptz__SetHomePosition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__SetHomePosition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetHomePosition(struct soap *soap, const char *tag, int id, const _tptz__SetHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetHomePosition), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__SetHomePosition::ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__SetHomePosition::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__SetHomePosition(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__SetHomePosition * SOAP_FMAC4 soap_in__tptz__SetHomePosition(struct soap *soap, const char *tag, _tptz__SetHomePosition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__SetHomePosition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePosition, sizeof(_tptz__SetHomePosition), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__SetHomePosition)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__SetHomePosition *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__SetHomePosition::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__SetHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePosition, SOAP_TYPE__tptz__SetHomePosition, sizeof(_tptz__SetHomePosition), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__SetHomePosition * SOAP_FMAC2 soap_instantiate__tptz__SetHomePosition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__SetHomePosition(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__SetHomePosition *p;
	size_t k = sizeof(_tptz__SetHomePosition);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__SetHomePosition, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__SetHomePosition);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__SetHomePosition, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__SetHomePosition location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__SetHomePosition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__SetHomePosition(soap, tag ? tag : "tptz:SetHomePosition", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__SetHomePosition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__SetHomePosition(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__SetHomePosition * SOAP_FMAC4 soap_get__tptz__SetHomePosition(struct soap *soap, _tptz__SetHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GotoHomePositionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__GotoHomePositionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__GotoHomePositionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GotoHomePositionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, int id, const _tptz__GotoHomePositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoHomePositionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GotoHomePositionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GotoHomePositionResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_in__tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, _tptz__GotoHomePositionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GotoHomePositionResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(_tptz__GotoHomePositionResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GotoHomePositionResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GotoHomePositionResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GotoHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePositionResponse, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(_tptz__GotoHomePositionResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GotoHomePositionResponse * SOAP_FMAC2 soap_instantiate__tptz__GotoHomePositionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GotoHomePositionResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GotoHomePositionResponse *p;
	size_t k = sizeof(_tptz__GotoHomePositionResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GotoHomePositionResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GotoHomePositionResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GotoHomePositionResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GotoHomePositionResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GotoHomePositionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GotoHomePositionResponse(soap, tag ? tag : "tptz:GotoHomePositionResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GotoHomePositionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GotoHomePositionResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_get__tptz__GotoHomePositionResponse(struct soap *soap, _tptz__GotoHomePositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GotoHomePosition::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GotoHomePosition::ProfileToken);
	this->_tptz__GotoHomePosition::Speed = NULL;
}

void _tptz__GotoHomePosition::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GotoHomePosition::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GotoHomePosition::ProfileToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->_tptz__GotoHomePosition::Speed);
#endif
}

int _tptz__GotoHomePosition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GotoHomePosition(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, const _tptz__GotoHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoHomePosition), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GotoHomePosition::ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->_tptz__GotoHomePosition::Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GotoHomePosition::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GotoHomePosition(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GotoHomePosition * SOAP_FMAC4 soap_in__tptz__GotoHomePosition(struct soap *soap, const char *tag, _tptz__GotoHomePosition *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GotoHomePosition*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(_tptz__GotoHomePosition), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GotoHomePosition)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GotoHomePosition *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GotoHomePosition::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->_tptz__GotoHomePosition::Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GotoHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePosition, SOAP_TYPE__tptz__GotoHomePosition, sizeof(_tptz__GotoHomePosition), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GotoHomePosition * SOAP_FMAC2 soap_instantiate__tptz__GotoHomePosition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GotoHomePosition(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GotoHomePosition *p;
	size_t k = sizeof(_tptz__GotoHomePosition);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GotoHomePosition, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GotoHomePosition);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GotoHomePosition, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GotoHomePosition location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GotoHomePosition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GotoHomePosition(soap, tag ? tag : "tptz:GotoHomePosition", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GotoHomePosition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GotoHomePosition(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GotoHomePosition * SOAP_FMAC4 soap_get__tptz__GotoHomePosition(struct soap *soap, _tptz__GotoHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__GetStatusResponse::PTZStatus = NULL;
}

void _tptz__GetStatusResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZStatus(soap, &this->_tptz__GetStatusResponse::PTZStatus);
#endif
}

int _tptz__GetStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetStatusResponse(struct soap *soap, const char *tag, int id, const _tptz__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetStatusResponse), type))
		return soap->error;
	if (a->PTZStatus)
		soap_element_result(soap, "tptz:PTZStatus");
	if (!a->_tptz__GetStatusResponse::PTZStatus)
	{	if (soap_element_empty(soap, "tptz:PTZStatus", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZStatus(soap, "tptz:PTZStatus", -1, &a->_tptz__GetStatusResponse::PTZStatus, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetStatusResponse * SOAP_FMAC4 soap_in__tptz__GetStatusResponse(struct soap *soap, const char *tag, _tptz__GetStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetStatusResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(_tptz__GetStatusResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetStatusResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetStatusResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PTZStatus1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZStatus(soap, "tptz:PTZStatus", &a->_tptz__GetStatusResponse::PTZStatus, "tt:PTZStatus"))
				{	soap_flag_PTZStatus1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PTZStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tptz__GetStatusResponse::PTZStatus))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatusResponse, SOAP_TYPE__tptz__GetStatusResponse, sizeof(_tptz__GetStatusResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetStatusResponse * SOAP_FMAC2 soap_instantiate__tptz__GetStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetStatusResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetStatusResponse *p;
	size_t k = sizeof(_tptz__GetStatusResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetStatusResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetStatusResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetStatusResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetStatusResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetStatusResponse(soap, tag ? tag : "tptz:GetStatusResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetStatusResponse * SOAP_FMAC4 soap_get__tptz__GetStatusResponse(struct soap *soap, _tptz__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetStatus::ProfileToken);
}

void _tptz__GetStatus::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetStatus::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetStatus::ProfileToken);
#endif
}

int _tptz__GetStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetStatus(struct soap *soap, const char *tag, int id, const _tptz__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetStatus), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GetStatus::ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetStatus * SOAP_FMAC4 soap_in__tptz__GetStatus(struct soap *soap, const char *tag, _tptz__GetStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetStatus*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatus, sizeof(_tptz__GetStatus), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetStatus)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetStatus *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GetStatus::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatus, SOAP_TYPE__tptz__GetStatus, sizeof(_tptz__GetStatus), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetStatus * SOAP_FMAC2 soap_instantiate__tptz__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetStatus *p;
	size_t k = sizeof(_tptz__GetStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetStatus);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetStatus, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetStatus(soap, tag ? tag : "tptz:GetStatus", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetStatus * SOAP_FMAC4 soap_get__tptz__GetStatus(struct soap *soap, _tptz__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GotoPresetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__GotoPresetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__GotoPresetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GotoPresetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoPresetResponse(struct soap *soap, const char *tag, int id, const _tptz__GotoPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoPresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GotoPresetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GotoPresetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GotoPresetResponse * SOAP_FMAC4 soap_in__tptz__GotoPresetResponse(struct soap *soap, const char *tag, _tptz__GotoPresetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GotoPresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(_tptz__GotoPresetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GotoPresetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GotoPresetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GotoPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPresetResponse, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(_tptz__GotoPresetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GotoPresetResponse * SOAP_FMAC2 soap_instantiate__tptz__GotoPresetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GotoPresetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GotoPresetResponse *p;
	size_t k = sizeof(_tptz__GotoPresetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GotoPresetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GotoPresetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GotoPresetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GotoPresetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GotoPresetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GotoPresetResponse(soap, tag ? tag : "tptz:GotoPresetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GotoPresetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GotoPresetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GotoPresetResponse * SOAP_FMAC4 soap_get__tptz__GotoPresetResponse(struct soap *soap, _tptz__GotoPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GotoPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GotoPreset::ProfileToken);
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GotoPreset::PresetToken);
	this->_tptz__GotoPreset::Speed = NULL;
}

void _tptz__GotoPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GotoPreset::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GotoPreset::ProfileToken);
	soap_embedded(soap, &this->_tptz__GotoPreset::PresetToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GotoPreset::PresetToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &this->_tptz__GotoPreset::Speed);
#endif
}

int _tptz__GotoPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GotoPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoPreset(struct soap *soap, const char *tag, int id, const _tptz__GotoPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoPreset), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GotoPreset::ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, &a->_tptz__GotoPreset::PresetToken, ""))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->_tptz__GotoPreset::Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GotoPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GotoPreset(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GotoPreset * SOAP_FMAC4 soap_in__tptz__GotoPreset(struct soap *soap, const char *tag, _tptz__GotoPreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GotoPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPreset, sizeof(_tptz__GotoPreset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GotoPreset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GotoPreset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetToken1 = 1;
	size_t soap_flag_Speed1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GotoPreset::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", &a->_tptz__GotoPreset::PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken1--;
					continue;
				}
			}
			if (soap_flag_Speed1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->_tptz__GotoPreset::Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || soap_flag_PresetToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GotoPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPreset, SOAP_TYPE__tptz__GotoPreset, sizeof(_tptz__GotoPreset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GotoPreset * SOAP_FMAC2 soap_instantiate__tptz__GotoPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GotoPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GotoPreset *p;
	size_t k = sizeof(_tptz__GotoPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GotoPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GotoPreset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GotoPreset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GotoPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GotoPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GotoPreset(soap, tag ? tag : "tptz:GotoPreset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GotoPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GotoPreset(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GotoPreset * SOAP_FMAC4 soap_get__tptz__GotoPreset(struct soap *soap, _tptz__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__RemovePresetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__RemovePresetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__RemovePresetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__RemovePresetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetResponse(struct soap *soap, const char *tag, int id, const _tptz__RemovePresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__RemovePresetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__RemovePresetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__RemovePresetResponse * SOAP_FMAC4 soap_in__tptz__RemovePresetResponse(struct soap *soap, const char *tag, _tptz__RemovePresetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__RemovePresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(_tptz__RemovePresetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__RemovePresetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__RemovePresetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__RemovePresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetResponse, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(_tptz__RemovePresetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__RemovePresetResponse * SOAP_FMAC2 soap_instantiate__tptz__RemovePresetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__RemovePresetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__RemovePresetResponse *p;
	size_t k = sizeof(_tptz__RemovePresetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__RemovePresetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__RemovePresetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__RemovePresetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__RemovePresetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__RemovePresetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__RemovePresetResponse(soap, tag ? tag : "tptz:RemovePresetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__RemovePresetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__RemovePresetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__RemovePresetResponse * SOAP_FMAC4 soap_get__tptz__RemovePresetResponse(struct soap *soap, _tptz__RemovePresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__RemovePreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__RemovePreset::ProfileToken);
	soap_default_tt__ReferenceToken(soap, &this->_tptz__RemovePreset::PresetToken);
}

void _tptz__RemovePreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__RemovePreset::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__RemovePreset::ProfileToken);
	soap_embedded(soap, &this->_tptz__RemovePreset::PresetToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__RemovePreset::PresetToken);
#endif
}

int _tptz__RemovePreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__RemovePreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePreset(struct soap *soap, const char *tag, int id, const _tptz__RemovePreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePreset), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__RemovePreset::ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, &a->_tptz__RemovePreset::PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__RemovePreset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__RemovePreset(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__RemovePreset * SOAP_FMAC4 soap_in__tptz__RemovePreset(struct soap *soap, const char *tag, _tptz__RemovePreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__RemovePreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePreset, sizeof(_tptz__RemovePreset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__RemovePreset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__RemovePreset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__RemovePreset::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", &a->_tptz__RemovePreset::PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || soap_flag_PresetToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__RemovePreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePreset, SOAP_TYPE__tptz__RemovePreset, sizeof(_tptz__RemovePreset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__RemovePreset * SOAP_FMAC2 soap_instantiate__tptz__RemovePreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__RemovePreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__RemovePreset *p;
	size_t k = sizeof(_tptz__RemovePreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__RemovePreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__RemovePreset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__RemovePreset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__RemovePreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__RemovePreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__RemovePreset(soap, tag ? tag : "tptz:RemovePreset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__RemovePreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__RemovePreset(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__RemovePreset * SOAP_FMAC4 soap_get__tptz__RemovePreset(struct soap *soap, _tptz__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__SetPresetResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__SetPresetResponse::PresetToken);
}

void _tptz__SetPresetResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__SetPresetResponse::PresetToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__SetPresetResponse::PresetToken);
#endif
}

int _tptz__SetPresetResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__SetPresetResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetPresetResponse(struct soap *soap, const char *tag, int id, const _tptz__SetPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetPresetResponse), type))
		return soap->error;
	soap_element_result(soap, "tptz:PresetToken");
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, &a->_tptz__SetPresetResponse::PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__SetPresetResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__SetPresetResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__SetPresetResponse * SOAP_FMAC4 soap_in__tptz__SetPresetResponse(struct soap *soap, const char *tag, _tptz__SetPresetResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__SetPresetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(_tptz__SetPresetResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__SetPresetResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__SetPresetResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PresetToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", &a->_tptz__SetPresetResponse::PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PresetToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__SetPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPresetResponse, SOAP_TYPE__tptz__SetPresetResponse, sizeof(_tptz__SetPresetResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__SetPresetResponse * SOAP_FMAC2 soap_instantiate__tptz__SetPresetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__SetPresetResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__SetPresetResponse *p;
	size_t k = sizeof(_tptz__SetPresetResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__SetPresetResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__SetPresetResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__SetPresetResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__SetPresetResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__SetPresetResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__SetPresetResponse(soap, tag ? tag : "tptz:SetPresetResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__SetPresetResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__SetPresetResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__SetPresetResponse * SOAP_FMAC4 soap_get__tptz__SetPresetResponse(struct soap *soap, _tptz__SetPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__SetPreset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__SetPreset::ProfileToken);
	this->_tptz__SetPreset::PresetName = NULL;
	this->_tptz__SetPreset::PresetToken = NULL;
}

void _tptz__SetPreset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__SetPreset::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__SetPreset::ProfileToken);
	soap_serialize_PointerTostd__string(soap, &this->_tptz__SetPreset::PresetName);
	soap_serialize_PointerTott__ReferenceToken(soap, &this->_tptz__SetPreset::PresetToken);
#endif
}

int _tptz__SetPreset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__SetPreset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetPreset(struct soap *soap, const char *tag, int id, const _tptz__SetPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetPreset), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__SetPreset::ProfileToken, ""))
		return soap->error;
	if (soap_out_PointerTostd__string(soap, "tptz:PresetName", -1, &a->_tptz__SetPreset::PresetName, ""))
		return soap->error;
	if (soap_out_PointerTott__ReferenceToken(soap, "tptz:PresetToken", -1, &a->_tptz__SetPreset::PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__SetPreset::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__SetPreset(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__SetPreset * SOAP_FMAC4 soap_in__tptz__SetPreset(struct soap *soap, const char *tag, _tptz__SetPreset *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__SetPreset*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPreset, sizeof(_tptz__SetPreset), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__SetPreset)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__SetPreset *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_PresetName1 = 1;
	size_t soap_flag_PresetToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__SetPreset::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_PresetName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTostd__string(soap, "tptz:PresetName", &a->_tptz__SetPreset::PresetName, "xsd:string"))
				{	soap_flag_PresetName1--;
					continue;
				}
			}
			if (soap_flag_PresetToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_PointerTott__ReferenceToken(soap, "tptz:PresetToken", &a->_tptz__SetPreset::PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__SetPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPreset, SOAP_TYPE__tptz__SetPreset, sizeof(_tptz__SetPreset), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__SetPreset * SOAP_FMAC2 soap_instantiate__tptz__SetPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__SetPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__SetPreset *p;
	size_t k = sizeof(_tptz__SetPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__SetPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__SetPreset);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__SetPreset, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__SetPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__SetPreset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__SetPreset(soap, tag ? tag : "tptz:SetPreset", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__SetPreset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__SetPreset(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__SetPreset * SOAP_FMAC4 soap_get__tptz__SetPreset(struct soap *soap, _tptz__SetPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetPresetsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__PTZPreset(soap, &this->_tptz__GetPresetsResponse::Preset);
}

void _tptz__GetPresetsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PTZPreset(soap, &this->_tptz__GetPresetsResponse::Preset);
#endif
}

int _tptz__GetPresetsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetPresetsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetsResponse(struct soap *soap, const char *tag, int id, const _tptz__GetPresetsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetsResponse), type))
		return soap->error;
	soap_element_result(soap, "tptz:Preset");
	if (soap_out_std__vectorTemplateOfPointerTott__PTZPreset(soap, "tptz:Preset", -1, &a->_tptz__GetPresetsResponse::Preset, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetPresetsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetPresetsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetPresetsResponse * SOAP_FMAC4 soap_in__tptz__GetPresetsResponse(struct soap *soap, const char *tag, _tptz__GetPresetsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetPresetsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(_tptz__GetPresetsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetPresetsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetPresetsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PTZPreset(soap, "tptz:Preset", &a->_tptz__GetPresetsResponse::Preset, "tt:PTZPreset"))
					continue;
			}
			soap_check_result(soap, "tptz:Preset");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GetPresetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetsResponse, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(_tptz__GetPresetsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetPresetsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetPresetsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetPresetsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetPresetsResponse *p;
	size_t k = sizeof(_tptz__GetPresetsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetPresetsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetPresetsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetPresetsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetPresetsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetPresetsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetPresetsResponse(soap, tag ? tag : "tptz:GetPresetsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetPresetsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetPresetsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetPresetsResponse * SOAP_FMAC4 soap_get__tptz__GetPresetsResponse(struct soap *soap, _tptz__GetPresetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetPresets::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetPresets::ProfileToken);
}

void _tptz__GetPresets::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetPresets::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetPresets::ProfileToken);
#endif
}

int _tptz__GetPresets::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetPresets(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresets(struct soap *soap, const char *tag, int id, const _tptz__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresets), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__GetPresets::ProfileToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetPresets::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetPresets(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetPresets * SOAP_FMAC4 soap_in__tptz__GetPresets(struct soap *soap, const char *tag, _tptz__GetPresets *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetPresets*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresets, sizeof(_tptz__GetPresets), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetPresets)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetPresets *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__GetPresets::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetPresets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresets, SOAP_TYPE__tptz__GetPresets, sizeof(_tptz__GetPresets), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetPresets * SOAP_FMAC2 soap_instantiate__tptz__GetPresets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetPresets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetPresets *p;
	size_t k = sizeof(_tptz__GetPresets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetPresets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetPresets);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetPresets, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetPresets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetPresets::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetPresets(soap, tag ? tag : "tptz:GetPresets", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetPresets::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetPresets(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetPresets * SOAP_FMAC4 soap_get__tptz__GetPresets(struct soap *soap, _tptz__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__SendAuxiliaryCommandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AuxiliaryData(soap, &this->_tptz__SendAuxiliaryCommandResponse::AuxiliaryResponse);
}

void _tptz__SendAuxiliaryCommandResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_tt__AuxiliaryData(soap, &this->_tptz__SendAuxiliaryCommandResponse::AuxiliaryResponse);
#endif
}

int _tptz__SendAuxiliaryCommandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__SendAuxiliaryCommandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const _tptz__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse), type))
		return soap->error;
	soap_element_result(soap, "tptz:AuxiliaryResponse");
	if (soap_out_tt__AuxiliaryData(soap, "tptz:AuxiliaryResponse", -1, &a->_tptz__SendAuxiliaryCommandResponse::AuxiliaryResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__SendAuxiliaryCommandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__SendAuxiliaryCommandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, _tptz__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__SendAuxiliaryCommandResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(_tptz__SendAuxiliaryCommandResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__SendAuxiliaryCommandResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__SendAuxiliaryCommandResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_AuxiliaryResponse1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tptz:AuxiliaryResponse", &a->_tptz__SendAuxiliaryCommandResponse::AuxiliaryResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryResponse1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:AuxiliaryResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryResponse1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(_tptz__SendAuxiliaryCommandResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tptz__SendAuxiliaryCommandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__SendAuxiliaryCommandResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__SendAuxiliaryCommandResponse *p;
	size_t k = sizeof(_tptz__SendAuxiliaryCommandResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__SendAuxiliaryCommandResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__SendAuxiliaryCommandResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__SendAuxiliaryCommandResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__SendAuxiliaryCommandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__SendAuxiliaryCommandResponse(soap, tag ? tag : "tptz:SendAuxiliaryCommandResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__SendAuxiliaryCommandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__SendAuxiliaryCommandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tptz__SendAuxiliaryCommandResponse(struct soap *soap, _tptz__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__SendAuxiliaryCommand::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__SendAuxiliaryCommand::ProfileToken);
	soap_default_tt__AuxiliaryData(soap, &this->_tptz__SendAuxiliaryCommand::AuxiliaryData);
}

void _tptz__SendAuxiliaryCommand::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__SendAuxiliaryCommand::ProfileToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__SendAuxiliaryCommand::ProfileToken);
	soap_serialize_tt__AuxiliaryData(soap, &this->_tptz__SendAuxiliaryCommand::AuxiliaryData);
#endif
}

int _tptz__SendAuxiliaryCommand::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__SendAuxiliaryCommand(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const _tptz__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->_tptz__SendAuxiliaryCommand::ProfileToken, ""))
		return soap->error;
	if (soap_out_tt__AuxiliaryData(soap, "tptz:AuxiliaryData", -1, &a->_tptz__SendAuxiliaryCommand::AuxiliaryData, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__SendAuxiliaryCommand::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__SendAuxiliaryCommand(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tptz__SendAuxiliaryCommand *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__SendAuxiliaryCommand*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(_tptz__SendAuxiliaryCommand), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__SendAuxiliaryCommand)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__SendAuxiliaryCommand *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ProfileToken1 = 1;
	size_t soap_flag_AuxiliaryData1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->_tptz__SendAuxiliaryCommand::ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken1--;
					continue;
				}
			}
			if (soap_flag_AuxiliaryData1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__AuxiliaryData(soap, "tptz:AuxiliaryData", &a->_tptz__SendAuxiliaryCommand::AuxiliaryData, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryData1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken1 > 0 || soap_flag_AuxiliaryData1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommand, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(_tptz__SendAuxiliaryCommand), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tptz__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__SendAuxiliaryCommand(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__SendAuxiliaryCommand *p;
	size_t k = sizeof(_tptz__SendAuxiliaryCommand);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__SendAuxiliaryCommand);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__SendAuxiliaryCommand, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__SendAuxiliaryCommand location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__SendAuxiliaryCommand::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__SendAuxiliaryCommand(soap, tag ? tag : "tptz:SendAuxiliaryCommand", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__SendAuxiliaryCommand::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__SendAuxiliaryCommand(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tptz__SendAuxiliaryCommand(struct soap *soap, _tptz__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetConfigurationOptionsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__GetConfigurationOptionsResponse::PTZConfigurationOptions = NULL;
}

void _tptz__GetConfigurationOptionsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfigurationOptions(soap, &this->_tptz__GetConfigurationOptionsResponse::PTZConfigurationOptions);
#endif
}

int _tptz__GetConfigurationOptionsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetConfigurationOptionsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const _tptz__GetConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse), type))
		return soap->error;
	if (a->PTZConfigurationOptions)
		soap_element_result(soap, "tptz:PTZConfigurationOptions");
	if (!a->_tptz__GetConfigurationOptionsResponse::PTZConfigurationOptions)
	{	if (soap_element_empty(soap, "tptz:PTZConfigurationOptions", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZConfigurationOptions(soap, "tptz:PTZConfigurationOptions", -1, &a->_tptz__GetConfigurationOptionsResponse::PTZConfigurationOptions, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetConfigurationOptionsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetConfigurationOptionsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, _tptz__GetConfigurationOptionsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetConfigurationOptionsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(_tptz__GetConfigurationOptionsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetConfigurationOptionsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetConfigurationOptionsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PTZConfigurationOptions1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfigurationOptions1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfigurationOptions(soap, "tptz:PTZConfigurationOptions", &a->_tptz__GetConfigurationOptionsResponse::PTZConfigurationOptions, "tt:PTZConfigurationOptions"))
				{	soap_flag_PTZConfigurationOptions1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PTZConfigurationOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tptz__GetConfigurationOptionsResponse::PTZConfigurationOptions))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(_tptz__GetConfigurationOptionsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetConfigurationOptionsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationOptionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetConfigurationOptionsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetConfigurationOptionsResponse *p;
	size_t k = sizeof(_tptz__GetConfigurationOptionsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetConfigurationOptionsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetConfigurationOptionsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetConfigurationOptionsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetConfigurationOptionsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetConfigurationOptionsResponse(soap, tag ? tag : "tptz:GetConfigurationOptionsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetConfigurationOptionsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetConfigurationOptionsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationOptionsResponse(struct soap *soap, _tptz__GetConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetConfigurationOptions::ConfigurationToken);
}

void _tptz__GetConfigurationOptions::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetConfigurationOptions::ConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetConfigurationOptions::ConfigurationToken);
#endif
}

int _tptz__GetConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, const _tptz__GetConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationOptions), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:ConfigurationToken", -1, &a->_tptz__GetConfigurationOptions::ConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_in__tptz__GetConfigurationOptions(struct soap *soap, const char *tag, _tptz__GetConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetConfigurationOptions*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(_tptz__GetConfigurationOptions), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetConfigurationOptions)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetConfigurationOptions *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_ConfigurationToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:ConfigurationToken", &a->_tptz__GetConfigurationOptions::ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptions, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(_tptz__GetConfigurationOptions), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetConfigurationOptions *p;
	size_t k = sizeof(_tptz__GetConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetConfigurationOptions);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetConfigurationOptions, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetConfigurationOptions(soap, tag ? tag : "tptz:GetConfigurationOptions", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_get__tptz__GetConfigurationOptions(struct soap *soap, _tptz__GetConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__SetConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__SetConfigurationResponse::__SetConfigurationResponse_sequence = NULL;
}

void _tptz__SetConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo__tptz__SetConfigurationResponse_sequence(soap, &this->_tptz__SetConfigurationResponse::__SetConfigurationResponse_sequence);
#endif
}

int _tptz__SetConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__SetConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetConfigurationResponse(struct soap *soap, const char *tag, int id, const _tptz__SetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetConfigurationResponse), type))
		return soap->error;
	if (a->__SetConfigurationResponse_sequence)
		soap_element_result(soap, "-SetConfigurationResponse-sequence");
	if (soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(soap, "-SetConfigurationResponse-sequence", -1, &a->_tptz__SetConfigurationResponse::__SetConfigurationResponse_sequence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__SetConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__SetConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_in__tptz__SetConfigurationResponse(struct soap *soap, const char *tag, _tptz__SetConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__SetConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(_tptz__SetConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__SetConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__SetConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag___SetConfigurationResponse_sequence1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___SetConfigurationResponse_sequence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(soap, "-SetConfigurationResponse-sequence", &a->_tptz__SetConfigurationResponse::__SetConfigurationResponse_sequence, "-tptz:SetConfigurationResponse-sequence"))
				{	soap_flag___SetConfigurationResponse_sequence1--;
					continue;
				}
			}
			soap_check_result(soap, "-SetConfigurationResponse-sequence");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__SetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfigurationResponse, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(_tptz__SetConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__SetConfigurationResponse * SOAP_FMAC2 soap_instantiate__tptz__SetConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__SetConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__SetConfigurationResponse *p;
	size_t k = sizeof(_tptz__SetConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__SetConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__SetConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__SetConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__SetConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__SetConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__SetConfigurationResponse(soap, tag ? tag : "tptz:SetConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__SetConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__SetConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_get__tptz__SetConfigurationResponse(struct soap *soap, _tptz__SetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__SetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__SetConfiguration::PTZConfiguration = NULL;
	soap_default_bool(soap, &this->_tptz__SetConfiguration::ForcePersistence);
}

void _tptz__SetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfiguration(soap, &this->_tptz__SetConfiguration::PTZConfiguration);
	soap_embedded(soap, &this->_tptz__SetConfiguration::ForcePersistence, SOAP_TYPE_bool);
#endif
}

int _tptz__SetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__SetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetConfiguration(struct soap *soap, const char *tag, int id, const _tptz__SetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetConfiguration), type))
		return soap->error;
	if (!a->_tptz__SetConfiguration::PTZConfiguration)
	{	if (soap_element_empty(soap, "tptz:PTZConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->_tptz__SetConfiguration::PTZConfiguration, ""))
		return soap->error;
	if (soap_out_bool(soap, "tptz:ForcePersistence", -1, &a->_tptz__SetConfiguration::ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__SetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__SetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__SetConfiguration * SOAP_FMAC4 soap_in__tptz__SetConfiguration(struct soap *soap, const char *tag, _tptz__SetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__SetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfiguration, sizeof(_tptz__SetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__SetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__SetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PTZConfiguration1 = 1;
	size_t soap_flag_ForcePersistence1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->_tptz__SetConfiguration::PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration1--;
					continue;
				}
			}
			if (soap_flag_ForcePersistence1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_bool(soap, "tptz:ForcePersistence", &a->_tptz__SetConfiguration::ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tptz__SetConfiguration::PTZConfiguration || soap_flag_ForcePersistence1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__SetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfiguration, SOAP_TYPE__tptz__SetConfiguration, sizeof(_tptz__SetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__SetConfiguration * SOAP_FMAC2 soap_instantiate__tptz__SetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__SetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__SetConfiguration *p;
	size_t k = sizeof(_tptz__SetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__SetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__SetConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__SetConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__SetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__SetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__SetConfiguration(soap, tag ? tag : "tptz:SetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__SetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__SetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__SetConfiguration * SOAP_FMAC4 soap_get__tptz__SetConfiguration(struct soap *soap, _tptz__SetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__GetConfigurationResponse::PTZConfiguration = NULL;
}

void _tptz__GetConfigurationResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZConfiguration(soap, &this->_tptz__GetConfigurationResponse::PTZConfiguration);
#endif
}

int _tptz__GetConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationResponse(struct soap *soap, const char *tag, int id, const _tptz__GetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationResponse), type))
		return soap->error;
	if (a->PTZConfiguration)
		soap_element_result(soap, "tptz:PTZConfiguration");
	if (!a->_tptz__GetConfigurationResponse::PTZConfiguration)
	{	if (soap_element_empty(soap, "tptz:PTZConfiguration", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->_tptz__GetConfigurationResponse::PTZConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationResponse(struct soap *soap, const char *tag, _tptz__GetConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetConfigurationResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(_tptz__GetConfigurationResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetConfigurationResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetConfigurationResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PTZConfiguration1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->_tptz__GetConfigurationResponse::PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tptz__GetConfigurationResponse::PTZConfiguration))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationResponse, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(_tptz__GetConfigurationResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetConfigurationResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetConfigurationResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetConfigurationResponse *p;
	size_t k = sizeof(_tptz__GetConfigurationResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetConfigurationResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetConfigurationResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetConfigurationResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetConfigurationResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetConfigurationResponse(soap, tag ? tag : "tptz:GetConfigurationResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationResponse(struct soap *soap, _tptz__GetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetConfiguration::PTZConfigurationToken);
}

void _tptz__GetConfiguration::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetConfiguration::PTZConfigurationToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetConfiguration::PTZConfigurationToken);
#endif
}

int _tptz__GetConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfiguration(struct soap *soap, const char *tag, int id, const _tptz__GetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfiguration), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PTZConfigurationToken", -1, &a->_tptz__GetConfiguration::PTZConfigurationToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetConfiguration * SOAP_FMAC4 soap_in__tptz__GetConfiguration(struct soap *soap, const char *tag, _tptz__GetConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetConfiguration*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfiguration, sizeof(_tptz__GetConfiguration), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetConfiguration)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetConfiguration *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PTZConfigurationToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:PTZConfigurationToken", &a->_tptz__GetConfiguration::PTZConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_PTZConfigurationToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfigurationToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfiguration, SOAP_TYPE__tptz__GetConfiguration, sizeof(_tptz__GetConfiguration), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetConfiguration * SOAP_FMAC2 soap_instantiate__tptz__GetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetConfiguration *p;
	size_t k = sizeof(_tptz__GetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetConfiguration);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetConfiguration, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetConfiguration(soap, tag ? tag : "tptz:GetConfiguration", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetConfiguration * SOAP_FMAC4 soap_get__tptz__GetConfiguration(struct soap *soap, _tptz__GetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, &this->_tptz__GetConfigurationsResponse::PTZConfiguration);
}

void _tptz__GetConfigurationsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, &this->_tptz__GetConfigurationsResponse::PTZConfiguration);
#endif
}

int _tptz__GetConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tptz__GetConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "tptz:PTZConfiguration");
	if (soap_out_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->_tptz__GetConfigurationsResponse::PTZConfiguration, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, _tptz__GetConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetConfigurationsResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(_tptz__GetConfigurationsResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetConfigurationsResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetConfigurationsResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->_tptz__GetConfigurationsResponse::PTZConfiguration, "tt:PTZConfiguration"))
					continue;
			}
			soap_check_result(soap, "tptz:PTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GetConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationsResponse, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(_tptz__GetConfigurationsResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetConfigurationsResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetConfigurationsResponse *p;
	size_t k = sizeof(_tptz__GetConfigurationsResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetConfigurationsResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetConfigurationsResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetConfigurationsResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetConfigurationsResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetConfigurationsResponse(soap, tag ? tag : "tptz:GetConfigurationsResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationsResponse(struct soap *soap, _tptz__GetConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__GetConfigurations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__GetConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurations(struct soap *soap, const char *tag, int id, const _tptz__GetConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetConfigurations * SOAP_FMAC4 soap_in__tptz__GetConfigurations(struct soap *soap, const char *tag, _tptz__GetConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetConfigurations*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurations, sizeof(_tptz__GetConfigurations), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetConfigurations)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetConfigurations *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GetConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurations, SOAP_TYPE__tptz__GetConfigurations, sizeof(_tptz__GetConfigurations), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetConfigurations * SOAP_FMAC2 soap_instantiate__tptz__GetConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetConfigurations *p;
	size_t k = sizeof(_tptz__GetConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetConfigurations);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetConfigurations, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetConfigurations(soap, tag ? tag : "tptz:GetConfigurations", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetConfigurations * SOAP_FMAC4 soap_get__tptz__GetConfigurations(struct soap *soap, _tptz__GetConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetNodeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__GetNodeResponse::PTZNode = NULL;
}

void _tptz__GetNodeResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTott__PTZNode(soap, &this->_tptz__GetNodeResponse::PTZNode);
#endif
}

int _tptz__GetNodeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetNodeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodeResponse(struct soap *soap, const char *tag, int id, const _tptz__GetNodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodeResponse), type))
		return soap->error;
	if (a->PTZNode)
		soap_element_result(soap, "tptz:PTZNode");
	if (!a->_tptz__GetNodeResponse::PTZNode)
	{	if (soap_element_empty(soap, "tptz:PTZNode", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTott__PTZNode(soap, "tptz:PTZNode", -1, &a->_tptz__GetNodeResponse::PTZNode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetNodeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetNodeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetNodeResponse * SOAP_FMAC4 soap_in__tptz__GetNodeResponse(struct soap *soap, const char *tag, _tptz__GetNodeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetNodeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(_tptz__GetNodeResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetNodeResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetNodeResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_PTZNode1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZNode1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTott__PTZNode(soap, "tptz:PTZNode", &a->_tptz__GetNodeResponse::PTZNode, "tt:PTZNode"))
				{	soap_flag_PTZNode1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:PTZNode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tptz__GetNodeResponse::PTZNode))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetNodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodeResponse, SOAP_TYPE__tptz__GetNodeResponse, sizeof(_tptz__GetNodeResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetNodeResponse * SOAP_FMAC2 soap_instantiate__tptz__GetNodeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetNodeResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetNodeResponse *p;
	size_t k = sizeof(_tptz__GetNodeResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetNodeResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetNodeResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetNodeResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetNodeResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetNodeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetNodeResponse(soap, tag ? tag : "tptz:GetNodeResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetNodeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetNodeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetNodeResponse * SOAP_FMAC4 soap_get__tptz__GetNodeResponse(struct soap *soap, _tptz__GetNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetNode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tptz__GetNode::NodeToken);
}

void _tptz__GetNode::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &this->_tptz__GetNode::NodeToken, SOAP_TYPE_tt__ReferenceToken);
	soap_serialize_tt__ReferenceToken(soap, &this->_tptz__GetNode::NodeToken);
#endif
}

int _tptz__GetNode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetNode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNode(struct soap *soap, const char *tag, int id, const _tptz__GetNode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNode), type))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:NodeToken", -1, &a->_tptz__GetNode::NodeToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetNode::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetNode(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetNode * SOAP_FMAC4 soap_in__tptz__GetNode(struct soap *soap, const char *tag, _tptz__GetNode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetNode*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNode, sizeof(_tptz__GetNode), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetNode)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetNode *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_NodeToken1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NodeToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_tt__ReferenceToken(soap, "tptz:NodeToken", &a->_tptz__GetNode::NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken1--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NodeToken1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNode, SOAP_TYPE__tptz__GetNode, sizeof(_tptz__GetNode), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetNode * SOAP_FMAC2 soap_instantiate__tptz__GetNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetNode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetNode *p;
	size_t k = sizeof(_tptz__GetNode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetNode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetNode);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetNode, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetNode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetNode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetNode(soap, tag ? tag : "tptz:GetNode", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetNode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetNode(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetNode * SOAP_FMAC4 soap_get__tptz__GetNode(struct soap *soap, _tptz__GetNode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetNodesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTott__PTZNode(soap, &this->_tptz__GetNodesResponse::PTZNode);
}

void _tptz__GetNodesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_std__vectorTemplateOfPointerTott__PTZNode(soap, &this->_tptz__GetNodesResponse::PTZNode);
#endif
}

int _tptz__GetNodesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetNodesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodesResponse(struct soap *soap, const char *tag, int id, const _tptz__GetNodesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodesResponse), type))
		return soap->error;
	soap_element_result(soap, "tptz:PTZNode");
	if (soap_out_std__vectorTemplateOfPointerTott__PTZNode(soap, "tptz:PTZNode", -1, &a->_tptz__GetNodesResponse::PTZNode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetNodesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetNodesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetNodesResponse * SOAP_FMAC4 soap_in__tptz__GetNodesResponse(struct soap *soap, const char *tag, _tptz__GetNodesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetNodesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(_tptz__GetNodesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetNodesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetNodesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_std__vectorTemplateOfPointerTott__PTZNode(soap, "tptz:PTZNode", &a->_tptz__GetNodesResponse::PTZNode, "tt:PTZNode"))
					continue;
			}
			soap_check_result(soap, "tptz:PTZNode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GetNodesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodesResponse, SOAP_TYPE__tptz__GetNodesResponse, sizeof(_tptz__GetNodesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetNodesResponse * SOAP_FMAC2 soap_instantiate__tptz__GetNodesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetNodesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetNodesResponse *p;
	size_t k = sizeof(_tptz__GetNodesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetNodesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetNodesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetNodesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetNodesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetNodesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetNodesResponse(soap, tag ? tag : "tptz:GetNodesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetNodesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetNodesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetNodesResponse * SOAP_FMAC4 soap_get__tptz__GetNodesResponse(struct soap *soap, _tptz__GetNodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetNodes::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__GetNodes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__GetNodes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetNodes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodes(struct soap *soap, const char *tag, int id, const _tptz__GetNodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetNodes::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetNodes(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetNodes * SOAP_FMAC4 soap_in__tptz__GetNodes(struct soap *soap, const char *tag, _tptz__GetNodes *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetNodes*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodes, sizeof(_tptz__GetNodes), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetNodes)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetNodes *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GetNodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodes, SOAP_TYPE__tptz__GetNodes, sizeof(_tptz__GetNodes), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetNodes * SOAP_FMAC2 soap_instantiate__tptz__GetNodes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetNodes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetNodes *p;
	size_t k = sizeof(_tptz__GetNodes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetNodes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetNodes);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetNodes, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetNodes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetNodes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetNodes(soap, tag ? tag : "tptz:GetNodes", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetNodes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetNodes(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetNodes * SOAP_FMAC4 soap_get__tptz__GetNodes(struct soap *soap, _tptz__GetNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetServiceCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tptz__GetServiceCapabilitiesResponse::Capabilities = NULL;
}

void _tptz__GetServiceCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTotptz__Capabilities(soap, &this->_tptz__GetServiceCapabilitiesResponse::Capabilities);
#endif
}

int _tptz__GetServiceCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetServiceCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tptz__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tptz:Capabilities");
	if (!a->_tptz__GetServiceCapabilitiesResponse::Capabilities)
	{	if (soap_element_empty(soap, "tptz:Capabilities", 0, NULL))
			return soap->error;
	}
	else if (soap_out_PointerTotptz__Capabilities(soap, "tptz:Capabilities", -1, &a->_tptz__GetServiceCapabilitiesResponse::Capabilities, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetServiceCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetServiceCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _tptz__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetServiceCapabilitiesResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(_tptz__GetServiceCapabilitiesResponse), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetServiceCapabilitiesResponse)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetServiceCapabilitiesResponse *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTotptz__Capabilities(soap, "tptz:Capabilities", &a->_tptz__GetServiceCapabilitiesResponse::Capabilities, "tptz:Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			}
			soap_check_result(soap, "tptz:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->_tptz__GetServiceCapabilitiesResponse::Capabilities))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (_tptz__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(_tptz__GetServiceCapabilitiesResponse), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tptz__GetServiceCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetServiceCapabilitiesResponse(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetServiceCapabilitiesResponse *p;
	size_t k = sizeof(_tptz__GetServiceCapabilitiesResponse);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetServiceCapabilitiesResponse);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetServiceCapabilitiesResponse, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetServiceCapabilitiesResponse location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetServiceCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetServiceCapabilitiesResponse(soap, tag ? tag : "tptz:GetServiceCapabilitiesResponse", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetServiceCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetServiceCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tptz__GetServiceCapabilitiesResponse(struct soap *soap, _tptz__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void _tptz__GetServiceCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
}

void _tptz__GetServiceCapabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int _tptz__GetServiceCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tptz__GetServiceCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const _tptz__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *_tptz__GetServiceCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in__tptz__GetServiceCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_in__tptz__GetServiceCapabilities(struct soap *soap, const char *tag, _tptz__GetServiceCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tptz__GetServiceCapabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(_tptz__GetServiceCapabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE__tptz__GetServiceCapabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (_tptz__GetServiceCapabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tptz__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilities, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(_tptz__GetServiceCapabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 _tptz__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate__tptz__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tptz__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	_tptz__GetServiceCapabilities *p;
	size_t k = sizeof(_tptz__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__tptz__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, _tptz__GetServiceCapabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, _tptz__GetServiceCapabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated _tptz__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int _tptz__GetServiceCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out__tptz__GetServiceCapabilities(soap, tag ? tag : "tptz:GetServiceCapabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tptz__GetServiceCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tptz__GetServiceCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_get__tptz__GetServiceCapabilities(struct soap *soap, _tptz__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void tptz__Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tptz__Capabilities::EFlip = NULL;
	this->tptz__Capabilities::Reverse = NULL;
	this->tptz__Capabilities::GetCompatibleConfigurations = NULL;
	this->tptz__Capabilities::MoveStatus = NULL;
	this->tptz__Capabilities::StatusPosition = NULL;
	this->tptz__Capabilities::MoveAndTrack = NULL;
}

void tptz__Capabilities::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int tptz__Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tptz__Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tptz__Capabilities(struct soap *soap, const char *tag, int id, const tptz__Capabilities *a, const char *type)
{
	if (((tptz__Capabilities*)a)->EFlip)
	{	soap_set_attr(soap, "EFlip", soap_bool2s(soap, *((tptz__Capabilities*)a)->EFlip), 1);
	}
	if (((tptz__Capabilities*)a)->Reverse)
	{	soap_set_attr(soap, "Reverse", soap_bool2s(soap, *((tptz__Capabilities*)a)->Reverse), 1);
	}
	if (((tptz__Capabilities*)a)->GetCompatibleConfigurations)
	{	soap_set_attr(soap, "GetCompatibleConfigurations", soap_bool2s(soap, *((tptz__Capabilities*)a)->GetCompatibleConfigurations), 1);
	}
	if (((tptz__Capabilities*)a)->MoveStatus)
	{	soap_set_attr(soap, "MoveStatus", soap_bool2s(soap, *((tptz__Capabilities*)a)->MoveStatus), 1);
	}
	if (((tptz__Capabilities*)a)->StatusPosition)
	{	soap_set_attr(soap, "StatusPosition", soap_bool2s(soap, *((tptz__Capabilities*)a)->StatusPosition), 1);
	}
	if (((tptz__Capabilities*)a)->MoveAndTrack)
	{	soap_set_attr(soap, "MoveAndTrack", soap_tt__StringList2s(soap, *((tptz__Capabilities*)a)->MoveAndTrack), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tptz__Capabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tptz__Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_tptz__Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 tptz__Capabilities * SOAP_FMAC4 soap_in_tptz__Capabilities(struct soap *soap, const char *tag, tptz__Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tptz__Capabilities*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tptz__Capabilities, sizeof(tptz__Capabilities), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	if (soap->alloced && soap->alloced != SOAP_TYPE_tptz__Capabilities)
	{	soap_revert(soap);
		*soap->id = '\0';
		return (tptz__Capabilities *)a->soap_in(soap, tag, type);
	}
	if (soap->alloced)
		a->soap_default(soap);
	{
		const char *t = soap_attr_value(soap, "EFlip", 5, 0);
		if (t)
		{
			if (!(((tptz__Capabilities*)a)->EFlip = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tptz__Capabilities*)a)->EFlip))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "Reverse", 5, 0);
		if (t)
		{
			if (!(((tptz__Capabilities*)a)->Reverse = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tptz__Capabilities*)a)->Reverse))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "GetCompatibleConfigurations", 5, 0);
		if (t)
		{
			if (!(((tptz__Capabilities*)a)->GetCompatibleConfigurations = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tptz__Capabilities*)a)->GetCompatibleConfigurations))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MoveStatus", 5, 0);
		if (t)
		{
			if (!(((tptz__Capabilities*)a)->MoveStatus = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tptz__Capabilities*)a)->MoveStatus))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "StatusPosition", 5, 0);
		if (t)
		{
			if (!(((tptz__Capabilities*)a)->StatusPosition = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tptz__Capabilities*)a)->StatusPosition))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{
		const char *t = soap_attr_value(soap, "MoveAndTrack", 1, 0);
		if (t)
		{
			if (!(((tptz__Capabilities*)a)->MoveAndTrack = soap_new_tt__StringList(soap)))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2tt__StringList(soap, t, ((tptz__Capabilities*)a)->MoveAndTrack))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tptz__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tptz__Capabilities, SOAP_TYPE_tptz__Capabilities, sizeof(tptz__Capabilities), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tptz__Capabilities * SOAP_FMAC2 soap_instantiate_tptz__Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tptz__Capabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	tptz__Capabilities *p;
	size_t k = sizeof(tptz__Capabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_tptz__Capabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, tptz__Capabilities);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, tptz__Capabilities, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated tptz__Capabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int tptz__Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_tptz__Capabilities(soap, tag ? tag : "tptz:Capabilities", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tptz__Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tptz__Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 tptz__Capabilities * SOAP_FMAC4 soap_get_tptz__Capabilities(struct soap *soap, tptz__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tptz__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xml__lang(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out__xml__lang(soap, tag ? tag : "xml:lang", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__token), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__token, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__token, SOAP_TYPE_xsd__token, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__token(soap, tag ? tag : "xsd:token", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__nonNegativeInteger), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "\\+?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__nonNegativeInteger, SOAP_TYPE_xsd__nonNegativeInteger, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__nonNegativeInteger(soap, tag ? tag : "xsd:nonNegativeInteger", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?\\d+")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__integer, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__duration(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__duration(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__duration), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__duration(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[-+]?P(\\d+Y)?(\\d+M)?(\\d+D)?(T(\\d+H)?(\\d+M)?(\\d+(\\.\\d*)?S)?)?")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__duration, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__duration, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__duration(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__duration(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anyURI), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 4, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anyURI, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anyURI, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__anySimpleType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__anySimpleType, SOAP_TYPE_xsd__anySimpleType, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__anySimpleType(soap, tag ? tag : "xsd:anySimpleType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__NCName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 5, 0, -1, "[\\i-[:]][\\c-[:]]*")))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__NCName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__NCName, SOAP_TYPE_xsd__NCName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__NCName(soap, tag ? tag : "xsd:NCName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__hexBinary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
}

void xsd__hexBinary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_array_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__hexBinary);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__hexBinary2s(struct soap *soap, xsd__hexBinary a)
{
	return soap_s2hex(soap, a.__ptr, NULL, a.__size);
}

int xsd__hexBinary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__hexBinary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__hexBinary(struct soap *soap, const char *tag, int id, const xsd__hexBinary *a, const char *type)
{
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__hexBinary, NULL);
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_puthex(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__hexBinary(struct soap *soap, const char *s, xsd__hexBinary *a)
{
	a->__ptr = (unsigned char*)soap_hex2s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__hexBinary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__hexBinary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_in_xsd__hexBinary(struct soap *soap, const char *tag, xsd__hexBinary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":hexBinary"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__hexBinary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && *soap->href != '#')
	{
		a->__ptr = soap_gethex(soap, &a->__size);
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (xsd__hexBinary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__hexBinary, SOAP_TYPE_xsd__hexBinary, sizeof(xsd__hexBinary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__hexBinary * SOAP_FMAC2 soap_instantiate_xsd__hexBinary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__hexBinary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__hexBinary *p;
	size_t k = sizeof(xsd__hexBinary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__hexBinary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__hexBinary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__hexBinary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__hexBinary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__hexBinary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__hexBinary(soap, tag ? tag : "xsd:hexBinary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__hexBinary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__hexBinary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__hexBinary * SOAP_FMAC4 soap_get_xsd__hexBinary(struct soap *soap, xsd__hexBinary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__hexBinary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__base64Binary::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__ptr = NULL;
	this->__size = 0;
	this->id = NULL;
	this->type = NULL;
	this->options = NULL;
}

void xsd__base64Binary::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (this->__ptr)
		(void)soap_attachment_reference(soap, this, this->__ptr, this->__size, SOAP_TYPE_xsd__base64Binary, this->id, this->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap_xsd__base64Binary2s(struct soap *soap, xsd__base64Binary a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

int xsd__base64Binary::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__base64Binary(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__base64Binary(struct soap *soap, const char *tag, int id, const xsd__base64Binary *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE_xsd__base64Binary);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE_xsd__base64Binary, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2xsd__base64Binary(struct soap *soap, const char *s, xsd__base64Binary *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

void *xsd__base64Binary::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__base64Binary(soap, tag, this, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_in_xsd__base64Binary(struct soap *soap, const char *tag, xsd__base64Binary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (xsd__base64Binary*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
	if (!a)
		return NULL;
	a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (xsd__base64Binary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xsd__base64Binary, SOAP_TYPE_xsd__base64Binary, sizeof(xsd__base64Binary), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__base64Binary(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__base64Binary *p;
	size_t k = sizeof(xsd__base64Binary);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__base64Binary, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__base64Binary);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__base64Binary, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__base64Binary location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__base64Binary::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__base64Binary(soap, tag ? tag : "xsd:base64Binary", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__base64Binary::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__base64Binary(soap, this, tag, type);
}

SOAP_FMAC3 xsd__base64Binary * SOAP_FMAC4 soap_get_xsd__base64Binary(struct soap *soap, xsd__base64Binary *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__QName(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__QName(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__QName), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_xsd__QName(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 2, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__QName, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_xsd__QName, SOAP_TYPE_xsd__QName, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_xsd__QName(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__QName(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__QName, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__QName(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_xsd__QName(soap, tag ? tag : "xsd:QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__QName(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && *soap->href != '#')
	{	char *t;
		s = (std::string*)soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1, NULL)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType, soap_instantiate, soap_fbase), 0, SOAP_TYPE_std__string, SOAP_TYPE_std__string, sizeof(std::string), 0, soap_finsert, NULL);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::string *p;
	size_t k = sizeof(std::string);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::string);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::string, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::string location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	if (soap_out_std__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void xsd__anyType::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::__item = NULL;
}

void xsd__anyType::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

int xsd__anyType::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_xsd__anyType(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyType(struct soap *soap, const char *tag, int id, const xsd__anyType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_outliteral(soap, tag, (char*const*)&a->xsd__anyType::__item, NULL);
}

void *xsd__anyType::soap_in(struct soap *soap, const char *tag, const char *type)
{
	return soap_in_xsd__anyType(soap, tag, this, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_in_xsd__anyType(struct soap *soap, const char *tag, xsd__anyType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (xsd__anyType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__anyType, sizeof(xsd__anyType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced && soap->alloced != SOAP_TYPE_xsd__anyType)
		return (xsd__anyType *)a->soap_in(soap, tag, type);
	if (soap->alloced)
		a->soap_default(soap);
	if (!soap_inliteral(soap, tag, (char**)&a->xsd__anyType::__item))
		return NULL;
	return a;
}

SOAP_FMAC1 xsd__anyType * SOAP_FMAC2 soap_instantiate_xsd__anyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__anyType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	xsd__anyType *p;
	size_t k = sizeof(xsd__anyType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_xsd__anyType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, xsd__anyType);
		if (p)
			p->soap = soap;
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, xsd__anyType, n);
		k *= n;
		if (p)
			for (int i = 0; i < n; i++)
				p[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated xsd__anyType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

int xsd__anyType::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	if (soap_out_xsd__anyType(soap, tag ? tag : "xsd:anyType", -2, this, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *xsd__anyType::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_xsd__anyType(soap, this, tag, type);
}

SOAP_FMAC3 xsd__anyType * SOAP_FMAC4 soap_get_xsd__anyType(struct soap *soap, xsd__anyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__MoveAndStartTracking(struct soap *soap, struct __tptz__MoveAndStartTracking *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__MoveAndStartTracking = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__MoveAndStartTracking(struct soap *soap, const struct __tptz__MoveAndStartTracking *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__MoveAndStartTracking(soap, &a->tptz__MoveAndStartTracking);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__MoveAndStartTracking(struct soap *soap, const char *tag, int id, const struct __tptz__MoveAndStartTracking *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__MoveAndStartTracking(soap, "tptz:MoveAndStartTracking", -1, &a->tptz__MoveAndStartTracking, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__MoveAndStartTracking * SOAP_FMAC4 soap_in___tptz__MoveAndStartTracking(struct soap *soap, const char *tag, struct __tptz__MoveAndStartTracking *a, const char *type)
{
	size_t soap_flag_tptz__MoveAndStartTracking = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__MoveAndStartTracking*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__MoveAndStartTracking, sizeof(struct __tptz__MoveAndStartTracking), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__MoveAndStartTracking(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__MoveAndStartTracking && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__MoveAndStartTracking(soap, "tptz:MoveAndStartTracking", &a->tptz__MoveAndStartTracking, ""))
				{	soap_flag_tptz__MoveAndStartTracking--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__MoveAndStartTracking * SOAP_FMAC2 soap_instantiate___tptz__MoveAndStartTracking(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__MoveAndStartTracking(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__MoveAndStartTracking *p;
	size_t k = sizeof(struct __tptz__MoveAndStartTracking);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__MoveAndStartTracking, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__MoveAndStartTracking);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__MoveAndStartTracking, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__MoveAndStartTracking location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__MoveAndStartTracking(struct soap *soap, const struct __tptz__MoveAndStartTracking *a, const char *tag, const char *type)
{
	if (soap_out___tptz__MoveAndStartTracking(soap, tag ? tag : "-tptz:MoveAndStartTracking", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__MoveAndStartTracking * SOAP_FMAC4 soap_get___tptz__MoveAndStartTracking(struct soap *soap, struct __tptz__MoveAndStartTracking *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__MoveAndStartTracking(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetCompatibleConfigurations(struct soap *soap, struct __tptz__GetCompatibleConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetCompatibleConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetCompatibleConfigurations(struct soap *soap, const struct __tptz__GetCompatibleConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetCompatibleConfigurations(soap, &a->tptz__GetCompatibleConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, int id, const struct __tptz__GetCompatibleConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetCompatibleConfigurations(soap, "tptz:GetCompatibleConfigurations", -1, &a->tptz__GetCompatibleConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_in___tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, struct __tptz__GetCompatibleConfigurations *a, const char *type)
{
	size_t soap_flag_tptz__GetCompatibleConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetCompatibleConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetCompatibleConfigurations, sizeof(struct __tptz__GetCompatibleConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetCompatibleConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetCompatibleConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetCompatibleConfigurations(soap, "tptz:GetCompatibleConfigurations", &a->tptz__GetCompatibleConfigurations, ""))
				{	soap_flag_tptz__GetCompatibleConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetCompatibleConfigurations * SOAP_FMAC2 soap_instantiate___tptz__GetCompatibleConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetCompatibleConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetCompatibleConfigurations *p;
	size_t k = sizeof(struct __tptz__GetCompatibleConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetCompatibleConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetCompatibleConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetCompatibleConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetCompatibleConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetCompatibleConfigurations(struct soap *soap, const struct __tptz__GetCompatibleConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetCompatibleConfigurations(soap, tag ? tag : "-tptz:GetCompatibleConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetCompatibleConfigurations * SOAP_FMAC4 soap_get___tptz__GetCompatibleConfigurations(struct soap *soap, struct __tptz__GetCompatibleConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetCompatibleConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__RemovePresetTour(struct soap *soap, struct __tptz__RemovePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__RemovePresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__RemovePresetTour(struct soap *soap, const struct __tptz__RemovePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__RemovePresetTour(soap, &a->tptz__RemovePresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__RemovePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__RemovePresetTour(soap, "tptz:RemovePresetTour", -1, &a->tptz__RemovePresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RemovePresetTour * SOAP_FMAC4 soap_in___tptz__RemovePresetTour(struct soap *soap, const char *tag, struct __tptz__RemovePresetTour *a, const char *type)
{
	size_t soap_flag_tptz__RemovePresetTour = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__RemovePresetTour*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__RemovePresetTour, sizeof(struct __tptz__RemovePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__RemovePresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__RemovePresetTour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__RemovePresetTour(soap, "tptz:RemovePresetTour", &a->tptz__RemovePresetTour, ""))
				{	soap_flag_tptz__RemovePresetTour--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__RemovePresetTour * SOAP_FMAC2 soap_instantiate___tptz__RemovePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__RemovePresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__RemovePresetTour *p;
	size_t k = sizeof(struct __tptz__RemovePresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__RemovePresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__RemovePresetTour);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__RemovePresetTour, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__RemovePresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__RemovePresetTour(struct soap *soap, const struct __tptz__RemovePresetTour *a, const char *tag, const char *type)
{
	if (soap_out___tptz__RemovePresetTour(soap, tag ? tag : "-tptz:RemovePresetTour", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RemovePresetTour * SOAP_FMAC4 soap_get___tptz__RemovePresetTour(struct soap *soap, struct __tptz__RemovePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__OperatePresetTour(struct soap *soap, struct __tptz__OperatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__OperatePresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__OperatePresetTour(struct soap *soap, const struct __tptz__OperatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__OperatePresetTour(soap, &a->tptz__OperatePresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__OperatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__OperatePresetTour(soap, "tptz:OperatePresetTour", -1, &a->tptz__OperatePresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__OperatePresetTour * SOAP_FMAC4 soap_in___tptz__OperatePresetTour(struct soap *soap, const char *tag, struct __tptz__OperatePresetTour *a, const char *type)
{
	size_t soap_flag_tptz__OperatePresetTour = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__OperatePresetTour*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__OperatePresetTour, sizeof(struct __tptz__OperatePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__OperatePresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__OperatePresetTour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__OperatePresetTour(soap, "tptz:OperatePresetTour", &a->tptz__OperatePresetTour, ""))
				{	soap_flag_tptz__OperatePresetTour--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__OperatePresetTour * SOAP_FMAC2 soap_instantiate___tptz__OperatePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__OperatePresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__OperatePresetTour *p;
	size_t k = sizeof(struct __tptz__OperatePresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__OperatePresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__OperatePresetTour);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__OperatePresetTour, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__OperatePresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__OperatePresetTour(struct soap *soap, const struct __tptz__OperatePresetTour *a, const char *tag, const char *type)
{
	if (soap_out___tptz__OperatePresetTour(soap, tag ? tag : "-tptz:OperatePresetTour", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__OperatePresetTour * SOAP_FMAC4 soap_get___tptz__OperatePresetTour(struct soap *soap, struct __tptz__OperatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__ModifyPresetTour(struct soap *soap, struct __tptz__ModifyPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__ModifyPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__ModifyPresetTour(struct soap *soap, const struct __tptz__ModifyPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__ModifyPresetTour(soap, &a->tptz__ModifyPresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__ModifyPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__ModifyPresetTour(soap, "tptz:ModifyPresetTour", -1, &a->tptz__ModifyPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__ModifyPresetTour * SOAP_FMAC4 soap_in___tptz__ModifyPresetTour(struct soap *soap, const char *tag, struct __tptz__ModifyPresetTour *a, const char *type)
{
	size_t soap_flag_tptz__ModifyPresetTour = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__ModifyPresetTour*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__ModifyPresetTour, sizeof(struct __tptz__ModifyPresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__ModifyPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__ModifyPresetTour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__ModifyPresetTour(soap, "tptz:ModifyPresetTour", &a->tptz__ModifyPresetTour, ""))
				{	soap_flag_tptz__ModifyPresetTour--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__ModifyPresetTour * SOAP_FMAC2 soap_instantiate___tptz__ModifyPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__ModifyPresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__ModifyPresetTour *p;
	size_t k = sizeof(struct __tptz__ModifyPresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__ModifyPresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__ModifyPresetTour);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__ModifyPresetTour, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__ModifyPresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__ModifyPresetTour(struct soap *soap, const struct __tptz__ModifyPresetTour *a, const char *tag, const char *type)
{
	if (soap_out___tptz__ModifyPresetTour(soap, tag ? tag : "-tptz:ModifyPresetTour", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__ModifyPresetTour * SOAP_FMAC4 soap_get___tptz__ModifyPresetTour(struct soap *soap, struct __tptz__ModifyPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__CreatePresetTour(struct soap *soap, struct __tptz__CreatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__CreatePresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__CreatePresetTour(struct soap *soap, const struct __tptz__CreatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__CreatePresetTour(soap, &a->tptz__CreatePresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__CreatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__CreatePresetTour(soap, "tptz:CreatePresetTour", -1, &a->tptz__CreatePresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__CreatePresetTour * SOAP_FMAC4 soap_in___tptz__CreatePresetTour(struct soap *soap, const char *tag, struct __tptz__CreatePresetTour *a, const char *type)
{
	size_t soap_flag_tptz__CreatePresetTour = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__CreatePresetTour*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__CreatePresetTour, sizeof(struct __tptz__CreatePresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__CreatePresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__CreatePresetTour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__CreatePresetTour(soap, "tptz:CreatePresetTour", &a->tptz__CreatePresetTour, ""))
				{	soap_flag_tptz__CreatePresetTour--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__CreatePresetTour * SOAP_FMAC2 soap_instantiate___tptz__CreatePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__CreatePresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__CreatePresetTour *p;
	size_t k = sizeof(struct __tptz__CreatePresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__CreatePresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__CreatePresetTour);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__CreatePresetTour, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__CreatePresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__CreatePresetTour(struct soap *soap, const struct __tptz__CreatePresetTour *a, const char *tag, const char *type)
{
	if (soap_out___tptz__CreatePresetTour(soap, tag ? tag : "-tptz:CreatePresetTour", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__CreatePresetTour * SOAP_FMAC4 soap_get___tptz__CreatePresetTour(struct soap *soap, struct __tptz__CreatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetPresetTourOptions(struct soap *soap, struct __tptz__GetPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetPresetTourOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetPresetTourOptions(struct soap *soap, const struct __tptz__GetPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetPresetTourOptions(soap, &a->tptz__GetPresetTourOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, const struct __tptz__GetPresetTourOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetPresetTourOptions(soap, "tptz:GetPresetTourOptions", -1, &a->tptz__GetPresetTourOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTourOptions * SOAP_FMAC4 soap_in___tptz__GetPresetTourOptions(struct soap *soap, const char *tag, struct __tptz__GetPresetTourOptions *a, const char *type)
{
	size_t soap_flag_tptz__GetPresetTourOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetPresetTourOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetPresetTourOptions, sizeof(struct __tptz__GetPresetTourOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetPresetTourOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetPresetTourOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetPresetTourOptions(soap, "tptz:GetPresetTourOptions", &a->tptz__GetPresetTourOptions, ""))
				{	soap_flag_tptz__GetPresetTourOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTourOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetPresetTourOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetPresetTourOptions *p;
	size_t k = sizeof(struct __tptz__GetPresetTourOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetPresetTourOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetPresetTourOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetPresetTourOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetPresetTourOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetPresetTourOptions(struct soap *soap, const struct __tptz__GetPresetTourOptions *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetPresetTourOptions(soap, tag ? tag : "-tptz:GetPresetTourOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTourOptions * SOAP_FMAC4 soap_get___tptz__GetPresetTourOptions(struct soap *soap, struct __tptz__GetPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetPresetTour(struct soap *soap, struct __tptz__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetPresetTour(struct soap *soap, const struct __tptz__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetPresetTour(soap, &a->tptz__GetPresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetPresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__GetPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetPresetTour(soap, "tptz:GetPresetTour", -1, &a->tptz__GetPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTour * SOAP_FMAC4 soap_in___tptz__GetPresetTour(struct soap *soap, const char *tag, struct __tptz__GetPresetTour *a, const char *type)
{
	size_t soap_flag_tptz__GetPresetTour = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetPresetTour*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetPresetTour, sizeof(struct __tptz__GetPresetTour), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetPresetTour && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetPresetTour(soap, "tptz:GetPresetTour", &a->tptz__GetPresetTour, ""))
				{	soap_flag_tptz__GetPresetTour--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetPresetTour * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetPresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetPresetTour *p;
	size_t k = sizeof(struct __tptz__GetPresetTour);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetPresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetPresetTour);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetPresetTour, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetPresetTour location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetPresetTour(struct soap *soap, const struct __tptz__GetPresetTour *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetPresetTour(soap, tag ? tag : "-tptz:GetPresetTour", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTour * SOAP_FMAC4 soap_get___tptz__GetPresetTour(struct soap *soap, struct __tptz__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetPresetTours(struct soap *soap, struct __tptz__GetPresetTours *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetPresetTours = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetPresetTours(struct soap *soap, const struct __tptz__GetPresetTours *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetPresetTours(soap, &a->tptz__GetPresetTours);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetPresetTours(struct soap *soap, const char *tag, int id, const struct __tptz__GetPresetTours *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetPresetTours(soap, "tptz:GetPresetTours", -1, &a->tptz__GetPresetTours, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTours * SOAP_FMAC4 soap_in___tptz__GetPresetTours(struct soap *soap, const char *tag, struct __tptz__GetPresetTours *a, const char *type)
{
	size_t soap_flag_tptz__GetPresetTours = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetPresetTours*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetPresetTours, sizeof(struct __tptz__GetPresetTours), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetPresetTours(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetPresetTours && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetPresetTours(soap, "tptz:GetPresetTours", &a->tptz__GetPresetTours, ""))
				{	soap_flag_tptz__GetPresetTours--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetPresetTours * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTours(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetPresetTours(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetPresetTours *p;
	size_t k = sizeof(struct __tptz__GetPresetTours);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetPresetTours, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetPresetTours);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetPresetTours, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetPresetTours location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetPresetTours(struct soap *soap, const struct __tptz__GetPresetTours *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetPresetTours(soap, tag ? tag : "-tptz:GetPresetTours", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTours * SOAP_FMAC4 soap_get___tptz__GetPresetTours(struct soap *soap, struct __tptz__GetPresetTours *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__Stop(struct soap *soap, struct __tptz__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__Stop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__Stop(struct soap *soap, const struct __tptz__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__Stop(soap, &a->tptz__Stop);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__Stop(struct soap *soap, const char *tag, int id, const struct __tptz__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__Stop(soap, "tptz:Stop", -1, &a->tptz__Stop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__Stop * SOAP_FMAC4 soap_in___tptz__Stop(struct soap *soap, const char *tag, struct __tptz__Stop *a, const char *type)
{
	size_t soap_flag_tptz__Stop = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__Stop*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__Stop, sizeof(struct __tptz__Stop), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__Stop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__Stop && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__Stop(soap, "tptz:Stop", &a->tptz__Stop, ""))
				{	soap_flag_tptz__Stop--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__Stop * SOAP_FMAC2 soap_instantiate___tptz__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__Stop(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__Stop *p;
	size_t k = sizeof(struct __tptz__Stop);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__Stop, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__Stop);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__Stop, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__Stop location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__Stop(struct soap *soap, const struct __tptz__Stop *a, const char *tag, const char *type)
{
	if (soap_out___tptz__Stop(soap, tag ? tag : "-tptz:Stop", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__Stop * SOAP_FMAC4 soap_get___tptz__Stop(struct soap *soap, struct __tptz__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GeoMove(struct soap *soap, struct __tptz__GeoMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GeoMove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GeoMove(struct soap *soap, const struct __tptz__GeoMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GeoMove(soap, &a->tptz__GeoMove);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GeoMove(struct soap *soap, const char *tag, int id, const struct __tptz__GeoMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GeoMove(soap, "tptz:GeoMove", -1, &a->tptz__GeoMove, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GeoMove * SOAP_FMAC4 soap_in___tptz__GeoMove(struct soap *soap, const char *tag, struct __tptz__GeoMove *a, const char *type)
{
	size_t soap_flag_tptz__GeoMove = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GeoMove*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GeoMove, sizeof(struct __tptz__GeoMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GeoMove(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GeoMove && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GeoMove(soap, "tptz:GeoMove", &a->tptz__GeoMove, ""))
				{	soap_flag_tptz__GeoMove--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GeoMove * SOAP_FMAC2 soap_instantiate___tptz__GeoMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GeoMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GeoMove *p;
	size_t k = sizeof(struct __tptz__GeoMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GeoMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GeoMove);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GeoMove, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GeoMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GeoMove(struct soap *soap, const struct __tptz__GeoMove *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GeoMove(soap, tag ? tag : "-tptz:GeoMove", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GeoMove * SOAP_FMAC4 soap_get___tptz__GeoMove(struct soap *soap, struct __tptz__GeoMove *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GeoMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__AbsoluteMove(struct soap *soap, struct __tptz__AbsoluteMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__AbsoluteMove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__AbsoluteMove(struct soap *soap, const struct __tptz__AbsoluteMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__AbsoluteMove(soap, &a->tptz__AbsoluteMove);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, const struct __tptz__AbsoluteMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__AbsoluteMove(soap, "tptz:AbsoluteMove", -1, &a->tptz__AbsoluteMove, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__AbsoluteMove * SOAP_FMAC4 soap_in___tptz__AbsoluteMove(struct soap *soap, const char *tag, struct __tptz__AbsoluteMove *a, const char *type)
{
	size_t soap_flag_tptz__AbsoluteMove = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__AbsoluteMove*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__AbsoluteMove, sizeof(struct __tptz__AbsoluteMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__AbsoluteMove(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__AbsoluteMove && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__AbsoluteMove(soap, "tptz:AbsoluteMove", &a->tptz__AbsoluteMove, ""))
				{	soap_flag_tptz__AbsoluteMove--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__AbsoluteMove * SOAP_FMAC2 soap_instantiate___tptz__AbsoluteMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__AbsoluteMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__AbsoluteMove *p;
	size_t k = sizeof(struct __tptz__AbsoluteMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__AbsoluteMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__AbsoluteMove);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__AbsoluteMove, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__AbsoluteMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__AbsoluteMove(struct soap *soap, const struct __tptz__AbsoluteMove *a, const char *tag, const char *type)
{
	if (soap_out___tptz__AbsoluteMove(soap, tag ? tag : "-tptz:AbsoluteMove", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__AbsoluteMove * SOAP_FMAC4 soap_get___tptz__AbsoluteMove(struct soap *soap, struct __tptz__AbsoluteMove *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SendAuxiliaryCommand(struct soap *soap, struct __tptz__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__SendAuxiliaryCommand = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SendAuxiliaryCommand(struct soap *soap, const struct __tptz__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__SendAuxiliaryCommand(soap, &a->tptz__SendAuxiliaryCommand);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct __tptz__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommand(soap, "tptz:SendAuxiliaryCommand", -1, &a->tptz__SendAuxiliaryCommand, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_in___tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct __tptz__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_tptz__SendAuxiliaryCommand = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__SendAuxiliaryCommand*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SendAuxiliaryCommand, sizeof(struct __tptz__SendAuxiliaryCommand), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SendAuxiliaryCommand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__SendAuxiliaryCommand(soap, "tptz:SendAuxiliaryCommand", &a->tptz__SendAuxiliaryCommand, ""))
				{	soap_flag_tptz__SendAuxiliaryCommand--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tptz__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SendAuxiliaryCommand(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__SendAuxiliaryCommand *p;
	size_t k = sizeof(struct __tptz__SendAuxiliaryCommand);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__SendAuxiliaryCommand);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__SendAuxiliaryCommand, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__SendAuxiliaryCommand location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SendAuxiliaryCommand(struct soap *soap, const struct __tptz__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	if (soap_out___tptz__SendAuxiliaryCommand(soap, tag ? tag : "-tptz:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_get___tptz__SendAuxiliaryCommand(struct soap *soap, struct __tptz__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__RelativeMove(struct soap *soap, struct __tptz__RelativeMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__RelativeMove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__RelativeMove(struct soap *soap, const struct __tptz__RelativeMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__RelativeMove(soap, &a->tptz__RelativeMove);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__RelativeMove(struct soap *soap, const char *tag, int id, const struct __tptz__RelativeMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__RelativeMove(soap, "tptz:RelativeMove", -1, &a->tptz__RelativeMove, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RelativeMove * SOAP_FMAC4 soap_in___tptz__RelativeMove(struct soap *soap, const char *tag, struct __tptz__RelativeMove *a, const char *type)
{
	size_t soap_flag_tptz__RelativeMove = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__RelativeMove*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__RelativeMove, sizeof(struct __tptz__RelativeMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__RelativeMove(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__RelativeMove && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__RelativeMove(soap, "tptz:RelativeMove", &a->tptz__RelativeMove, ""))
				{	soap_flag_tptz__RelativeMove--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__RelativeMove * SOAP_FMAC2 soap_instantiate___tptz__RelativeMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__RelativeMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__RelativeMove *p;
	size_t k = sizeof(struct __tptz__RelativeMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__RelativeMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__RelativeMove);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__RelativeMove, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__RelativeMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__RelativeMove(struct soap *soap, const struct __tptz__RelativeMove *a, const char *tag, const char *type)
{
	if (soap_out___tptz__RelativeMove(soap, tag ? tag : "-tptz:RelativeMove", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RelativeMove * SOAP_FMAC4 soap_get___tptz__RelativeMove(struct soap *soap, struct __tptz__RelativeMove *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__ContinuousMove(struct soap *soap, struct __tptz__ContinuousMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__ContinuousMove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__ContinuousMove(struct soap *soap, const struct __tptz__ContinuousMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__ContinuousMove(soap, &a->tptz__ContinuousMove);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__ContinuousMove(struct soap *soap, const char *tag, int id, const struct __tptz__ContinuousMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__ContinuousMove(soap, "tptz:ContinuousMove", -1, &a->tptz__ContinuousMove, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__ContinuousMove * SOAP_FMAC4 soap_in___tptz__ContinuousMove(struct soap *soap, const char *tag, struct __tptz__ContinuousMove *a, const char *type)
{
	size_t soap_flag_tptz__ContinuousMove = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__ContinuousMove*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__ContinuousMove, sizeof(struct __tptz__ContinuousMove), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__ContinuousMove(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__ContinuousMove && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__ContinuousMove(soap, "tptz:ContinuousMove", &a->tptz__ContinuousMove, ""))
				{	soap_flag_tptz__ContinuousMove--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__ContinuousMove * SOAP_FMAC2 soap_instantiate___tptz__ContinuousMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__ContinuousMove(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__ContinuousMove *p;
	size_t k = sizeof(struct __tptz__ContinuousMove);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__ContinuousMove, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__ContinuousMove);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__ContinuousMove, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__ContinuousMove location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__ContinuousMove(struct soap *soap, const struct __tptz__ContinuousMove *a, const char *tag, const char *type)
{
	if (soap_out___tptz__ContinuousMove(soap, tag ? tag : "-tptz:ContinuousMove", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__ContinuousMove * SOAP_FMAC4 soap_get___tptz__ContinuousMove(struct soap *soap, struct __tptz__ContinuousMove *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetHomePosition(struct soap *soap, struct __tptz__SetHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__SetHomePosition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetHomePosition(struct soap *soap, const struct __tptz__SetHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__SetHomePosition(soap, &a->tptz__SetHomePosition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetHomePosition(struct soap *soap, const char *tag, int id, const struct __tptz__SetHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__SetHomePosition(soap, "tptz:SetHomePosition", -1, &a->tptz__SetHomePosition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetHomePosition * SOAP_FMAC4 soap_in___tptz__SetHomePosition(struct soap *soap, const char *tag, struct __tptz__SetHomePosition *a, const char *type)
{
	size_t soap_flag_tptz__SetHomePosition = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__SetHomePosition*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetHomePosition, sizeof(struct __tptz__SetHomePosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetHomePosition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__SetHomePosition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__SetHomePosition(soap, "tptz:SetHomePosition", &a->tptz__SetHomePosition, ""))
				{	soap_flag_tptz__SetHomePosition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__SetHomePosition * SOAP_FMAC2 soap_instantiate___tptz__SetHomePosition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SetHomePosition(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__SetHomePosition *p;
	size_t k = sizeof(struct __tptz__SetHomePosition);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__SetHomePosition, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__SetHomePosition);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__SetHomePosition, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__SetHomePosition location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetHomePosition(struct soap *soap, const struct __tptz__SetHomePosition *a, const char *tag, const char *type)
{
	if (soap_out___tptz__SetHomePosition(soap, tag ? tag : "-tptz:SetHomePosition", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetHomePosition * SOAP_FMAC4 soap_get___tptz__SetHomePosition(struct soap *soap, struct __tptz__SetHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GotoHomePosition(struct soap *soap, struct __tptz__GotoHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GotoHomePosition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GotoHomePosition(struct soap *soap, const struct __tptz__GotoHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GotoHomePosition(soap, &a->tptz__GotoHomePosition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, const struct __tptz__GotoHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GotoHomePosition(soap, "tptz:GotoHomePosition", -1, &a->tptz__GotoHomePosition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GotoHomePosition * SOAP_FMAC4 soap_in___tptz__GotoHomePosition(struct soap *soap, const char *tag, struct __tptz__GotoHomePosition *a, const char *type)
{
	size_t soap_flag_tptz__GotoHomePosition = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GotoHomePosition*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GotoHomePosition, sizeof(struct __tptz__GotoHomePosition), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GotoHomePosition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GotoHomePosition && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GotoHomePosition(soap, "tptz:GotoHomePosition", &a->tptz__GotoHomePosition, ""))
				{	soap_flag_tptz__GotoHomePosition--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GotoHomePosition * SOAP_FMAC2 soap_instantiate___tptz__GotoHomePosition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GotoHomePosition(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GotoHomePosition *p;
	size_t k = sizeof(struct __tptz__GotoHomePosition);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GotoHomePosition, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GotoHomePosition);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GotoHomePosition, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GotoHomePosition location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GotoHomePosition(struct soap *soap, const struct __tptz__GotoHomePosition *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GotoHomePosition(soap, tag ? tag : "-tptz:GotoHomePosition", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GotoHomePosition * SOAP_FMAC4 soap_get___tptz__GotoHomePosition(struct soap *soap, struct __tptz__GotoHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetConfigurationOptions(struct soap *soap, struct __tptz__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetConfigurationOptions(struct soap *soap, const struct __tptz__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetConfigurationOptions(soap, &a->tptz__GetConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __tptz__GetConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetConfigurationOptions(soap, "tptz:GetConfigurationOptions", -1, &a->tptz__GetConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfigurationOptions * SOAP_FMAC4 soap_in___tptz__GetConfigurationOptions(struct soap *soap, const char *tag, struct __tptz__GetConfigurationOptions *a, const char *type)
{
	size_t soap_flag_tptz__GetConfigurationOptions = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetConfigurationOptions*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetConfigurationOptions, sizeof(struct __tptz__GetConfigurationOptions), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetConfigurationOptions(soap, "tptz:GetConfigurationOptions", &a->tptz__GetConfigurationOptions, ""))
				{	soap_flag_tptz__GetConfigurationOptions--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate___tptz__GetConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetConfigurationOptions(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetConfigurationOptions *p;
	size_t k = sizeof(struct __tptz__GetConfigurationOptions);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetConfigurationOptions, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetConfigurationOptions);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetConfigurationOptions, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetConfigurationOptions location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetConfigurationOptions(struct soap *soap, const struct __tptz__GetConfigurationOptions *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetConfigurationOptions(soap, tag ? tag : "-tptz:GetConfigurationOptions", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfigurationOptions * SOAP_FMAC4 soap_get___tptz__GetConfigurationOptions(struct soap *soap, struct __tptz__GetConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetConfiguration(struct soap *soap, struct __tptz__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__SetConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetConfiguration(struct soap *soap, const struct __tptz__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__SetConfiguration(soap, &a->tptz__SetConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetConfiguration(struct soap *soap, const char *tag, int id, const struct __tptz__SetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__SetConfiguration(soap, "tptz:SetConfiguration", -1, &a->tptz__SetConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfiguration * SOAP_FMAC4 soap_in___tptz__SetConfiguration(struct soap *soap, const char *tag, struct __tptz__SetConfiguration *a, const char *type)
{
	size_t soap_flag_tptz__SetConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__SetConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetConfiguration, sizeof(struct __tptz__SetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__SetConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__SetConfiguration(soap, "tptz:SetConfiguration", &a->tptz__SetConfiguration, ""))
				{	soap_flag_tptz__SetConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__SetConfiguration * SOAP_FMAC2 soap_instantiate___tptz__SetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__SetConfiguration *p;
	size_t k = sizeof(struct __tptz__SetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__SetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__SetConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__SetConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__SetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetConfiguration(struct soap *soap, const struct __tptz__SetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tptz__SetConfiguration(soap, tag ? tag : "-tptz:SetConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfiguration * SOAP_FMAC4 soap_get___tptz__SetConfiguration(struct soap *soap, struct __tptz__SetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetNode(struct soap *soap, struct __tptz__GetNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetNode(struct soap *soap, const struct __tptz__GetNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetNode(soap, &a->tptz__GetNode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetNode(struct soap *soap, const char *tag, int id, const struct __tptz__GetNode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetNode(soap, "tptz:GetNode", -1, &a->tptz__GetNode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetNode * SOAP_FMAC4 soap_in___tptz__GetNode(struct soap *soap, const char *tag, struct __tptz__GetNode *a, const char *type)
{
	size_t soap_flag_tptz__GetNode = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetNode*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetNode, sizeof(struct __tptz__GetNode), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetNode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetNode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetNode(soap, "tptz:GetNode", &a->tptz__GetNode, ""))
				{	soap_flag_tptz__GetNode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetNode * SOAP_FMAC2 soap_instantiate___tptz__GetNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetNode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetNode *p;
	size_t k = sizeof(struct __tptz__GetNode);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetNode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetNode);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetNode, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetNode location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetNode(struct soap *soap, const struct __tptz__GetNode *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetNode(soap, tag ? tag : "-tptz:GetNode", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetNode * SOAP_FMAC4 soap_get___tptz__GetNode(struct soap *soap, struct __tptz__GetNode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetNodes(struct soap *soap, struct __tptz__GetNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetNodes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetNodes(struct soap *soap, const struct __tptz__GetNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetNodes(soap, &a->tptz__GetNodes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetNodes(struct soap *soap, const char *tag, int id, const struct __tptz__GetNodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetNodes(soap, "tptz:GetNodes", -1, &a->tptz__GetNodes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetNodes * SOAP_FMAC4 soap_in___tptz__GetNodes(struct soap *soap, const char *tag, struct __tptz__GetNodes *a, const char *type)
{
	size_t soap_flag_tptz__GetNodes = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetNodes*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetNodes, sizeof(struct __tptz__GetNodes), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetNodes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetNodes && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetNodes(soap, "tptz:GetNodes", &a->tptz__GetNodes, ""))
				{	soap_flag_tptz__GetNodes--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetNodes * SOAP_FMAC2 soap_instantiate___tptz__GetNodes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetNodes(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetNodes *p;
	size_t k = sizeof(struct __tptz__GetNodes);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetNodes, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetNodes);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetNodes, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetNodes location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetNodes(struct soap *soap, const struct __tptz__GetNodes *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetNodes(soap, tag ? tag : "-tptz:GetNodes", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetNodes * SOAP_FMAC4 soap_get___tptz__GetNodes(struct soap *soap, struct __tptz__GetNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetConfiguration(struct soap *soap, struct __tptz__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetConfiguration(struct soap *soap, const struct __tptz__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetConfiguration(soap, &a->tptz__GetConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetConfiguration(struct soap *soap, const char *tag, int id, const struct __tptz__GetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetConfiguration(soap, "tptz:GetConfiguration", -1, &a->tptz__GetConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfiguration * SOAP_FMAC4 soap_in___tptz__GetConfiguration(struct soap *soap, const char *tag, struct __tptz__GetConfiguration *a, const char *type)
{
	size_t soap_flag_tptz__GetConfiguration = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetConfiguration*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetConfiguration, sizeof(struct __tptz__GetConfiguration), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetConfiguration && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetConfiguration(soap, "tptz:GetConfiguration", &a->tptz__GetConfiguration, ""))
				{	soap_flag_tptz__GetConfiguration--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetConfiguration * SOAP_FMAC2 soap_instantiate___tptz__GetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetConfiguration *p;
	size_t k = sizeof(struct __tptz__GetConfiguration);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetConfiguration);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetConfiguration, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetConfiguration location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetConfiguration(struct soap *soap, const struct __tptz__GetConfiguration *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetConfiguration(soap, tag ? tag : "-tptz:GetConfiguration", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfiguration * SOAP_FMAC4 soap_get___tptz__GetConfiguration(struct soap *soap, struct __tptz__GetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetStatus(struct soap *soap, struct __tptz__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetStatus(struct soap *soap, const struct __tptz__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetStatus(soap, &a->tptz__GetStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetStatus(struct soap *soap, const char *tag, int id, const struct __tptz__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetStatus(soap, "tptz:GetStatus", -1, &a->tptz__GetStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetStatus * SOAP_FMAC4 soap_in___tptz__GetStatus(struct soap *soap, const char *tag, struct __tptz__GetStatus *a, const char *type)
{
	size_t soap_flag_tptz__GetStatus = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetStatus*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetStatus, sizeof(struct __tptz__GetStatus), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetStatus && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetStatus(soap, "tptz:GetStatus", &a->tptz__GetStatus, ""))
				{	soap_flag_tptz__GetStatus--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetStatus * SOAP_FMAC2 soap_instantiate___tptz__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetStatus(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetStatus *p;
	size_t k = sizeof(struct __tptz__GetStatus);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetStatus, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetStatus);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetStatus, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetStatus location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetStatus(struct soap *soap, const struct __tptz__GetStatus *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetStatus(soap, tag ? tag : "-tptz:GetStatus", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetStatus * SOAP_FMAC4 soap_get___tptz__GetStatus(struct soap *soap, struct __tptz__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GotoPreset(struct soap *soap, struct __tptz__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GotoPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GotoPreset(struct soap *soap, const struct __tptz__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GotoPreset(soap, &a->tptz__GotoPreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GotoPreset(struct soap *soap, const char *tag, int id, const struct __tptz__GotoPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GotoPreset(soap, "tptz:GotoPreset", -1, &a->tptz__GotoPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GotoPreset * SOAP_FMAC4 soap_in___tptz__GotoPreset(struct soap *soap, const char *tag, struct __tptz__GotoPreset *a, const char *type)
{
	size_t soap_flag_tptz__GotoPreset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GotoPreset*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GotoPreset, sizeof(struct __tptz__GotoPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GotoPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GotoPreset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GotoPreset(soap, "tptz:GotoPreset", &a->tptz__GotoPreset, ""))
				{	soap_flag_tptz__GotoPreset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GotoPreset * SOAP_FMAC2 soap_instantiate___tptz__GotoPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GotoPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GotoPreset *p;
	size_t k = sizeof(struct __tptz__GotoPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GotoPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GotoPreset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GotoPreset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GotoPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GotoPreset(struct soap *soap, const struct __tptz__GotoPreset *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GotoPreset(soap, tag ? tag : "-tptz:GotoPreset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GotoPreset * SOAP_FMAC4 soap_get___tptz__GotoPreset(struct soap *soap, struct __tptz__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__RemovePreset(struct soap *soap, struct __tptz__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__RemovePreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__RemovePreset(struct soap *soap, const struct __tptz__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__RemovePreset(soap, &a->tptz__RemovePreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__RemovePreset(struct soap *soap, const char *tag, int id, const struct __tptz__RemovePreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__RemovePreset(soap, "tptz:RemovePreset", -1, &a->tptz__RemovePreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RemovePreset * SOAP_FMAC4 soap_in___tptz__RemovePreset(struct soap *soap, const char *tag, struct __tptz__RemovePreset *a, const char *type)
{
	size_t soap_flag_tptz__RemovePreset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__RemovePreset*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__RemovePreset, sizeof(struct __tptz__RemovePreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__RemovePreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__RemovePreset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__RemovePreset(soap, "tptz:RemovePreset", &a->tptz__RemovePreset, ""))
				{	soap_flag_tptz__RemovePreset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__RemovePreset * SOAP_FMAC2 soap_instantiate___tptz__RemovePreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__RemovePreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__RemovePreset *p;
	size_t k = sizeof(struct __tptz__RemovePreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__RemovePreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__RemovePreset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__RemovePreset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__RemovePreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__RemovePreset(struct soap *soap, const struct __tptz__RemovePreset *a, const char *tag, const char *type)
{
	if (soap_out___tptz__RemovePreset(soap, tag ? tag : "-tptz:RemovePreset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RemovePreset * SOAP_FMAC4 soap_get___tptz__RemovePreset(struct soap *soap, struct __tptz__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetPreset(struct soap *soap, struct __tptz__SetPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__SetPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetPreset(struct soap *soap, const struct __tptz__SetPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__SetPreset(soap, &a->tptz__SetPreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetPreset(struct soap *soap, const char *tag, int id, const struct __tptz__SetPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__SetPreset(soap, "tptz:SetPreset", -1, &a->tptz__SetPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetPreset * SOAP_FMAC4 soap_in___tptz__SetPreset(struct soap *soap, const char *tag, struct __tptz__SetPreset *a, const char *type)
{
	size_t soap_flag_tptz__SetPreset = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__SetPreset*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetPreset, sizeof(struct __tptz__SetPreset), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__SetPreset && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__SetPreset(soap, "tptz:SetPreset", &a->tptz__SetPreset, ""))
				{	soap_flag_tptz__SetPreset--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__SetPreset * SOAP_FMAC2 soap_instantiate___tptz__SetPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SetPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__SetPreset *p;
	size_t k = sizeof(struct __tptz__SetPreset);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__SetPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__SetPreset);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__SetPreset, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__SetPreset location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetPreset(struct soap *soap, const struct __tptz__SetPreset *a, const char *tag, const char *type)
{
	if (soap_out___tptz__SetPreset(soap, tag ? tag : "-tptz:SetPreset", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetPreset * SOAP_FMAC4 soap_get___tptz__SetPreset(struct soap *soap, struct __tptz__SetPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetPresets(struct soap *soap, struct __tptz__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetPresets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetPresets(struct soap *soap, const struct __tptz__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetPresets(soap, &a->tptz__GetPresets);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetPresets(struct soap *soap, const char *tag, int id, const struct __tptz__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetPresets(soap, "tptz:GetPresets", -1, &a->tptz__GetPresets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresets * SOAP_FMAC4 soap_in___tptz__GetPresets(struct soap *soap, const char *tag, struct __tptz__GetPresets *a, const char *type)
{
	size_t soap_flag_tptz__GetPresets = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetPresets*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetPresets, sizeof(struct __tptz__GetPresets), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetPresets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetPresets && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetPresets(soap, "tptz:GetPresets", &a->tptz__GetPresets, ""))
				{	soap_flag_tptz__GetPresets--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetPresets * SOAP_FMAC2 soap_instantiate___tptz__GetPresets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetPresets(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetPresets *p;
	size_t k = sizeof(struct __tptz__GetPresets);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetPresets, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetPresets);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetPresets, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetPresets location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetPresets(struct soap *soap, const struct __tptz__GetPresets *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetPresets(soap, tag ? tag : "-tptz:GetPresets", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresets * SOAP_FMAC4 soap_get___tptz__GetPresets(struct soap *soap, struct __tptz__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetConfigurations(struct soap *soap, struct __tptz__GetConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetConfigurations(struct soap *soap, const struct __tptz__GetConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetConfigurations(soap, &a->tptz__GetConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetConfigurations(struct soap *soap, const char *tag, int id, const struct __tptz__GetConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetConfigurations(soap, "tptz:GetConfigurations", -1, &a->tptz__GetConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfigurations * SOAP_FMAC4 soap_in___tptz__GetConfigurations(struct soap *soap, const char *tag, struct __tptz__GetConfigurations *a, const char *type)
{
	size_t soap_flag_tptz__GetConfigurations = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetConfigurations*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetConfigurations, sizeof(struct __tptz__GetConfigurations), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetConfigurations && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetConfigurations(soap, "tptz:GetConfigurations", &a->tptz__GetConfigurations, ""))
				{	soap_flag_tptz__GetConfigurations--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetConfigurations * SOAP_FMAC2 soap_instantiate___tptz__GetConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetConfigurations(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetConfigurations *p;
	size_t k = sizeof(struct __tptz__GetConfigurations);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetConfigurations, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetConfigurations);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetConfigurations, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetConfigurations location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetConfigurations(struct soap *soap, const struct __tptz__GetConfigurations *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetConfigurations(soap, tag ? tag : "-tptz:GetConfigurations", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfigurations * SOAP_FMAC4 soap_get___tptz__GetConfigurations(struct soap *soap, struct __tptz__GetConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetServiceCapabilities(struct soap *soap, struct __tptz__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetServiceCapabilities(struct soap *soap, const struct __tptz__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTo_tptz__GetServiceCapabilities(soap, &a->tptz__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tptz__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_out_PointerTo_tptz__GetServiceCapabilities(soap, "tptz:GetServiceCapabilities", -1, &a->tptz__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetServiceCapabilities * SOAP_FMAC4 soap_in___tptz__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tptz__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tptz__GetServiceCapabilities = 1;
	short soap_flag;
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__GetServiceCapabilities*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetServiceCapabilities, sizeof(struct __tptz__GetServiceCapabilities), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_tptz__GetServiceCapabilities(soap, "tptz:GetServiceCapabilities", &a->tptz__GetServiceCapabilities, ""))
				{	soap_flag_tptz__GetServiceCapabilities--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && soap_flag)
			{	soap->error = SOAP_OK;
				break;
			}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC1 struct __tptz__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tptz__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetServiceCapabilities(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__GetServiceCapabilities *p;
	size_t k = sizeof(struct __tptz__GetServiceCapabilities);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__GetServiceCapabilities, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__GetServiceCapabilities);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__GetServiceCapabilities, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__GetServiceCapabilities location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetServiceCapabilities(struct soap *soap, const struct __tptz__GetServiceCapabilities *a, const char *tag, const char *type)
{
	if (soap_out___tptz__GetServiceCapabilities(soap, tag ? tag : "-tptz:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetServiceCapabilities * SOAP_FMAC4 soap_get___tptz__GetServiceCapabilities(struct soap *soap, struct __tptz__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetConfigurationResponse_sequence(struct soap *soap, const struct __tptz__SetConfigurationResponse_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, int id, const struct __tptz__SetConfigurationResponse_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_in___tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, struct __tptz__SetConfigurationResponse_sequence *a, const char *type)
{
	(void)tag; (void)type; /* appease -Wall -Werror */
	a = (struct __tptz__SetConfigurationResponse_sequence*)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetConfigurationResponse_sequence(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC1 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC2 soap_instantiate___tptz__SetConfigurationResponse_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SetConfigurationResponse_sequence(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct __tptz__SetConfigurationResponse_sequence *p;
	size_t k = sizeof(struct __tptz__SetConfigurationResponse_sequence);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct __tptz__SetConfigurationResponse_sequence);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct __tptz__SetConfigurationResponse_sequence, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct __tptz__SetConfigurationResponse_sequence location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetConfigurationResponse_sequence(struct soap *soap, const struct __tptz__SetConfigurationResponse_sequence *a, const char *tag, const char *type)
{
	if (soap_out___tptz__SetConfigurationResponse_sequence(soap, tag ? tag : "-tptz:SetConfigurationResponse-sequence", -2, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_get___tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetConfigurationResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SOAP_ENV__Header = NULL;
	a->SOAP_ENV__Body = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToSOAP_ENV__Header(soap, &a->SOAP_ENV__Header);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Envelope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Envelope), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", -1, &a->SOAP_ENV__Header, ""))
		return soap->error;
	if (soap_outliteral(soap, "SOAP-ENV:Body", (char*const*)&a->SOAP_ENV__Body, NULL))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Header = 1;
	size_t soap_flag_SOAP_ENV__Body = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Envelope*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Envelope(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Header && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", &a->SOAP_ENV__Header, ""))
				{	soap_flag_SOAP_ENV__Header--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "SOAP-ENV:Body", (char**)&a->SOAP_ENV__Body))
				{	soap_flag_SOAP_ENV__Body--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Envelope, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Envelope(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Envelope *p;
	size_t k = sizeof(struct SOAP_ENV__Envelope);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Envelope, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Envelope);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Envelope, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Envelope location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Envelope(soap, tag ? tag : "SOAP-ENV:Envelope", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode;
	soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Fault *p;
	size_t k = sizeof(struct SOAP_ENV__Fault);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Fault);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Fault, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Fault location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Reason *p;
	size_t k = sizeof(struct SOAP_ENV__Reason);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Reason);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Reason, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Reason location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value;
	soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Code *p;
	size_t k = sizeof(struct SOAP_ENV__Code);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Code);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Code, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Code location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, "fault", &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Detail *p;
	size_t k = sizeof(struct SOAP_ENV__Detail);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Detail);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Detail, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Detail location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__wsa5__MessageID(soap, (char*const*)&a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, (char*const*)&a->wsa5__To);
	soap_serialize__wsa5__Action(soap, (char*const*)&a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, (char*const*)&a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, (char*const*)&a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, (char*const*)&a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", (char**)&a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__To(soap, "wsa5:To", (char**)&a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__wsa5__Action(soap, "wsa5:Action", (char**)&a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct SOAP_ENV__Header *p;
	size_t k = sizeof(struct SOAP_ENV__Header);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct SOAP_ENV__Header);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct SOAP_ENV__Header, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct SOAP_ENV__Header location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	if (a->wsa5__IsReferenceParameter != (enum _wsa5__IsReferenceParameter)0)
	{	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	}
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct chan__ChannelInstanceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 5, 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_chan__ChannelInstanceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct chan__ChannelInstanceType *p;
	size_t k = sizeof(struct chan__ChannelInstanceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_chan__ChannelInstanceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct chan__ChannelInstanceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct chan__ChannelInstanceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct chan__ChannelInstanceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	if (soap_out_chan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemAction(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemAction(soap, tag ? tag : "wsa5:ProblemAction", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__FaultTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__From(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReplyTo(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__RelatesTo(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Metadata(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Metadata(soap, tag ? tag : "wsa5:Metadata", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ReferenceParameters(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ReferenceParameters(soap, tag ? tag : "wsa5:ReferenceParameters", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__EndpointReference(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out__wsa5__EndpointReference(soap, tag ? tag : "wsa5:EndpointReference", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Action);
	soap_serialize_string(soap, (char*const*)&a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, (char*const*)&a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, (char*const*)&a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ProblemActionType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Action", (char**)&a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:SoapAction", (char**)&a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ProblemActionType *p;
	size_t k = sizeof(struct wsa5__ProblemActionType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ProblemActionType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ProblemActionType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ProblemActionType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ProblemActionType(soap, tag ? tag : "wsa5:ProblemActionType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_wsa5__RelationshipTypeOpenEnum2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	return soap_out_string(soap, tag, id, (char*const*)&a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	if (!(a = (struct wsa5__RelatesToType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType, soap_instantiate, soap_fbase)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2wsa5__RelationshipTypeOpenEnum(soap, soap_attr_value(soap, "RelationshipType", 1, 0), &a->RelationshipType))
		return NULL;
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (!soap_in_string(soap, tag, (char**)&a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__RelatesToType *p;
	size_t k = sizeof(struct wsa5__RelatesToType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__RelatesToType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__RelatesToType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__RelatesToType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelatesToType(soap, tag ? tag : "wsa5:RelatesToType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__MetadataType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__MetadataType *p;
	size_t k = sizeof(struct wsa5__MetadataType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__MetadataType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__MetadataType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__MetadataType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__ReferenceParametersType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__ReferenceParametersType *p;
	size_t k = sizeof(struct wsa5__ReferenceParametersType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__ReferenceParametersType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__ReferenceParametersType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__ReferenceParametersType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (!a->Address)
	{	if (soap_element_empty(soap, "wsa5:Address", 0, NULL))
			return soap->error;
	}
	else if (soap_out_string(soap, "wsa5:Address", -1, (char*const*)&a->Address, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < (int)a->__size; i++)
			if (soap_outliteral(soap, "-any", (char*const*)(a->__any + i), NULL))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	(void)type; /* appease -Wall -Werror */
	a = (struct wsa5__EndpointReferenceType*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2char(soap, soap_attr_value(soap, "-anyAttribute", 0, 0), &a->__anyAttribute, 0, 0, -1, NULL))
		return NULL;
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "wsa5:Address", (char**)&a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_alloc_block(soap);
					a->__any = (char **)soap_push_block_max(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", (char**)a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
		{	a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		}
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		if ((soap->mode & SOAP_XML_STRICT) && (!a->Address))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
	}
	else if ((soap->mode & SOAP_XML_STRICT) && *soap->href != '#')
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, soap_finsert, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct wsa5__EndpointReferenceType *p;
	size_t k = sizeof(struct wsa5__EndpointReferenceType);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct wsa5__EndpointReferenceType);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct wsa5__EndpointReferenceType, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct wsa5__EndpointReferenceType location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	if (soap_out_wsa5__EndpointReferenceType(soap, tag ? tag : "wsa5:EndpointReferenceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{
	(void)soap; /* appease -Wall -Werror */
	a->__ptr = NULL;
	a->__size = 0;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, const struct _xop__Include *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (a->__ptr)
		(void)soap_attachment_reference(soap, a, a->__ptr, a->__size, SOAP_TYPE__xop__Include, a->id, a->type);
#endif
}

SOAP_FMAC3S const char* SOAP_FMAC4S soap__xop__Include2s(struct soap *soap, struct _xop__Include a)
{
	return soap_s2base64(soap, a.__ptr, NULL, a.__size);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, a->__ptr, a->__size, a->id, a->type, a->options, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, a->__ptr, a->__size, type, SOAP_TYPE__xop__Include, NULL);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_xop__Include(struct soap *soap, const char *s, struct _xop__Include *a)
{
	a->__ptr = (unsigned char*)soap_base642s(soap, s, NULL, 0, &a->__size);
	if (!a->__ptr)
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include*)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_attachment_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, soap_finsert, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xop__Include(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	struct _xop__Include *p;
	size_t k = sizeof(struct _xop__Include);
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE__xop__Include, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, struct _xop__Include);
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, struct _xop__Include, n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated struct _xop__Include location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	if (soap_out__xop__Include(soap, tag ? tag : "xop:Include", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)choice; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		soap_serialize_PointerTott__ReferenceToken(soap, &a->PresetToken);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		soap_embedded(soap, &a->Home, SOAP_TYPE_bool);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		soap_serialize_PointerTott__PTZPresetTourTypeExtension(soap, &a->TypeExtension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		return soap_out_PointerTott__ReferenceToken(soap, "tt:PresetToken", -1, &a->PresetToken, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		return soap_out_bool(soap, "tt:Home", -1, &a->Home, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		return soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		return soap_out_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", -1, &a->TypeExtension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int *choice, union _tt__union_PTZPresetTourPresetDetail *a)
{
	(void)a; /* appease -Wall -Werror */
	soap->error = SOAP_TAG_MISMATCH;
	a->PresetToken = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__ReferenceToken(soap, "tt:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_bool(soap, "tt:Home", &a->Home, "xsd:boolean"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home;
		return a;
	}
	a->PTZPosition = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition;
		return a;
	}
	a->TypeExtension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", &a->TypeExtension, "tt:PTZPresetTourTypeExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__MoveAndStartTracking(struct soap *soap, _tptz__MoveAndStartTracking *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__MoveAndStartTracking))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__MoveAndStartTracking(struct soap *soap, const char *tag, int id, _tptz__MoveAndStartTracking *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__MoveAndStartTracking, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__MoveAndStartTracking ? type : NULL);
}

SOAP_FMAC3 _tptz__MoveAndStartTracking ** SOAP_FMAC4 soap_in_PointerTo_tptz__MoveAndStartTracking(struct soap *soap, const char *tag, _tptz__MoveAndStartTracking **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__MoveAndStartTracking **)soap_malloc(soap, sizeof(_tptz__MoveAndStartTracking *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__MoveAndStartTracking *)soap_instantiate__tptz__MoveAndStartTracking(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__MoveAndStartTracking **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__MoveAndStartTracking, sizeof(_tptz__MoveAndStartTracking), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__MoveAndStartTracking(struct soap *soap, _tptz__MoveAndStartTracking *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__MoveAndStartTracking(soap, tag ? tag : "tptz:MoveAndStartTracking", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__MoveAndStartTracking ** SOAP_FMAC4 soap_get_PointerTo_tptz__MoveAndStartTracking(struct soap *soap, _tptz__MoveAndStartTracking **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__MoveAndStartTracking(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, _tptz__GetCompatibleConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetCompatibleConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, int id, _tptz__GetCompatibleConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetCompatibleConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetCompatibleConfigurations ? type : NULL);
}

SOAP_FMAC3 _tptz__GetCompatibleConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, const char *tag, _tptz__GetCompatibleConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetCompatibleConfigurations **)soap_malloc(soap, sizeof(_tptz__GetCompatibleConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetCompatibleConfigurations *)soap_instantiate__tptz__GetCompatibleConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetCompatibleConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetCompatibleConfigurations, sizeof(_tptz__GetCompatibleConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, _tptz__GetCompatibleConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetCompatibleConfigurations(soap, tag ? tag : "tptz:GetCompatibleConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetCompatibleConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetCompatibleConfigurations(struct soap *soap, _tptz__GetCompatibleConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetCompatibleConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetTour(struct soap *soap, _tptz__RemovePresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, _tptz__RemovePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetTour, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__RemovePresetTour ? type : NULL);
}

SOAP_FMAC3 _tptz__RemovePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetTour(struct soap *soap, const char *tag, _tptz__RemovePresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RemovePresetTour **)soap_malloc(soap, sizeof(_tptz__RemovePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RemovePresetTour *)soap_instantiate__tptz__RemovePresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__RemovePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(_tptz__RemovePresetTour), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetTour(struct soap *soap, _tptz__RemovePresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__RemovePresetTour(soap, tag ? tag : "tptz:RemovePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RemovePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetTour(struct soap *soap, _tptz__RemovePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__OperatePresetTour(struct soap *soap, _tptz__OperatePresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__OperatePresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, _tptz__OperatePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__OperatePresetTour, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__OperatePresetTour ? type : NULL);
}

SOAP_FMAC3 _tptz__OperatePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__OperatePresetTour(struct soap *soap, const char *tag, _tptz__OperatePresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__OperatePresetTour **)soap_malloc(soap, sizeof(_tptz__OperatePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__OperatePresetTour *)soap_instantiate__tptz__OperatePresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__OperatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(_tptz__OperatePresetTour), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__OperatePresetTour(struct soap *soap, _tptz__OperatePresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__OperatePresetTour(soap, tag ? tag : "tptz:OperatePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__OperatePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__OperatePresetTour(struct soap *soap, _tptz__OperatePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ModifyPresetTour(struct soap *soap, _tptz__ModifyPresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ModifyPresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, _tptz__ModifyPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ModifyPresetTour, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__ModifyPresetTour ? type : NULL);
}

SOAP_FMAC3 _tptz__ModifyPresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__ModifyPresetTour(struct soap *soap, const char *tag, _tptz__ModifyPresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__ModifyPresetTour **)soap_malloc(soap, sizeof(_tptz__ModifyPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__ModifyPresetTour *)soap_instantiate__tptz__ModifyPresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__ModifyPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(_tptz__ModifyPresetTour), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ModifyPresetTour(struct soap *soap, _tptz__ModifyPresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__ModifyPresetTour(soap, tag ? tag : "tptz:ModifyPresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__ModifyPresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__ModifyPresetTour(struct soap *soap, _tptz__ModifyPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__CreatePresetTour(struct soap *soap, _tptz__CreatePresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__CreatePresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, _tptz__CreatePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__CreatePresetTour, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__CreatePresetTour ? type : NULL);
}

SOAP_FMAC3 _tptz__CreatePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__CreatePresetTour(struct soap *soap, const char *tag, _tptz__CreatePresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__CreatePresetTour **)soap_malloc(soap, sizeof(_tptz__CreatePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__CreatePresetTour *)soap_instantiate__tptz__CreatePresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__CreatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(_tptz__CreatePresetTour), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__CreatePresetTour(struct soap *soap, _tptz__CreatePresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__CreatePresetTour(soap, tag ? tag : "tptz:CreatePresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__CreatePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__CreatePresetTour(struct soap *soap, _tptz__CreatePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, _tptz__GetPresetTourOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, _tptz__GetPresetTourOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetPresetTourOptions ? type : NULL);
}

SOAP_FMAC3 _tptz__GetPresetTourOptions ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, const char *tag, _tptz__GetPresetTourOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetTourOptions **)soap_malloc(soap, sizeof(_tptz__GetPresetTourOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetTourOptions *)soap_instantiate__tptz__GetPresetTourOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(_tptz__GetPresetTourOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, _tptz__GetPresetTourOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetTourOptions(soap, tag ? tag : "tptz:GetPresetTourOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetTourOptions ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, _tptz__GetPresetTourOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTour(struct soap *soap, _tptz__GetPresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTour(struct soap *soap, const char *tag, int id, _tptz__GetPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTour, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetPresetTour ? type : NULL);
}

SOAP_FMAC3 _tptz__GetPresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTour(struct soap *soap, const char *tag, _tptz__GetPresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetTour **)soap_malloc(soap, sizeof(_tptz__GetPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetTour *)soap_instantiate__tptz__GetPresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTour, sizeof(_tptz__GetPresetTour), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTour(struct soap *soap, _tptz__GetPresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetTour(soap, tag ? tag : "tptz:GetPresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTour(struct soap *soap, _tptz__GetPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTours(struct soap *soap, _tptz__GetPresetTours *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTours))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTours(struct soap *soap, const char *tag, int id, _tptz__GetPresetTours *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTours, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetPresetTours ? type : NULL);
}

SOAP_FMAC3 _tptz__GetPresetTours ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTours(struct soap *soap, const char *tag, _tptz__GetPresetTours **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetTours **)soap_malloc(soap, sizeof(_tptz__GetPresetTours *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetTours *)soap_instantiate__tptz__GetPresetTours(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetPresetTours **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTours, sizeof(_tptz__GetPresetTours), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTours(struct soap *soap, _tptz__GetPresetTours *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresetTours(soap, tag ? tag : "tptz:GetPresetTours", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetTours ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTours(struct soap *soap, _tptz__GetPresetTours **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__Stop(struct soap *soap, _tptz__Stop *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__Stop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__Stop(struct soap *soap, const char *tag, int id, _tptz__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__Stop, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__Stop ? type : NULL);
}

SOAP_FMAC3 _tptz__Stop ** SOAP_FMAC4 soap_in_PointerTo_tptz__Stop(struct soap *soap, const char *tag, _tptz__Stop **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__Stop **)soap_malloc(soap, sizeof(_tptz__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__Stop *)soap_instantiate__tptz__Stop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__Stop, sizeof(_tptz__Stop), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__Stop(struct soap *soap, _tptz__Stop *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__Stop(soap, tag ? tag : "tptz:Stop", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__Stop ** SOAP_FMAC4 soap_get_PointerTo_tptz__Stop(struct soap *soap, _tptz__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GeoMove(struct soap *soap, _tptz__GeoMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GeoMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GeoMove(struct soap *soap, const char *tag, int id, _tptz__GeoMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GeoMove, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GeoMove ? type : NULL);
}

SOAP_FMAC3 _tptz__GeoMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__GeoMove(struct soap *soap, const char *tag, _tptz__GeoMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GeoMove **)soap_malloc(soap, sizeof(_tptz__GeoMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GeoMove *)soap_instantiate__tptz__GeoMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GeoMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GeoMove, sizeof(_tptz__GeoMove), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GeoMove(struct soap *soap, _tptz__GeoMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GeoMove(soap, tag ? tag : "tptz:GeoMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GeoMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__GeoMove(struct soap *soap, _tptz__GeoMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GeoMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMove(struct soap *soap, _tptz__AbsoluteMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, _tptz__AbsoluteMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMove, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__AbsoluteMove ? type : NULL);
}

SOAP_FMAC3 _tptz__AbsoluteMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, _tptz__AbsoluteMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__AbsoluteMove **)soap_malloc(soap, sizeof(_tptz__AbsoluteMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__AbsoluteMove *)soap_instantiate__tptz__AbsoluteMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__AbsoluteMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(_tptz__AbsoluteMove), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMove(struct soap *soap, _tptz__AbsoluteMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__AbsoluteMove(soap, tag ? tag : "tptz:AbsoluteMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__AbsoluteMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMove(struct soap *soap, _tptz__AbsoluteMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, _tptz__SendAuxiliaryCommand *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommand))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, _tptz__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommand, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__SendAuxiliaryCommand ? type : NULL);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tptz__SendAuxiliaryCommand **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(_tptz__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SendAuxiliaryCommand *)soap_instantiate__tptz__SendAuxiliaryCommand(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(_tptz__SendAuxiliaryCommand), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, _tptz__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommand(soap, tag ? tag : "tptz:SendAuxiliaryCommand", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, _tptz__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMove(struct soap *soap, _tptz__RelativeMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, int id, _tptz__RelativeMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMove, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__RelativeMove ? type : NULL);
}

SOAP_FMAC3 _tptz__RelativeMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, _tptz__RelativeMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RelativeMove **)soap_malloc(soap, sizeof(_tptz__RelativeMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RelativeMove *)soap_instantiate__tptz__RelativeMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__RelativeMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMove, sizeof(_tptz__RelativeMove), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMove(struct soap *soap, _tptz__RelativeMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__RelativeMove(soap, tag ? tag : "tptz:RelativeMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RelativeMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMove(struct soap *soap, _tptz__RelativeMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMove(struct soap *soap, _tptz__ContinuousMove *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, int id, _tptz__ContinuousMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMove, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__ContinuousMove ? type : NULL);
}

SOAP_FMAC3 _tptz__ContinuousMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, _tptz__ContinuousMove **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__ContinuousMove **)soap_malloc(soap, sizeof(_tptz__ContinuousMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__ContinuousMove *)soap_instantiate__tptz__ContinuousMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__ContinuousMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMove, sizeof(_tptz__ContinuousMove), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMove(struct soap *soap, _tptz__ContinuousMove *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__ContinuousMove(soap, tag ? tag : "tptz:ContinuousMove", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__ContinuousMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMove(struct soap *soap, _tptz__ContinuousMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePosition(struct soap *soap, _tptz__SetHomePosition *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePosition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, int id, _tptz__SetHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePosition, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__SetHomePosition ? type : NULL);
}

SOAP_FMAC3 _tptz__SetHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, _tptz__SetHomePosition **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetHomePosition **)soap_malloc(soap, sizeof(_tptz__SetHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetHomePosition *)soap_instantiate__tptz__SetHomePosition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__SetHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePosition, sizeof(_tptz__SetHomePosition), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePosition(struct soap *soap, _tptz__SetHomePosition *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__SetHomePosition(soap, tag ? tag : "tptz:SetHomePosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePosition(struct soap *soap, _tptz__SetHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePosition(struct soap *soap, _tptz__GotoHomePosition *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePosition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, _tptz__GotoHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePosition, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GotoHomePosition ? type : NULL);
}

SOAP_FMAC3 _tptz__GotoHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, _tptz__GotoHomePosition **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GotoHomePosition **)soap_malloc(soap, sizeof(_tptz__GotoHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GotoHomePosition *)soap_instantiate__tptz__GotoHomePosition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GotoHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(_tptz__GotoHomePosition), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePosition(struct soap *soap, _tptz__GotoHomePosition *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GotoHomePosition(soap, tag ? tag : "tptz:GotoHomePosition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GotoHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePosition(struct soap *soap, _tptz__GotoHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, _tptz__GetConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, _tptz__GetConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 _tptz__GetConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, const char *tag, _tptz__GetConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfigurationOptions **)soap_malloc(soap, sizeof(_tptz__GetConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfigurationOptions *)soap_instantiate__tptz__GetConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(_tptz__GetConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, _tptz__GetConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetConfigurationOptions(soap, tag ? tag : "tptz:GetConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, _tptz__GetConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetConfiguration(struct soap *soap, _tptz__SetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetConfiguration(struct soap *soap, const char *tag, int id, _tptz__SetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__SetConfiguration ? type : NULL);
}

SOAP_FMAC3 _tptz__SetConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetConfiguration(struct soap *soap, const char *tag, _tptz__SetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetConfiguration **)soap_malloc(soap, sizeof(_tptz__SetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetConfiguration *)soap_instantiate__tptz__SetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__SetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfiguration, sizeof(_tptz__SetConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetConfiguration(struct soap *soap, _tptz__SetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__SetConfiguration(soap, tag ? tag : "tptz:SetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetConfiguration(struct soap *soap, _tptz__SetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNode(struct soap *soap, _tptz__GetNode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNode(struct soap *soap, const char *tag, int id, _tptz__GetNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetNode ? type : NULL);
}

SOAP_FMAC3 _tptz__GetNode ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNode(struct soap *soap, const char *tag, _tptz__GetNode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetNode **)soap_malloc(soap, sizeof(_tptz__GetNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetNode *)soap_instantiate__tptz__GetNode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNode, sizeof(_tptz__GetNode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNode(struct soap *soap, _tptz__GetNode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetNode(soap, tag ? tag : "tptz:GetNode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetNode ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNode(struct soap *soap, _tptz__GetNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodes(struct soap *soap, _tptz__GetNodes *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodes(struct soap *soap, const char *tag, int id, _tptz__GetNodes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodes, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetNodes ? type : NULL);
}

SOAP_FMAC3 _tptz__GetNodes ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodes(struct soap *soap, const char *tag, _tptz__GetNodes **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetNodes **)soap_malloc(soap, sizeof(_tptz__GetNodes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetNodes *)soap_instantiate__tptz__GetNodes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetNodes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodes, sizeof(_tptz__GetNodes), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodes(struct soap *soap, _tptz__GetNodes *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetNodes(soap, tag ? tag : "tptz:GetNodes", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetNodes ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodes(struct soap *soap, _tptz__GetNodes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfiguration(struct soap *soap, _tptz__GetConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfiguration(struct soap *soap, const char *tag, int id, _tptz__GetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetConfiguration ? type : NULL);
}

SOAP_FMAC3 _tptz__GetConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfiguration(struct soap *soap, const char *tag, _tptz__GetConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfiguration **)soap_malloc(soap, sizeof(_tptz__GetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfiguration *)soap_instantiate__tptz__GetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfiguration, sizeof(_tptz__GetConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfiguration(struct soap *soap, _tptz__GetConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetConfiguration(soap, tag ? tag : "tptz:GetConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfiguration(struct soap *soap, _tptz__GetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetStatus(struct soap *soap, _tptz__GetStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetStatus(struct soap *soap, const char *tag, int id, _tptz__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetStatus ? type : NULL);
}

SOAP_FMAC3 _tptz__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetStatus(struct soap *soap, const char *tag, _tptz__GetStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetStatus **)soap_malloc(soap, sizeof(_tptz__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetStatus *)soap_instantiate__tptz__GetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatus, sizeof(_tptz__GetStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetStatus(struct soap *soap, _tptz__GetStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetStatus(soap, tag ? tag : "tptz:GetStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetStatus(struct soap *soap, _tptz__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoPreset(struct soap *soap, _tptz__GotoPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoPreset(struct soap *soap, const char *tag, int id, _tptz__GotoPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GotoPreset ? type : NULL);
}

SOAP_FMAC3 _tptz__GotoPreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoPreset(struct soap *soap, const char *tag, _tptz__GotoPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GotoPreset **)soap_malloc(soap, sizeof(_tptz__GotoPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GotoPreset *)soap_instantiate__tptz__GotoPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GotoPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPreset, sizeof(_tptz__GotoPreset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoPreset(struct soap *soap, _tptz__GotoPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GotoPreset(soap, tag ? tag : "tptz:GotoPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GotoPreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoPreset(struct soap *soap, _tptz__GotoPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePreset(struct soap *soap, _tptz__RemovePreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePreset(struct soap *soap, const char *tag, int id, _tptz__RemovePreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__RemovePreset ? type : NULL);
}

SOAP_FMAC3 _tptz__RemovePreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePreset(struct soap *soap, const char *tag, _tptz__RemovePreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RemovePreset **)soap_malloc(soap, sizeof(_tptz__RemovePreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RemovePreset *)soap_instantiate__tptz__RemovePreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__RemovePreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePreset, sizeof(_tptz__RemovePreset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePreset(struct soap *soap, _tptz__RemovePreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__RemovePreset(soap, tag ? tag : "tptz:RemovePreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RemovePreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePreset(struct soap *soap, _tptz__RemovePreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetPreset(struct soap *soap, _tptz__SetPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetPreset(struct soap *soap, const char *tag, int id, _tptz__SetPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__SetPreset ? type : NULL);
}

SOAP_FMAC3 _tptz__SetPreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetPreset(struct soap *soap, const char *tag, _tptz__SetPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetPreset **)soap_malloc(soap, sizeof(_tptz__SetPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetPreset *)soap_instantiate__tptz__SetPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__SetPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPreset, sizeof(_tptz__SetPreset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetPreset(struct soap *soap, _tptz__SetPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__SetPreset(soap, tag ? tag : "tptz:SetPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetPreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetPreset(struct soap *soap, _tptz__SetPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresets(struct soap *soap, _tptz__GetPresets *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresets))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresets(struct soap *soap, const char *tag, int id, _tptz__GetPresets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresets, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetPresets ? type : NULL);
}

SOAP_FMAC3 _tptz__GetPresets ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresets(struct soap *soap, const char *tag, _tptz__GetPresets **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresets **)soap_malloc(soap, sizeof(_tptz__GetPresets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresets *)soap_instantiate__tptz__GetPresets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetPresets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresets, sizeof(_tptz__GetPresets), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresets(struct soap *soap, _tptz__GetPresets *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetPresets(soap, tag ? tag : "tptz:GetPresets", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresets ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresets(struct soap *soap, _tptz__GetPresets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurations(struct soap *soap, _tptz__GetConfigurations *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurations(struct soap *soap, const char *tag, int id, _tptz__GetConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurations, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetConfigurations ? type : NULL);
}

SOAP_FMAC3 _tptz__GetConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurations(struct soap *soap, const char *tag, _tptz__GetConfigurations **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfigurations **)soap_malloc(soap, sizeof(_tptz__GetConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfigurations *)soap_instantiate__tptz__GetConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurations, sizeof(_tptz__GetConfigurations), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurations(struct soap *soap, _tptz__GetConfigurations *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetConfigurations(soap, tag ? tag : "tptz:GetConfigurations", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurations(struct soap *soap, _tptz__GetConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, _tptz__GetServiceCapabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _tptz__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetServiceCapabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE__tptz__GetServiceCapabilities ? type : NULL);
}

SOAP_FMAC3 _tptz__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, const char *tag, _tptz__GetServiceCapabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetServiceCapabilities **)soap_malloc(soap, sizeof(_tptz__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetServiceCapabilities *)soap_instantiate__tptz__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (_tptz__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(_tptz__GetServiceCapabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, _tptz__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_tptz__GetServiceCapabilities(soap, tag ? tag : "tptz:GetServiceCapabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, _tptz__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension *)soap_instantiate_tt__PTZConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag ? tag : "tt:PTZConfigurationExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ZoomLimits ? type : NULL);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ZoomLimits **)soap_malloc(soap, sizeof(tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ZoomLimits *)soap_instantiate_tt__ZoomLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ZoomLimits(soap, tag ? tag : "tt:ZoomLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PanTiltLimits ? type : NULL);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PanTiltLimits **)soap_malloc(soap, sizeof(tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PanTiltLimits *)soap_instantiate_tt__PanTiltLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PanTiltLimits(soap, tag ? tag : "tt:PanTiltLimits", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, int id, tt__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZNodeExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, tt__PTZNodeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZNodeExtension **)soap_malloc(soap, sizeof(tt__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZNodeExtension *)soap_instantiate_tt__PTZNodeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZNodeExtension(soap, tag ? tag : "tt:PTZNodeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_double);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTodouble(soap, tag ? tag : "double", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__MoveStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveStatus(struct soap *soap, const char *tag, int id, enum tt__MoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_in_PointerTott__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__MoveStatus **)soap_malloc(soap, sizeof(enum tt__MoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__MoveStatus(soap, tag ? tag : "tt:MoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_get_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZMoveStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, int id, tt__PTZMoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZMoveStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZMoveStatus ? type : NULL);
}

SOAP_FMAC3 tt__PTZMoveStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, tt__PTZMoveStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZMoveStatus **)soap_malloc(soap, sizeof(tt__PTZMoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZMoveStatus *)soap_instantiate_tt__PTZMoveStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZMoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(tt__PTZMoveStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZMoveStatus(soap, tag ? tag : "tt:PTZMoveStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZMoveStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZMoveStatus(struct soap *soap, tt__PTZMoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__anyURI(soap, tag ? tag : "xsd:anyURI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, tt__PTZPresetTourStartingConditionOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, int id, tt__PTZPresetTourStartingConditionOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourStartingConditionOptionsExtension **)soap_malloc(soap, sizeof(tt__PTZPresetTourStartingConditionOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourStartingConditionOptionsExtension *)soap_instantiate_tt__PTZPresetTourStartingConditionOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(tt__PTZPresetTourStartingConditionOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, tt__PTZPresetTourStartingConditionOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, tt__PTZPresetTourStartingConditionOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__IntRange ? type : NULL);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, tt__IntRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRange **)soap_malloc(soap, sizeof(tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRange *)soap_instantiate_tt__IntRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, tt__IntRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntRange(soap, tag ? tag : "tt:IntRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, tt__PTZPresetTourPresetDetailOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, int id, tt__PTZPresetTourPresetDetailOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetailOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourPresetDetailOptionsExtension **)soap_malloc(soap, sizeof(tt__PTZPresetTourPresetDetailOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourPresetDetailOptionsExtension *)soap_instantiate_tt__PTZPresetTourPresetDetailOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourPresetDetailOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(tt__PTZPresetTourPresetDetailOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, tt__PTZPresetTourPresetDetailOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, tt__PTZPresetTourPresetDetailOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, tt__PTZPresetTourPresetDetailOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, int id, tt__PTZPresetTourPresetDetailOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetailOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourPresetDetailOptions **)soap_malloc(soap, sizeof(tt__PTZPresetTourPresetDetailOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourPresetDetailOptions *)soap_instantiate_tt__PTZPresetTourPresetDetailOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourPresetDetailOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(tt__PTZPresetTourPresetDetailOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, tt__PTZPresetTourPresetDetailOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptions(soap, tag ? tag : "tt:PTZPresetTourPresetDetailOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetailOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, tt__PTZPresetTourPresetDetailOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetailOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, tt__PTZPresetTourSpotOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpotOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, int id, tt__PTZPresetTourSpotOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpotOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourSpotOptions ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourSpotOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, tt__PTZPresetTourSpotOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourSpotOptions **)soap_malloc(soap, sizeof(tt__PTZPresetTourSpotOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourSpotOptions *)soap_instantiate_tt__PTZPresetTourSpotOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourSpotOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(tt__PTZPresetTourSpotOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, tt__PTZPresetTourSpotOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSpotOptions(soap, tag ? tag : "tt:PTZPresetTourSpotOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourSpotOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, tt__PTZPresetTourSpotOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpotOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, tt__PTZPresetTourStartingConditionOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, int id, tt__PTZPresetTourStartingConditionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourStartingConditionOptions **)soap_malloc(soap, sizeof(tt__PTZPresetTourStartingConditionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourStartingConditionOptions *)soap_instantiate_tt__PTZPresetTourStartingConditionOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(tt__PTZPresetTourStartingConditionOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, tt__PTZPresetTourStartingConditionOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptions(soap, tag ? tag : "tt:PTZPresetTourStartingConditionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, tt__PTZPresetTourStartingConditionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, tt__PTZPresetTourStartingConditionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, int id, tt__PTZPresetTourStartingConditionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStartingConditionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourStartingConditionExtension **)soap_malloc(soap, sizeof(tt__PTZPresetTourStartingConditionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourStartingConditionExtension *)soap_instantiate_tt__PTZPresetTourStartingConditionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourStartingConditionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(tt__PTZPresetTourStartingConditionExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, tt__PTZPresetTourStartingConditionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStartingConditionExtension(soap, tag ? tag : "tt:PTZPresetTourStartingConditionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourStartingConditionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, tt__PTZPresetTourStartingConditionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourDirection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourDirection(struct soap *soap, const char *tag, int id, enum tt__PTZPresetTourDirection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourDirection, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourDirection(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourDirection(struct soap *soap, const char *tag, enum tt__PTZPresetTourDirection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PTZPresetTourDirection **)soap_malloc(soap, sizeof(enum tt__PTZPresetTourDirection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourDirection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourDirection(soap, tag ? tag : "tt:PTZPresetTourDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, tt__PTZPresetTourStatusExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStatusExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, int id, tt__PTZPresetTourStatusExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStatusExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourStatusExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourStatusExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, tt__PTZPresetTourStatusExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourStatusExtension **)soap_malloc(soap, sizeof(tt__PTZPresetTourStatusExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourStatusExtension *)soap_instantiate_tt__PTZPresetTourStatusExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourStatusExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(tt__PTZPresetTourStatusExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, tt__PTZPresetTourStatusExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStatusExtension(soap, tag ? tag : "tt:PTZPresetTourStatusExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourStatusExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, tt__PTZPresetTourStatusExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, tt__PTZPresetTourTypeExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourTypeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, int id, tt__PTZPresetTourTypeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourTypeExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourTypeExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourTypeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, tt__PTZPresetTourTypeExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourTypeExtension **)soap_malloc(soap, sizeof(tt__PTZPresetTourTypeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourTypeExtension *)soap_instantiate_tt__PTZPresetTourTypeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourTypeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(tt__PTZPresetTourTypeExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, tt__PTZPresetTourTypeExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourTypeExtension(soap, tag ? tag : "tt:PTZPresetTourTypeExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourTypeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, tt__PTZPresetTourTypeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourTypeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, tt__PTZPresetTourSpotExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpotExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, int id, tt__PTZPresetTourSpotExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpotExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourSpotExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourSpotExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, tt__PTZPresetTourSpotExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourSpotExtension **)soap_malloc(soap, sizeof(tt__PTZPresetTourSpotExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourSpotExtension *)soap_instantiate_tt__PTZPresetTourSpotExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourSpotExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(tt__PTZPresetTourSpotExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, tt__PTZPresetTourSpotExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSpotExtension(soap, tag ? tag : "tt:PTZPresetTourSpotExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourSpotExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, tt__PTZPresetTourSpotExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpotExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, tt__PTZPresetTourPresetDetail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetail))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, int id, tt__PTZPresetTourPresetDetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetail, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourPresetDetail ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetail ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, tt__PTZPresetTourPresetDetail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourPresetDetail **)soap_malloc(soap, sizeof(tt__PTZPresetTourPresetDetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourPresetDetail *)soap_instantiate_tt__PTZPresetTourPresetDetail(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourPresetDetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(tt__PTZPresetTourPresetDetail), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, tt__PTZPresetTourPresetDetail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourPresetDetail(soap, tag ? tag : "tt:PTZPresetTourPresetDetail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourPresetDetail ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, tt__PTZPresetTourPresetDetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourExtension(struct soap *soap, tt__PTZPresetTourExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourExtension(struct soap *soap, const char *tag, int id, tt__PTZPresetTourExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourExtension(struct soap *soap, const char *tag, tt__PTZPresetTourExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourExtension **)soap_malloc(soap, sizeof(tt__PTZPresetTourExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourExtension *)soap_instantiate_tt__PTZPresetTourExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(tt__PTZPresetTourExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourExtension(struct soap *soap, tt__PTZPresetTourExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourExtension(soap, tag ? tag : "tt:PTZPresetTourExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourExtension(struct soap *soap, tt__PTZPresetTourExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpot(struct soap *soap, tt__PTZPresetTourSpot *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, tt__PTZPresetTourSpot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpot, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourSpot ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourSpot ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, tt__PTZPresetTourSpot **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourSpot **)soap_malloc(soap, sizeof(tt__PTZPresetTourSpot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourSpot *)soap_instantiate_tt__PTZPresetTourSpot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourSpot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(tt__PTZPresetTourSpot), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpot(struct soap *soap, tt__PTZPresetTourSpot *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSpot(soap, tag ? tag : "tt:PTZPresetTourSpot", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourSpot ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpot(struct soap *soap, tt__PTZPresetTourSpot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, tt__PTZPresetTourStartingCondition *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingCondition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, int id, tt__PTZPresetTourStartingCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingCondition, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourStartingCondition ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourStartingCondition ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, tt__PTZPresetTourStartingCondition **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourStartingCondition **)soap_malloc(soap, sizeof(tt__PTZPresetTourStartingCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourStartingCondition *)soap_instantiate_tt__PTZPresetTourStartingCondition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourStartingCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(tt__PTZPresetTourStartingCondition), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, tt__PTZPresetTourStartingCondition *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStartingCondition(soap, tag ? tag : "tt:PTZPresetTourStartingCondition", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourStartingCondition ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, tt__PTZPresetTourStartingCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStatus(struct soap *soap, tt__PTZPresetTourStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStatus(struct soap *soap, const char *tag, int id, tt__PTZPresetTourStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourStatus ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStatus(struct soap *soap, const char *tag, tt__PTZPresetTourStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourStatus **)soap_malloc(soap, sizeof(tt__PTZPresetTourStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourStatus *)soap_instantiate_tt__PTZPresetTourStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(tt__PTZPresetTourStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStatus(struct soap *soap, tt__PTZPresetTourStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourStatus(soap, tag ? tag : "tt:PTZPresetTourStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStatus(struct soap *soap, tt__PTZPresetTourStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Name(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Name))
		soap_serialize_tt__Name(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Name(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Name, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Name(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__Name(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Name(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Name, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Name(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Name(soap, tag ? tag : "tt:Name", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__Name(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap *soap, tt__Vector1D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector1D))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap *soap, const char *tag, int id, tt__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector1D, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Vector1D ? type : NULL);
}

SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap *soap, const char *tag, tt__Vector1D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector1D **)soap_malloc(soap, sizeof(tt__Vector1D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector1D *)soap_instantiate_tt__Vector1D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(tt__Vector1D), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap *soap, tt__Vector1D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector1D(soap, tag ? tag : "tt:Vector1D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap *soap, tt__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap *soap, tt__Vector2D *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector2D))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap *soap, const char *tag, int id, tt__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector2D, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Vector2D ? type : NULL);
}

SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap *soap, const char *tag, tt__Vector2D **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Vector2D **)soap_malloc(soap, sizeof(tt__Vector2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Vector2D *)soap_instantiate_tt__Vector2D(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(tt__Vector2D), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap *soap, tt__Vector2D *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Vector2D(soap, tag ? tag : "tt:Vector2D", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap *soap, tt__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, tt__FloatRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__FloatRange ? type : NULL);
}

SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, tt__FloatRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FloatRange **)soap_malloc(soap, sizeof(tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FloatRange *)soap_instantiate_tt__FloatRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, tt__FloatRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__FloatRange(soap, tag ? tag : "tt:FloatRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpacesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpacesExtension(struct soap *soap, const char *tag, int id, tt__PTZSpacesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpacesExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZSpacesExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZSpacesExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZSpacesExtension(struct soap *soap, const char *tag, tt__PTZSpacesExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZSpacesExtension **)soap_malloc(soap, sizeof(tt__PTZSpacesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZSpacesExtension *)soap_instantiate_tt__PTZSpacesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZSpacesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(tt__PTZSpacesExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZSpacesExtension(soap, tag ? tag : "tt:PTZSpacesExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZSpacesExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZSpacesExtension(struct soap *soap, tt__PTZSpacesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space1DDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, tt__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space1DDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Space1DDescription ? type : NULL);
}

SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap *soap, const char *tag, tt__Space1DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Space1DDescription **)soap_malloc(soap, sizeof(tt__Space1DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Space1DDescription *)soap_instantiate_tt__Space1DDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(tt__Space1DDescription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space1DDescription(soap, tag ? tag : "tt:Space1DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap *soap, tt__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space2DDescription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, tt__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space2DDescription, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Space2DDescription ? type : NULL);
}

SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap *soap, const char *tag, tt__Space2DDescription **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Space2DDescription **)soap_malloc(soap, sizeof(tt__Space2DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Space2DDescription *)soap_instantiate_tt__Space2DDescription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(tt__Space2DDescription), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Space2DDescription(soap, tag ? tag : "tt:Space2DDescription", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap *soap, tt__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReverseOptionsExtension(struct soap *soap, tt__ReverseOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReverseOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReverseOptionsExtension(struct soap *soap, const char *tag, int id, tt__ReverseOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReverseOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ReverseOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__ReverseOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ReverseOptionsExtension(struct soap *soap, const char *tag, tt__ReverseOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ReverseOptionsExtension **)soap_malloc(soap, sizeof(tt__ReverseOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ReverseOptionsExtension *)soap_instantiate_tt__ReverseOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ReverseOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(tt__ReverseOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReverseOptionsExtension(struct soap *soap, tt__ReverseOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReverseOptionsExtension(soap, tag ? tag : "tt:ReverseOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ReverseOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ReverseOptionsExtension(struct soap *soap, tt__ReverseOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReverseOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlipOptionsExtension(struct soap *soap, tt__EFlipOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlipOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlipOptionsExtension(struct soap *soap, const char *tag, int id, tt__EFlipOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlipOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EFlipOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__EFlipOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__EFlipOptionsExtension(struct soap *soap, const char *tag, tt__EFlipOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EFlipOptionsExtension **)soap_malloc(soap, sizeof(tt__EFlipOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EFlipOptionsExtension *)soap_instantiate_tt__EFlipOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EFlipOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(tt__EFlipOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlipOptionsExtension(struct soap *soap, tt__EFlipOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlipOptionsExtension(soap, tag ? tag : "tt:EFlipOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EFlipOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__EFlipOptionsExtension(struct soap *soap, tt__EFlipOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlipOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, tt__PTControlDirectionOptionsExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, int id, tt__PTControlDirectionOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTControlDirectionOptionsExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTControlDirectionOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, tt__PTControlDirectionOptionsExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTControlDirectionOptionsExtension **)soap_malloc(soap, sizeof(tt__PTControlDirectionOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTControlDirectionOptionsExtension *)soap_instantiate_tt__PTControlDirectionOptionsExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTControlDirectionOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(tt__PTControlDirectionOptionsExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, tt__PTControlDirectionOptionsExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirectionOptionsExtension(soap, tag ? tag : "tt:PTControlDirectionOptionsExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTControlDirectionOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, tt__PTControlDirectionOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReverseOptions(struct soap *soap, tt__ReverseOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReverseOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReverseOptions(struct soap *soap, const char *tag, int id, tt__ReverseOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReverseOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__ReverseOptions ? type : NULL);
}

SOAP_FMAC3 tt__ReverseOptions ** SOAP_FMAC4 soap_in_PointerTott__ReverseOptions(struct soap *soap, const char *tag, tt__ReverseOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ReverseOptions **)soap_malloc(soap, sizeof(tt__ReverseOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ReverseOptions *)soap_instantiate_tt__ReverseOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__ReverseOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseOptions, sizeof(tt__ReverseOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReverseOptions(struct soap *soap, tt__ReverseOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReverseOptions(soap, tag ? tag : "tt:ReverseOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ReverseOptions ** SOAP_FMAC4 soap_get_PointerTott__ReverseOptions(struct soap *soap, tt__ReverseOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReverseOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlipOptions(struct soap *soap, tt__EFlipOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlipOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlipOptions(struct soap *soap, const char *tag, int id, tt__EFlipOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlipOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EFlipOptions ? type : NULL);
}

SOAP_FMAC3 tt__EFlipOptions ** SOAP_FMAC4 soap_in_PointerTott__EFlipOptions(struct soap *soap, const char *tag, tt__EFlipOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EFlipOptions **)soap_malloc(soap, sizeof(tt__EFlipOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EFlipOptions *)soap_instantiate_tt__EFlipOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EFlipOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipOptions, sizeof(tt__EFlipOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlipOptions(struct soap *soap, tt__EFlipOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlipOptions(soap, tag ? tag : "tt:EFlipOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EFlipOptions ** SOAP_FMAC4 soap_get_PointerTott__EFlipOptions(struct soap *soap, tt__EFlipOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlipOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntAttrList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntAttrList))
		soap_serialize_tt__IntAttrList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntAttrList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntAttrList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntAttrList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__IntAttrList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntAttrList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntAttrList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntAttrList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__IntAttrList(soap, tag ? tag : "tt:IntAttrList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__IntAttrList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationOptions2(struct soap *soap, tt__PTZConfigurationOptions2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationOptions2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationOptions2(struct soap *soap, const char *tag, int id, tt__PTZConfigurationOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationOptions2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationOptions2 ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationOptions2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationOptions2(struct soap *soap, const char *tag, tt__PTZConfigurationOptions2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationOptions2 **)soap_malloc(soap, sizeof(tt__PTZConfigurationOptions2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationOptions2 *)soap_instantiate_tt__PTZConfigurationOptions2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(tt__PTZConfigurationOptions2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationOptions2(struct soap *soap, tt__PTZConfigurationOptions2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationOptions2(soap, tag ? tag : "tt:PTZConfigurationOptions2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationOptions2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationOptions2(struct soap *soap, tt__PTZConfigurationOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionOptions(struct soap *soap, tt__PTControlDirectionOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionOptions(struct soap *soap, const char *tag, int id, tt__PTControlDirectionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTControlDirectionOptions ? type : NULL);
}

SOAP_FMAC3 tt__PTControlDirectionOptions ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionOptions(struct soap *soap, const char *tag, tt__PTControlDirectionOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTControlDirectionOptions **)soap_malloc(soap, sizeof(tt__PTControlDirectionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTControlDirectionOptions *)soap_instantiate_tt__PTControlDirectionOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTControlDirectionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(tt__PTControlDirectionOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionOptions(struct soap *soap, tt__PTControlDirectionOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirectionOptions(soap, tag ? tag : "tt:PTControlDirectionOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTControlDirectionOptions ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionOptions(struct soap *soap, tt__PTControlDirectionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DurationRange(struct soap *soap, tt__DurationRange *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DurationRange))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DurationRange(struct soap *soap, const char *tag, int id, tt__DurationRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DurationRange, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__DurationRange ? type : NULL);
}

SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_in_PointerTott__DurationRange(struct soap *soap, const char *tag, tt__DurationRange **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__DurationRange **)soap_malloc(soap, sizeof(tt__DurationRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__DurationRange *)soap_instantiate_tt__DurationRange(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__DurationRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DurationRange(struct soap *soap, tt__DurationRange *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__DurationRange(soap, tag ? tag : "tt:DurationRange", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__DurationRange ** SOAP_FMAC4 soap_get_PointerTott__DurationRange(struct soap *soap, tt__DurationRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpaces(struct soap *soap, tt__PTZSpaces *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpaces))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpaces(struct soap *soap, const char *tag, int id, tt__PTZSpaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpaces, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZSpaces ? type : NULL);
}

SOAP_FMAC3 tt__PTZSpaces ** SOAP_FMAC4 soap_in_PointerTott__PTZSpaces(struct soap *soap, const char *tag, tt__PTZSpaces **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZSpaces **)soap_malloc(soap, sizeof(tt__PTZSpaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZSpaces *)soap_instantiate_tt__PTZSpaces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZSpaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpaces, sizeof(tt__PTZSpaces), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpaces(struct soap *soap, tt__PTZSpaces *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZSpaces(soap, tag ? tag : "tt:PTZSpaces", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZSpaces ** SOAP_FMAC4 soap_get_PointerTott__PTZSpaces(struct soap *soap, tt__PTZSpaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, tt__PTControlDirectionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTControlDirectionExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, tt__PTControlDirectionExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTControlDirectionExtension **)soap_malloc(soap, sizeof(tt__PTControlDirectionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTControlDirectionExtension *)soap_instantiate_tt__PTControlDirectionExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTControlDirectionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(tt__PTControlDirectionExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, tag ? tag : "tt:PTControlDirectionExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionExtension(struct soap *soap, tt__PTControlDirectionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Reverse(struct soap *soap, tt__Reverse *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Reverse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Reverse(struct soap *soap, const char *tag, int id, tt__Reverse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Reverse, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__Reverse ? type : NULL);
}

SOAP_FMAC3 tt__Reverse ** SOAP_FMAC4 soap_in_PointerTott__Reverse(struct soap *soap, const char *tag, tt__Reverse **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Reverse **)soap_malloc(soap, sizeof(tt__Reverse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Reverse *)soap_instantiate_tt__Reverse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__Reverse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Reverse, sizeof(tt__Reverse), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Reverse(struct soap *soap, tt__Reverse *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__Reverse(soap, tag ? tag : "tt:Reverse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Reverse ** SOAP_FMAC4 soap_get_PointerTott__Reverse(struct soap *soap, tt__Reverse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlip(struct soap *soap, tt__EFlip *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlip))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlip(struct soap *soap, const char *tag, int id, tt__EFlip *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlip, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__EFlip ? type : NULL);
}

SOAP_FMAC3 tt__EFlip ** SOAP_FMAC4 soap_in_PointerTott__EFlip(struct soap *soap, const char *tag, tt__EFlip **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EFlip **)soap_malloc(soap, sizeof(tt__EFlip *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EFlip *)soap_instantiate_tt__EFlip(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__EFlip **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlip, sizeof(tt__EFlip), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlip(struct soap *soap, tt__EFlip *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__EFlip(soap, tag ? tag : "tt:EFlip", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EFlip ** SOAP_FMAC4 soap_get_PointerTott__EFlip(struct soap *soap, tt__EFlip **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, tt__PTZConfigurationExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension2 **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension2 *)soap_instantiate_tt__PTZConfigurationExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(tt__PTZConfigurationExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, tag ? tag : "tt:PTZConfigurationExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension2(struct soap *soap, tt__PTZConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirection))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirection(struct soap *soap, const char *tag, int id, tt__PTControlDirection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirection, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTControlDirection ? type : NULL);
}

SOAP_FMAC3 tt__PTControlDirection ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirection(struct soap *soap, const char *tag, tt__PTControlDirection **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTControlDirection **)soap_malloc(soap, sizeof(tt__PTControlDirection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTControlDirection *)soap_instantiate_tt__PTControlDirection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTControlDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirection, sizeof(tt__PTControlDirection), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTControlDirection(soap, tag ? tag : "tt:PTControlDirection", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTControlDirection ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirection(struct soap *soap, tt__PTControlDirection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, tt__PTZPresetTourSupportedExtension *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, int id, tt__PTZPresetTourSupportedExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourSupportedExtension ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourSupportedExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, tt__PTZPresetTourSupportedExtension **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourSupportedExtension **)soap_malloc(soap, sizeof(tt__PTZPresetTourSupportedExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourSupportedExtension *)soap_instantiate_tt__PTZPresetTourSupportedExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourSupportedExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(tt__PTZPresetTourSupportedExtension), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, tt__PTZPresetTourSupportedExtension *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSupportedExtension(soap, tag ? tag : "tt:PTZPresetTourSupportedExtension", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourSupportedExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, tt__PTZPresetTourSupportedExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSupportedExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension2(struct soap *soap, tt__PTZNodeExtension2 *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension2))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension2(struct soap *soap, const char *tag, int id, tt__PTZNodeExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension2, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZNodeExtension2 ? type : NULL);
}

SOAP_FMAC3 tt__PTZNodeExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension2(struct soap *soap, const char *tag, tt__PTZNodeExtension2 **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZNodeExtension2 **)soap_malloc(soap, sizeof(tt__PTZNodeExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZNodeExtension2 *)soap_instantiate_tt__PTZNodeExtension2(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZNodeExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(tt__PTZNodeExtension2), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension2(struct soap *soap, tt__PTZNodeExtension2 *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZNodeExtension2(soap, tag ? tag : "tt:PTZNodeExtension2", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZNodeExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension2(struct soap *soap, tt__PTZNodeExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSupported(struct soap *soap, tt__PTZPresetTourSupported *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSupported))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSupported(struct soap *soap, const char *tag, int id, tt__PTZPresetTourSupported *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSupported, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourSupported ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourSupported ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSupported(struct soap *soap, const char *tag, tt__PTZPresetTourSupported **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourSupported **)soap_malloc(soap, sizeof(tt__PTZPresetTourSupported *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourSupported *)soap_instantiate_tt__PTZPresetTourSupported(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourSupported **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(tt__PTZPresetTourSupported), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSupported(struct soap *soap, tt__PTZPresetTourSupported *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourSupported(soap, tag ? tag : "tt:PTZPresetTourSupported", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourSupported ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSupported(struct soap *soap, tt__PTZPresetTourSupported **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSupported(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__integer(soap, tag ? tag : "xsd:integer", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourOptions(struct soap *soap, tt__PTZPresetTourOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourOptions(struct soap *soap, const char *tag, int id, tt__PTZPresetTourOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPresetTourOptions ? type : NULL);
}

SOAP_FMAC3 tt__PTZPresetTourOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourOptions(struct soap *soap, const char *tag, tt__PTZPresetTourOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourOptions **)soap_malloc(soap, sizeof(tt__PTZPresetTourOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourOptions *)soap_instantiate_tt__PTZPresetTourOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(tt__PTZPresetTourOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourOptions(struct soap *soap, tt__PTZPresetTourOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPresetTourOptions(soap, tag ? tag : "tt:PTZPresetTourOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourOptions(struct soap *soap, tt__PTZPresetTourOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PresetTour(struct soap *soap, tt__PresetTour *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PresetTour(struct soap *soap, const char *tag, int id, tt__PresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PresetTour, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PresetTour ? type : NULL);
}

SOAP_FMAC3 tt__PresetTour ** SOAP_FMAC4 soap_in_PointerTott__PresetTour(struct soap *soap, const char *tag, tt__PresetTour **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PresetTour **)soap_malloc(soap, sizeof(tt__PresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PresetTour *)soap_instantiate_tt__PresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PresetTour, sizeof(tt__PresetTour), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PresetTour(struct soap *soap, tt__PresetTour *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PresetTour(soap, tag ? tag : "tt:PresetTour", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PresetTour ** SOAP_FMAC4 soap_get_PointerTott__PresetTour(struct soap *soap, tt__PresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTofloat(soap, tag ? tag : "float", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GeoLocation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GeoLocation(struct soap *soap, const char *tag, int id, tt__GeoLocation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GeoLocation, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__GeoLocation ? type : NULL);
}

SOAP_FMAC3 tt__GeoLocation ** SOAP_FMAC4 soap_in_PointerTott__GeoLocation(struct soap *soap, const char *tag, tt__GeoLocation **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GeoLocation **)soap_malloc(soap, sizeof(tt__GeoLocation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GeoLocation *)soap_instantiate_tt__GeoLocation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__GeoLocation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GeoLocation, sizeof(tt__GeoLocation), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__GeoLocation(soap, tag ? tag : "tt:GeoLocation", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GeoLocation ** SOAP_FMAC4 soap_get_PointerTott__GeoLocation(struct soap *soap, tt__GeoLocation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GeoLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZVector(struct soap *soap, tt__PTZVector *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZVector))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZVector(struct soap *soap, const char *tag, int id, tt__PTZVector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZVector, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZVector ? type : NULL);
}

SOAP_FMAC3 tt__PTZVector ** SOAP_FMAC4 soap_in_PointerTott__PTZVector(struct soap *soap, const char *tag, tt__PTZVector **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZVector **)soap_malloc(soap, sizeof(tt__PTZVector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZVector *)soap_instantiate_tt__PTZVector(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZVector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZVector, sizeof(tt__PTZVector), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZVector(struct soap *soap, tt__PTZVector *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZVector(soap, tag ? tag : "tt:PTZVector", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZVector ** SOAP_FMAC4 soap_get_PointerTott__PTZVector(struct soap *soap, tt__PTZVector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__duration))
		soap_serialize_xsd__duration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToxsd__duration(soap, tag ? tag : "xsd:duration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatus(struct soap *soap, tt__PTZStatus *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatus(struct soap *soap, const char *tag, int id, tt__PTZStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatus, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZStatus ? type : NULL);
}

SOAP_FMAC3 tt__PTZStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZStatus(struct soap *soap, const char *tag, tt__PTZStatus **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZStatus **)soap_malloc(soap, sizeof(tt__PTZStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZStatus *)soap_instantiate_tt__PTZStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatus, sizeof(tt__PTZStatus), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatus(struct soap *soap, tt__PTZStatus *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZStatus(soap, tag ? tag : "tt:PTZStatus", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZStatus(struct soap *soap, tt__PTZStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpeed))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpeed(struct soap *soap, const char *tag, int id, tt__PTZSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpeed, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZSpeed ? type : NULL);
}

SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTott__PTZSpeed(struct soap *soap, const char *tag, tt__PTZSpeed **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZSpeed **)soap_malloc(soap, sizeof(tt__PTZSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZSpeed *)soap_instantiate_tt__PTZSpeed(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpeed, sizeof(tt__PTZSpeed), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZSpeed(soap, tag ? tag : "tt:PTZSpeed", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTott__PTZSpeed(struct soap *soap, tt__PTZSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReferenceToken(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken))
		soap_serialize_tt__ReferenceToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReferenceToken(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReferenceToken, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__ReferenceToken(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReferenceToken, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReferenceToken(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__ReferenceToken(soap, tag ? tag : "tt:ReferenceToken", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__ReferenceToken(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostd__string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPreset(struct soap *soap, tt__PTZPreset *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPreset(struct soap *soap, const char *tag, int id, tt__PTZPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPreset, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZPreset ? type : NULL);
}

SOAP_FMAC3 tt__PTZPreset ** SOAP_FMAC4 soap_in_PointerTott__PTZPreset(struct soap *soap, const char *tag, tt__PTZPreset **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPreset **)soap_malloc(soap, sizeof(tt__PTZPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPreset *)soap_instantiate_tt__PTZPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPreset, sizeof(tt__PTZPreset), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPreset(struct soap *soap, tt__PTZPreset *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZPreset(soap, tag ? tag : "tt:PTZPreset", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPreset ** SOAP_FMAC4 soap_get_PointerTott__PTZPreset(struct soap *soap, tt__PTZPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, tt__PTZConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationOptions, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfigurationOptions ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationOptions(struct soap *soap, const char *tag, tt__PTZConfigurationOptions **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationOptions **)soap_malloc(soap, sizeof(tt__PTZConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationOptions *)soap_instantiate_tt__PTZConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(tt__PTZConfigurationOptions), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfigurationOptions(soap, tag ? tag : "tt:PTZConfigurationOptions", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence))
		soap_serialize___tptz__SetConfigurationResponse_sequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, int id, struct __tptz__SetConfigurationResponse_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, NULL);
	if (id < 0)
		return soap->error;
	return soap_out___tptz__SetConfigurationResponse_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence ** SOAP_FMAC4 soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, struct __tptz__SetConfigurationResponse_sequence **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tptz__SetConfigurationResponse_sequence **)soap_malloc(soap, sizeof(struct __tptz__SetConfigurationResponse_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tptz__SetConfigurationResponse_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tptz__SetConfigurationResponse_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(soap, tag ? tag : "-tptz:SetConfigurationResponse-sequence", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence ** SOAP_FMAC4 soap_get_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, tt__PTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfiguration, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZConfiguration ? type : NULL);
}

SOAP_FMAC3 tt__PTZConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfiguration **)soap_malloc(soap, sizeof(tt__PTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfiguration *)soap_instantiate_tt__PTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfiguration, sizeof(tt__PTZConfiguration), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZConfiguration(soap, tag ? tag : "tt:PTZConfiguration", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNode(struct soap *soap, tt__PTZNode *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNode(struct soap *soap, const char *tag, int id, tt__PTZNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNode, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tt__PTZNode ? type : NULL);
}

SOAP_FMAC3 tt__PTZNode ** SOAP_FMAC4 soap_in_PointerTott__PTZNode(struct soap *soap, const char *tag, tt__PTZNode **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZNode **)soap_malloc(soap, sizeof(tt__PTZNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZNode *)soap_instantiate_tt__PTZNode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tt__PTZNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNode, sizeof(tt__PTZNode), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNode(struct soap *soap, tt__PTZNode *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__PTZNode(soap, tag ? tag : "tt:PTZNode", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZNode ** SOAP_FMAC4 soap_get_PointerTott__PTZNode(struct soap *soap, tt__PTZNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotptz__Capabilities(struct soap *soap, tptz__Capabilities *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tptz__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotptz__Capabilities(struct soap *soap, const char *tag, int id, tptz__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tptz__Capabilities, NULL);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, (*a)->soap_type() == SOAP_TYPE_tptz__Capabilities ? type : NULL);
}

SOAP_FMAC3 tptz__Capabilities ** SOAP_FMAC4 soap_in_PointerTotptz__Capabilities(struct soap *soap, const char *tag, tptz__Capabilities **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tptz__Capabilities **)soap_malloc(soap, sizeof(tptz__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tptz__Capabilities *)soap_instantiate_tptz__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
		{	*a = NULL;
			return NULL;
		}
	}
	else
	{	a = (tptz__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tptz__Capabilities, sizeof(tptz__Capabilities), 0, soap_fbase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotptz__Capabilities(struct soap *soap, tptz__Capabilities *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTotptz__Capabilities(soap, tag ? tag : "tptz:Capabilities", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tptz__Capabilities ** SOAP_FMAC4 soap_get_PointerTotptz__Capabilities(struct soap *soap, tptz__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotptz__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StringList(struct soap *soap, std::string *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StringList))
		soap_serialize_tt__StringList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StringList(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StringList, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StringList(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTott__StringList(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StringList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StringList, sizeof(std::string), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StringList(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTott__StringList(soap, tag ? tag : "tt:StringList", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTott__StringList(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StringList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTobool(struct soap *soap, bool *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_bool);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTobool(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_bool, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_bool(soap, tag, id, *a, type);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_in_PointerTobool(struct soap *soap, const char *tag, bool **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (bool **)soap_malloc(soap, sizeof(bool *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_bool(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_bool, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTobool(struct soap *soap, bool *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTobool(soap, tag ? tag : "boolean", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool ** SOAP_FMAC4 soap_get_PointerTobool(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTobool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag ? tag : "chan:ChannelInstanceType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag ? tag : "wsa5:FaultTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag ? tag : "wsa5:ReplyTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__From(soap, tag ? tag : "wsa5:From", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo, NULL);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag ? tag : "wsa5:RelatesTo", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemIRI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__ProblemIRI(soap, tag ? tag : "wsa5:ProblemIRI", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__Action(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__Action(soap, tag ? tag : "wsa5:Action", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__To(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__To(soap, tag ? tag : "wsa5:To", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__MessageID(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__wsa5__MessageID(soap, tag ? tag : "wsa5:MessageID", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToint(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__MetadataType(soap, tag ? tag : "wsa5:MetadataType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag ? tag : "wsa5:ReferenceParametersType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag ? tag : "wsa5:FaultCodesOpenEnumType", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag ? tag : "wsa5:RelationshipTypeOpenEnum", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTounsignedByte(soap, tag ? tag : "unsignedByte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *a = static_cast<char * *>(soap_malloc(soap, (n = (n < 0 ? 1 : n)) * sizeof(char *)));
	for (char * *p = a; p && n--; ++p)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__AuxiliaryData(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__AuxiliaryData(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__AuxiliaryData(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__AuxiliaryData(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__AuxiliaryData, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__AuxiliaryData(soap, tag, NULL, "tt:AuxiliaryData"))
				break;
		}
		else
		{	if (!soap_in_tt__AuxiliaryData(soap, tag, &n, "tt:AuxiliaryData"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__AuxiliaryData(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__AuxiliaryData, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, std::vector<enum tt__PTZPresetTourDirection> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const std::vector<enum tt__PTZPresetTourDirection> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const char *tag, int id, const std::vector<enum tt__PTZPresetTourDirection> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__PTZPresetTourDirection> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__PTZPresetTourDirection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__PTZPresetTourDirection> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, const char *tag, std::vector<enum tt__PTZPresetTourDirection> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__PTZPresetTourDirection(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__PTZPresetTourDirection n;
		soap_default_tt__PTZPresetTourDirection(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZPresetTourDirection, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__PTZPresetTourDirection(soap, tag, NULL, "tt:PTZPresetTourDirection"))
				break;
		}
		else
		{	if (!soap_in_tt__PTZPresetTourDirection(soap, tag, &n, "tt:PTZPresetTourDirection"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__PTZPresetTourDirection>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__PTZPresetTourDirection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__PTZPresetTourDirection(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__PTZPresetTourDirection> *p;
	size_t k = sizeof(std::vector<enum tt__PTZPresetTourDirection> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourDirection, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__PTZPresetTourDirection> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__PTZPresetTourDirection> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__PTZPresetTourDirection>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, std::vector<std::string> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const std::vector<std::string> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_tt__ReferenceToken(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, int id, const std::vector<std::string> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<std::string> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReferenceToken(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<std::string> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, const char *tag, std::vector<std::string> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ReferenceToken(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		std::string n;
		soap_default_tt__ReferenceToken(soap, &n);
		short soap_shaky = soap_begin_shaky(soap);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ReferenceToken, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, sizeof(std::string), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ReferenceToken(soap, tag, NULL, "tt:ReferenceToken"))
				break;
		}
		else
		{	if (!soap_in_tt__ReferenceToken(soap, tag, &n, "tt:ReferenceToken"))
				break;
		}
		soap_end_shaky(soap, soap_shaky);
		if (a->size())
		{	const void *p = &*a->begin();
			soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
			if (p != &*a->begin())
			{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container capacity increased: updating pointers\n"));
				soap_update_pointers(soap, (const char*)&*a->begin(), (const char*)p, (a->size() - 1) * sizeof(std::string));
			}
		}
		else
		{	soap_update_pointers(soap, (const char*)&(*a->insert(a->end(), n)), (const char*)&n, sizeof(std::string));
		}
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<std::string>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReferenceToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReferenceToken(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<std::string> *p;
	size_t k = sizeof(std::vector<std::string> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ReferenceToken, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<std::string> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<std::string> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<std::string>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, std::vector<tt__PTZPresetTourSpot *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const std::vector<tt__PTZPresetTourSpot *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZPresetTourSpot *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZPresetTourSpot(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZPresetTourSpot *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZPresetTourSpot *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZPresetTourSpot(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZPresetTourSpot *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, std::vector<tt__PTZPresetTourSpot *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PTZPresetTourSpot *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZPresetTourSpot, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot, sizeof(tt__PTZPresetTourSpot), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZPresetTourSpot(soap, tag, NULL, "tt:PTZPresetTourSpot"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZPresetTourSpot(soap, tag, &n, "tt:PTZPresetTourSpot"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZPresetTourSpot *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZPresetTourSpot(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZPresetTourSpot *> *p;
	size_t k = sizeof(std::vector<tt__PTZPresetTourSpot *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPresetTourSpot, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZPresetTourSpot *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZPresetTourSpot *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZPresetTourSpot *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, std::vector<tt__Space1DDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const std::vector<tt__Space1DDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Space1DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Space1DDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__Space1DDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Space1DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Space1DDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Space1DDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, const char *tag, std::vector<tt__Space1DDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Space1DDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Space1DDescription *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Space1DDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription, sizeof(tt__Space1DDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Space1DDescription(soap, tag, NULL, "tt:Space1DDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Space1DDescription(soap, tag, &n, "tt:Space1DDescription"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Space1DDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Space1DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Space1DDescription *> *p;
	size_t k = sizeof(std::vector<tt__Space1DDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space1DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Space1DDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Space1DDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Space1DDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, std::vector<tt__Space2DDescription *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const std::vector<tt__Space2DDescription *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__Space2DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__Space2DDescription(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, const std::vector<tt__Space2DDescription *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__Space2DDescription *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__Space2DDescription(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__Space2DDescription *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, const char *tag, std::vector<tt__Space2DDescription *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__Space2DDescription(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__Space2DDescription *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__Space2DDescription, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription, sizeof(tt__Space2DDescription), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__Space2DDescription(soap, tag, NULL, "tt:Space2DDescription"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__Space2DDescription(soap, tag, &n, "tt:Space2DDescription"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__Space2DDescription *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__Space2DDescription(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__Space2DDescription *> *p;
	size_t k = sizeof(std::vector<tt__Space2DDescription *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__Space2DDescription, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__Space2DDescription *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__Space2DDescription *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__Space2DDescription *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__ReverseMode(struct soap *soap, std::vector<enum tt__ReverseMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const std::vector<enum tt__ReverseMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__ReverseMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__ReverseMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__ReverseMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__ReverseMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__ReverseMode(struct soap *soap, const char *tag, std::vector<enum tt__ReverseMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__ReverseMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__ReverseMode n;
		soap_default_tt__ReverseMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__ReverseMode, SOAP_TYPE_std__vectorTemplateOftt__ReverseMode, sizeof(enum tt__ReverseMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__ReverseMode(soap, tag, NULL, "tt:ReverseMode"))
				break;
		}
		else
		{	if (!soap_in_tt__ReverseMode(soap, tag, &n, "tt:ReverseMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__ReverseMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__ReverseMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__ReverseMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__ReverseMode> *p;
	size_t k = sizeof(std::vector<enum tt__ReverseMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__ReverseMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__ReverseMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__ReverseMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__ReverseMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__EFlipMode(struct soap *soap, std::vector<enum tt__EFlipMode> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const std::vector<enum tt__EFlipMode> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const char *tag, int id, const std::vector<enum tt__EFlipMode> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__EFlipMode> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__EFlipMode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__EFlipMode> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__EFlipMode(struct soap *soap, const char *tag, std::vector<enum tt__EFlipMode> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__EFlipMode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__EFlipMode n;
		soap_default_tt__EFlipMode(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__EFlipMode, SOAP_TYPE_std__vectorTemplateOftt__EFlipMode, sizeof(enum tt__EFlipMode), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__EFlipMode(soap, tag, NULL, "tt:EFlipMode"))
				break;
		}
		else
		{	if (!soap_in_tt__EFlipMode(soap, tag, &n, "tt:EFlipMode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__EFlipMode>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__EFlipMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__EFlipMode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__EFlipMode> *p;
	size_t k = sizeof(std::vector<enum tt__EFlipMode> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__EFlipMode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__EFlipMode> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__EFlipMode> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__EFlipMode>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, std::vector<enum tt__PTZPresetTourOperation> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const std::vector<enum tt__PTZPresetTourOperation> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const char *tag, int id, const std::vector<enum tt__PTZPresetTourOperation> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<enum tt__PTZPresetTourOperation> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_tt__PTZPresetTourOperation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<enum tt__PTZPresetTourOperation> * SOAP_FMAC4 soap_in_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, const char *tag, std::vector<enum tt__PTZPresetTourOperation> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOftt__PTZPresetTourOperation(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		enum tt__PTZPresetTourOperation n;
		soap_default_tt__PTZPresetTourOperation(soap, &n);
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZPresetTourOperation, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), 0, soap_finsert, soap_fbase))
				break;
			if (!soap_in_tt__PTZPresetTourOperation(soap, tag, NULL, "tt:PTZPresetTourOperation"))
				break;
		}
		else
		{	if (!soap_in_tt__PTZPresetTourOperation(soap, tag, &n, "tt:PTZPresetTourOperation"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<enum tt__PTZPresetTourOperation>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOftt__PTZPresetTourOperation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOftt__PTZPresetTourOperation(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<enum tt__PTZPresetTourOperation> *p;
	size_t k = sizeof(std::vector<enum tt__PTZPresetTourOperation> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOftt__PTZPresetTourOperation, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<enum tt__PTZPresetTourOperation> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<enum tt__PTZPresetTourOperation> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<enum tt__PTZPresetTourOperation>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, std::vector<tt__PresetTour *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, const std::vector<tt__PresetTour *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PresetTour *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PresetTour(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, const char *tag, int id, const std::vector<tt__PresetTour *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PresetTour *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PresetTour(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PresetTour *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, const char *tag, std::vector<tt__PresetTour *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PresetTour(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PresetTour *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PresetTour, SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour, sizeof(tt__PresetTour), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PresetTour(soap, tag, NULL, "tt:PresetTour"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PresetTour(soap, tag, &n, "tt:PresetTour"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PresetTour *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PresetTour(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PresetTour *> *p;
	size_t k = sizeof(std::vector<tt__PresetTour *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PresetTour, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PresetTour *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PresetTour *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PresetTour *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, std::vector<tt__PTZPreset *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, const std::vector<tt__PTZPreset *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZPreset(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZPreset *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZPreset *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZPreset(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZPreset *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, const char *tag, std::vector<tt__PTZPreset *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZPreset(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PTZPreset *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZPreset, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset, sizeof(tt__PTZPreset), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZPreset(soap, tag, NULL, "tt:PTZPreset"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZPreset(soap, tag, &n, "tt:PTZPreset"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZPreset *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZPreset(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZPreset *> *p;
	size_t k = sizeof(std::vector<tt__PTZPreset *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZPreset, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZPreset *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZPreset *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZPreset *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, std::vector<tt__PTZConfiguration *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, const std::vector<tt__PTZConfiguration *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZConfiguration(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZConfiguration *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZConfiguration *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZConfiguration(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZConfiguration *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, const char *tag, std::vector<tt__PTZConfiguration *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZConfiguration(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PTZConfiguration *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZConfiguration, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration, sizeof(tt__PTZConfiguration), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZConfiguration(soap, tag, NULL, "tt:PTZConfiguration"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZConfiguration(soap, tag, &n, "tt:PTZConfiguration"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZConfiguration *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZConfiguration(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZConfiguration *> *p;
	size_t k = sizeof(std::vector<tt__PTZConfiguration *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZConfiguration, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZConfiguration *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZConfiguration *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZConfiguration *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, std::vector<tt__PTZNode *> *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, const std::vector<tt__PTZNode *> *a)
{
	(void)soap; (void)a;/* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	for (std::vector<tt__PTZNode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTott__PTZNode(soap, &(*i));
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, const char *tag, int id, const std::vector<tt__PTZNode *> *a, const char *type)
{
	(void)id; (void)type; /* appease -Wall -Werror */
	for (std::vector<tt__PTZNode *> ::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTott__PTZNode(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<tt__PTZNode *> * SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, const char *tag, std::vector<tt__PTZNode *> *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	short soap_flag;
	for (soap_flag = 0;; soap_flag = 1)
	{
		if (tag && *tag != '-')
		{	if (soap_element_begin_in(soap, tag, 1, NULL))
				break;
			soap_revert(soap);
		}
		if (!a && !(a = soap_new_std__vectorTemplateOfPointerTott__PTZNode(soap)))
			return NULL;
		else if (static_cast<size_t>(a->size()) > soap->maxoccurs)
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		tt__PTZNode *n;
		n = NULL;
		if (tag && *tag != '-' && (*soap->id || *soap->href == '#'))
		{	if (!soap_id_forward(soap, *soap->id?soap->id:soap->href, a, static_cast<size_t>(a->size()), SOAP_TYPE_tt__PTZNode, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode, sizeof(tt__PTZNode), 1, soap_finsert, soap_fbase))
				break;
			if (!soap_in_PointerTott__PTZNode(soap, tag, NULL, "tt:PTZNode"))
				break;
		}
		else
		{	if (!soap_in_PointerTott__PTZNode(soap, tag, &n, "tt:PTZNode"))
				break;
		}
		a->insert(a->end(), n);
		if (!tag || *tag == '-')
			return a;
	}
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<tt__PTZNode *>  * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTott__PTZNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTott__PTZNode(%p, %d, %s, %s)\n", (void*)soap, n, type?type:"", arrayType?arrayType:""));
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	std::vector<tt__PTZNode *> *p;
	size_t k = sizeof(std::vector<tt__PTZNode *> );
	struct soap_clist *cp = soap_link(soap, SOAP_TYPE_std__vectorTemplateOfPointerTott__PTZNode, n, soap_fdelete);
	if (!cp && soap && n != SOAP_NO_LINK_TO_DELETE)
		return NULL;
	if (n < 0)
	{	p = SOAP_NEW(soap, std::vector<tt__PTZNode *> );
	}
	else
	{	p = SOAP_NEW_ARRAY(soap, std::vector<tt__PTZNode *> , n);
		k *= n;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated std::vector<tt__PTZNode *>  location=%p n=%d\n", (void*)p, n));
	if (size)
		*size = k;
	if (!p)
		soap->error = SOAP_EOM;
	else if (cp)
		cp->ptr = (void*)p;
	return p;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.cpp */
